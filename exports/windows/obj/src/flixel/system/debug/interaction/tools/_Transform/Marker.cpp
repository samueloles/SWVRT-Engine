// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_math__FlxPoint_FlxPoint_Impl_
#include <flixel/math/_FlxPoint/FlxPoint_Impl_.h>
#endif
#ifndef INCLUDED_flixel_system_debug_interaction_tools__Transform_Marker
#include <flixel/system/debug/interaction/tools/_Transform/Marker.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool
#include <flixel/util/FlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_openfl_display_Graphics
#include <openfl/display/Graphics.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_97817d579925b552_267_new,"flixel.system.debug.interaction.tools._Transform.Marker","new",0x70f606d6,"flixel.system.debug.interaction.tools._Transform.Marker.new","flixel/system/debug/interaction/tools/Transform.hx",267,0xb006466c)
HX_LOCAL_STACK_FRAME(_hx_pos_97817d579925b552_290_reposition,"flixel.system.debug.interaction.tools._Transform.Marker","reposition",0x6e5393a6,"flixel.system.debug.interaction.tools._Transform.Marker.reposition","flixel/system/debug/interaction/tools/Transform.hx",290,0xb006466c)
HX_LOCAL_STACK_FRAME(_hx_pos_97817d579925b552_302_draw,"flixel.system.debug.interaction.tools._Transform.Marker","draw",0x5fbd9cce,"flixel.system.debug.interaction.tools._Transform.Marker.draw","flixel/system/debug/interaction/tools/Transform.hx",302,0xb006466c)
HX_LOCAL_STACK_FRAME(_hx_pos_97817d579925b552_269_boot,"flixel.system.debug.interaction.tools._Transform.Marker","boot",0x5e68f4fc,"flixel.system.debug.interaction.tools._Transform.Marker.boot","flixel/system/debug/interaction/tools/Transform.hx",269,0xb006466c)
HX_LOCAL_STACK_FRAME(_hx_pos_97817d579925b552_271_boot,"flixel.system.debug.interaction.tools._Transform.Marker","boot",0x5e68f4fc,"flixel.system.debug.interaction.tools._Transform.Marker.boot","flixel/system/debug/interaction/tools/Transform.hx",271,0xb006466c)
HX_LOCAL_STACK_FRAME(_hx_pos_97817d579925b552_272_boot,"flixel.system.debug.interaction.tools._Transform.Marker","boot",0x5e68f4fc,"flixel.system.debug.interaction.tools._Transform.Marker.boot","flixel/system/debug/interaction/tools/Transform.hx",272,0xb006466c)
HX_LOCAL_STACK_FRAME(_hx_pos_97817d579925b552_273_boot,"flixel.system.debug.interaction.tools._Transform.Marker","boot",0x5e68f4fc,"flixel.system.debug.interaction.tools._Transform.Marker.boot","flixel/system/debug/interaction/tools/Transform.hx",273,0xb006466c)
HX_LOCAL_STACK_FRAME(_hx_pos_97817d579925b552_274_boot,"flixel.system.debug.interaction.tools._Transform.Marker","boot",0x5e68f4fc,"flixel.system.debug.interaction.tools._Transform.Marker.boot","flixel/system/debug/interaction/tools/Transform.hx",274,0xb006466c)
namespace flixel{
namespace _hx_system{
namespace debug{
namespace interaction{
namespace tools{
namespace _Transform{

void Marker_obj::__construct(::String type,bool left,bool up){
            	HX_STACKFRAME(&_hx_pos_97817d579925b552_267_new)
HXLINE( 277)		this->y = ((Float)0);
HXLINE( 276)		this->x = ((Float)0);
HXLINE( 284)		this->type = type;
HXLINE( 285)		this->left = left;
HXLINE( 286)		this->up = up;
            	}

Dynamic Marker_obj::__CreateEmpty() { return new Marker_obj; }

void *Marker_obj::_hx_vtable = 0;

Dynamic Marker_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Marker_obj > _hx_result = new Marker_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2]);
	return _hx_result;
}

bool Marker_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x4b68ec98;
}

void Marker_obj::reposition( ::flixel::FlxSprite target){
            	HX_STACKFRAME(&_hx_pos_97817d579925b552_290_reposition)
HXLINE( 291)		Float w = ((( (Float)(target->frameWidth) ) * target->scale->x) * ((Float)0.5));
HXLINE( 292)		Float h = ((( (Float)(target->frameHeight) ) * target->scale->y) * ((Float)0.5));
HXLINE( 293)		Float x;
HXDLIN( 293)		if (this->left) {
HXLINE( 293)			x = -(w);
            		}
            		else {
HXLINE( 293)			x = w;
            		}
HXDLIN( 293)		Float y;
HXDLIN( 293)		if (this->up) {
HXLINE( 293)			y = -(h);
            		}
            		else {
HXLINE( 293)			y = h;
            		}
HXDLIN( 293)		 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(x,y);
HXDLIN( 293)		point->_inPool = false;
HXDLIN( 293)		 ::flixel::math::FlxBasePoint rot = point;
HXLINE( 294)		{
HXLINE( 294)			Float degs = ::flixel::math::_FlxPoint::FlxPoint_Impl__obj::get_radians(rot);
HXDLIN( 294)			Float degs1 = ((degs * (( (Float)(180) ) / ::Math_obj::PI)) + target->angle);
HXDLIN( 294)			{
HXLINE( 294)				Float rads = (degs1 * (::Math_obj::PI / ( (Float)(180) )));
HXDLIN( 294)				Float len = ::Math_obj::sqrt(((rot->x * rot->x) + (rot->y * rot->y)));
HXDLIN( 294)				rot->set_x((len * ::Math_obj::cos(rads)));
HXDLIN( 294)				rot->set_y((len * ::Math_obj::sin(rads)));
            			}
            		}
HXLINE( 295)		{
HXLINE( 295)			Float l = (::Math_obj::sqrt(((rot->x * rot->x) + (rot->y * rot->y))) + 2);
HXDLIN( 295)			bool _hx_tmp;
HXDLIN( 295)			if ((::Math_obj::abs(rot->x) < ((Float)0.0000001))) {
HXLINE( 295)				_hx_tmp = (::Math_obj::abs(rot->y) < ((Float)0.0000001));
            			}
            			else {
HXLINE( 295)				_hx_tmp = false;
            			}
HXDLIN( 295)			if (!(_hx_tmp)) {
HXLINE( 295)				Float a = ::flixel::math::_FlxPoint::FlxPoint_Impl__obj::get_radians(rot);
HXDLIN( 295)				rot->set_x((l * ::Math_obj::cos(a)));
HXDLIN( 295)				rot->set_y((l * ::Math_obj::sin(a)));
            			}
            		}
HXLINE( 296)		this->x = ((target->x + target->origin->x) + rot->x);
HXLINE( 297)		this->y = ((target->y + target->origin->y) + rot->y);
HXLINE( 298)		rot->put();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Marker_obj,reposition,(void))

int Marker_obj::MOUSE_RADIUS;

int Marker_obj::BUFFER;

int Marker_obj::CIRCLE_RADIUS;

int Marker_obj::RECT_MARGIN;

int Marker_obj::RECT_SIZE;

void Marker_obj::draw(Float screenX,Float screenY,bool circle, ::openfl::display::Graphics gfx){
            	HX_STACKFRAME(&_hx_pos_97817d579925b552_302_draw)
HXLINE( 303)		gfx->beginFill(-65281,null());
HXLINE( 304)		if (circle) {
HXLINE( 305)			gfx->drawCircle(screenX,screenY,( (Float)(5) ));
            		}
            		else {
HXLINE( 307)			gfx->drawRect((screenX - ( (Float)(2) )),(screenY - ( (Float)(2) )),( (Float)(5) ),( (Float)(5) ));
            		}
HXLINE( 308)		gfx->endFill();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Marker_obj,draw,(void))


::hx::ObjectPtr< Marker_obj > Marker_obj::__new(::String type,bool left,bool up) {
	::hx::ObjectPtr< Marker_obj > __this = new Marker_obj();
	__this->__construct(type,left,up);
	return __this;
}

::hx::ObjectPtr< Marker_obj > Marker_obj::__alloc(::hx::Ctx *_hx_ctx,::String type,bool left,bool up) {
	Marker_obj *__this = (Marker_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Marker_obj), true, "flixel.system.debug.interaction.tools._Transform.Marker"));
	*(void **)__this = Marker_obj::_hx_vtable;
	__this->__construct(type,left,up);
	return __this;
}

Marker_obj::Marker_obj()
{
}

void Marker_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Marker);
	HX_MARK_MEMBER_NAME(x,"x");
	HX_MARK_MEMBER_NAME(y,"y");
	HX_MARK_MEMBER_NAME(type,"type");
	HX_MARK_MEMBER_NAME(left,"left");
	HX_MARK_MEMBER_NAME(up,"up");
	HX_MARK_END_CLASS();
}

void Marker_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(x,"x");
	HX_VISIT_MEMBER_NAME(y,"y");
	HX_VISIT_MEMBER_NAME(type,"type");
	HX_VISIT_MEMBER_NAME(left,"left");
	HX_VISIT_MEMBER_NAME(up,"up");
}

::hx::Val Marker_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { return ::hx::Val( x ); }
		if (HX_FIELD_EQ(inName,"y") ) { return ::hx::Val( y ); }
		break;
	case 2:
		if (HX_FIELD_EQ(inName,"up") ) { return ::hx::Val( up ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"type") ) { return ::hx::Val( type ); }
		if (HX_FIELD_EQ(inName,"left") ) { return ::hx::Val( left ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"reposition") ) { return ::hx::Val( reposition_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Marker_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"draw") ) { outValue = draw_dyn(); return true; }
	}
	return false;
}

::hx::Val Marker_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { x=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y") ) { y=inValue.Cast< Float >(); return inValue; }
		break;
	case 2:
		if (HX_FIELD_EQ(inName,"up") ) { up=inValue.Cast< bool >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"type") ) { type=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"left") ) { left=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Marker_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("x",78,00,00,00));
	outFields->push(HX_("y",79,00,00,00));
	outFields->push(HX_("type",ba,f2,08,4d));
	outFields->push(HX_("left",07,08,b0,47));
	outFields->push(HX_("up",5b,66,00,00));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Marker_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(Marker_obj,x),HX_("x",78,00,00,00)},
	{::hx::fsFloat,(int)offsetof(Marker_obj,y),HX_("y",79,00,00,00)},
	{::hx::fsString,(int)offsetof(Marker_obj,type),HX_("type",ba,f2,08,4d)},
	{::hx::fsBool,(int)offsetof(Marker_obj,left),HX_("left",07,08,b0,47)},
	{::hx::fsBool,(int)offsetof(Marker_obj,up),HX_("up",5b,66,00,00)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo Marker_obj_sStaticStorageInfo[] = {
	{::hx::fsInt,(void *) &Marker_obj::MOUSE_RADIUS,HX_("MOUSE_RADIUS",8c,3a,bf,04)},
	{::hx::fsInt,(void *) &Marker_obj::BUFFER,HX_("BUFFER",00,69,17,83)},
	{::hx::fsInt,(void *) &Marker_obj::CIRCLE_RADIUS,HX_("CIRCLE_RADIUS",e1,51,e7,77)},
	{::hx::fsInt,(void *) &Marker_obj::RECT_MARGIN,HX_("RECT_MARGIN",29,c5,73,f0)},
	{::hx::fsInt,(void *) &Marker_obj::RECT_SIZE,HX_("RECT_SIZE",fc,4c,2a,5e)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String Marker_obj_sMemberFields[] = {
	HX_("x",78,00,00,00),
	HX_("y",79,00,00,00),
	HX_("type",ba,f2,08,4d),
	HX_("left",07,08,b0,47),
	HX_("up",5b,66,00,00),
	HX_("reposition",5c,6f,62,a5),
	::String(null()) };

static void Marker_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Marker_obj::MOUSE_RADIUS,"MOUSE_RADIUS");
	HX_MARK_MEMBER_NAME(Marker_obj::BUFFER,"BUFFER");
	HX_MARK_MEMBER_NAME(Marker_obj::CIRCLE_RADIUS,"CIRCLE_RADIUS");
	HX_MARK_MEMBER_NAME(Marker_obj::RECT_MARGIN,"RECT_MARGIN");
	HX_MARK_MEMBER_NAME(Marker_obj::RECT_SIZE,"RECT_SIZE");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Marker_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Marker_obj::MOUSE_RADIUS,"MOUSE_RADIUS");
	HX_VISIT_MEMBER_NAME(Marker_obj::BUFFER,"BUFFER");
	HX_VISIT_MEMBER_NAME(Marker_obj::CIRCLE_RADIUS,"CIRCLE_RADIUS");
	HX_VISIT_MEMBER_NAME(Marker_obj::RECT_MARGIN,"RECT_MARGIN");
	HX_VISIT_MEMBER_NAME(Marker_obj::RECT_SIZE,"RECT_SIZE");
};

#endif

::hx::Class Marker_obj::__mClass;

static ::String Marker_obj_sStaticFields[] = {
	HX_("MOUSE_RADIUS",8c,3a,bf,04),
	HX_("BUFFER",00,69,17,83),
	HX_("CIRCLE_RADIUS",e1,51,e7,77),
	HX_("RECT_MARGIN",29,c5,73,f0),
	HX_("RECT_SIZE",fc,4c,2a,5e),
	HX_("draw",04,2c,70,42),
	::String(null())
};

void Marker_obj::__register()
{
	Marker_obj _hx_dummy;
	Marker_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("flixel.system.debug.interaction.tools._Transform.Marker",e4,a3,50,52);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Marker_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Marker_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Marker_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Marker_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Marker_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Marker_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Marker_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Marker_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Marker_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_97817d579925b552_269_boot)
HXDLIN( 269)		MOUSE_RADIUS = 10;
            	}
{
            	HX_STACKFRAME(&_hx_pos_97817d579925b552_271_boot)
HXDLIN( 271)		BUFFER = 2;
            	}
{
            	HX_STACKFRAME(&_hx_pos_97817d579925b552_272_boot)
HXDLIN( 272)		CIRCLE_RADIUS = 5;
            	}
{
            	HX_STACKFRAME(&_hx_pos_97817d579925b552_273_boot)
HXDLIN( 273)		RECT_MARGIN = 2;
            	}
{
            	HX_STACKFRAME(&_hx_pos_97817d579925b552_274_boot)
HXDLIN( 274)		RECT_SIZE = 5;
            	}
}

} // end namespace flixel
} // end namespace system
} // end namespace debug
} // end namespace interaction
} // end namespace tools
} // end namespace _Transform
