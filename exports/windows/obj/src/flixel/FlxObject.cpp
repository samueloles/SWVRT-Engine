// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRect
#include <flixel/math/FlxRect.h>
#endif
#ifndef INCLUDED_flixel_math_FlxVelocity
#include <flixel/math/FlxVelocity.h>
#endif
#ifndef INCLUDED_flixel_path_FlxPath
#include <flixel/path/FlxPath.h>
#endif
#ifndef INCLUDED_flixel_path_FlxTypedBasePath
#include <flixel/path/FlxTypedBasePath.h>
#endif
#ifndef INCLUDED_flixel_system_debug_log_LogStyle
#include <flixel/system/debug/log/LogStyle.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_DebuggerFrontEnd
#include <flixel/system/frontEnds/DebuggerFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_LogFrontEnd
#include <flixel/system/frontEnds/LogFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxBaseTilemap
#include <flixel/tile/FlxBaseTilemap.h>
#endif
#ifndef INCLUDED_flixel_util_FlxDestroyUtil
#include <flixel/util/FlxDestroyUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool
#include <flixel/util/FlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_FlxSpriteUtil
#include <flixel/util/FlxSpriteUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxStringUtil
#include <flixel/util/FlxStringUtil.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_flixel_util_LabelValuePair
#include <flixel/util/LabelValuePair.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_Graphics
#include <openfl/display/Graphics.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_c625bfaa5b4263df_75_new,"flixel.FlxObject","new",0x2aa4ec91,"flixel.FlxObject.new","flixel/FlxObject.hx",75,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_783_initVars,"flixel.FlxObject","initVars",0xb8a66d0b,"flixel.FlxObject.initVars","flixel/FlxObject.hx",783,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_797_initMotionVars,"flixel.FlxObject","initMotionVars",0xb01943a1,"flixel.FlxObject.initMotionVars","flixel/FlxObject.hx",797,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_815_destroy,"flixel.FlxObject","destroy",0xba37b5ab,"flixel.FlxObject.destroy","flixel/FlxObject.hx",815,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_833_update,"flixel.FlxObject","update",0x87b15e78,"flixel.FlxObject.update","flixel/FlxObject.hx",833,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_858_updateMotion,"flixel.FlxObject","updateMotion",0x420d82ce,"flixel.FlxObject.updateMotion","flixel/FlxObject.hx",858,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_881_draw,"flixel.FlxObject","draw",0x1f17bab3,"flixel.FlxObject.draw","flixel/FlxObject.hx",881,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_902_overlaps,"flixel.FlxObject","overlaps",0xaad0e53b,"flixel.FlxObject.overlaps","flixel/FlxObject.hx",902,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_906_overlaps,"flixel.FlxObject","overlaps",0xaad0e53b,"flixel.FlxObject.overlaps","flixel/FlxObject.hx",906,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_937_overlapsCallback,"flixel.FlxObject","overlapsCallback",0xe4196e20,"flixel.FlxObject.overlapsCallback","flixel/FlxObject.hx",937,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_959_overlapsAt,"flixel.FlxObject","overlapsAt",0xacc1230e,"flixel.FlxObject.overlapsAt","flixel/FlxObject.hx",959,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_963_overlapsAt,"flixel.FlxObject","overlapsAt",0xacc1230e,"flixel.FlxObject.overlapsAt","flixel/FlxObject.hx",963,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_996_overlapsAtCallback,"flixel.FlxObject","overlapsAtCallback",0xb90836f3,"flixel.FlxObject.overlapsAtCallback","flixel/FlxObject.hx",996,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1008_overlapsPoint,"flixel.FlxObject","overlapsPoint",0xcd9c6915,"flixel.FlxObject.overlapsPoint","flixel/FlxObject.hx",1008,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1032_inWorldBounds,"flixel.FlxObject","inWorldBounds",0x89d0e9f3,"flixel.FlxObject.inWorldBounds","flixel/FlxObject.hx",1032,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1043_getScreenPosition,"flixel.FlxObject","getScreenPosition",0x643c435c,"flixel.FlxObject.getScreenPosition","flixel/FlxObject.hx",1043,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1064_getPosition,"flixel.FlxObject","getPosition",0x1bf09890,"flixel.FlxObject.getPosition","flixel/FlxObject.hx",1064,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1079_getMidpoint,"flixel.FlxObject","getMidpoint",0x7bfe0daf,"flixel.FlxObject.getMidpoint","flixel/FlxObject.hx",1079,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1086_getHitbox,"flixel.FlxObject","getHitbox",0x5f284dbf,"flixel.FlxObject.getHitbox","flixel/FlxObject.hx",1086,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1100_reset,"flixel.FlxObject","reset",0x1cbd9440,"flixel.FlxObject.reset","flixel/FlxObject.hx",1100,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1116_isOnScreen,"flixel.FlxObject","isOnScreen",0x4aab7fe4,"flixel.FlxObject.isOnScreen","flixel/FlxObject.hx",1116,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1128_isPixelPerfectRender,"flixel.FlxObject","isPixelPerfectRender",0xc4c93916,"flixel.FlxObject.isPixelPerfectRender","flixel/FlxObject.hx",1128,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1143_isTouching,"flixel.FlxObject","isTouching",0x23c6647c,"flixel.FlxObject.isTouching","flixel/FlxObject.hx",1143,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1155_justTouched,"flixel.FlxObject","justTouched",0xbcba8e43,"flixel.FlxObject.justTouched","flixel/FlxObject.hx",1155,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1170_hurt,"flixel.FlxObject","hurt",0x21beeabe,"flixel.FlxObject.hurt","flixel/FlxObject.hx",1170,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1184_screenCenter,"flixel.FlxObject","screenCenter",0x59e58410,"flixel.FlxObject.screenCenter","flixel/FlxObject.hx",1184,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1202_setPosition,"flixel.FlxObject","setPosition",0x265d9f9c,"flixel.FlxObject.setPosition","flixel/FlxObject.hx",1202,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1214_setSize,"flixel.FlxObject","setSize",0xa7896a34,"flixel.FlxObject.setSize","flixel/FlxObject.hx",1214,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1221_drawDebug,"flixel.FlxObject","drawDebug",0x2ad45ea0,"flixel.FlxObject.drawDebug","flixel/FlxObject.hx",1221,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1245_drawDebugOnCamera,"flixel.FlxObject","drawDebugOnCamera",0x0b2ef7e4,"flixel.FlxObject.drawDebugOnCamera","flixel/FlxObject.hx",1245,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1256_drawDebugBoundingBox,"flixel.FlxObject","drawDebugBoundingBox",0xa96b1247,"flixel.FlxObject.drawDebugBoundingBox","flixel/FlxObject.hx",1256,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1263_getDebugBoundingBoxColor,"flixel.FlxObject","getDebugBoundingBoxColor",0xc0f2db08,"flixel.FlxObject.getDebugBoundingBoxColor","flixel/FlxObject.hx",1263,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1278_drawDebugBoundingBoxColor,"flixel.FlxObject","drawDebugBoundingBoxColor",0x00142d9c,"flixel.FlxObject.drawDebugBoundingBoxColor","flixel/FlxObject.hx",1278,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1286_beginDrawDebug,"flixel.FlxObject","beginDrawDebug",0x8677cfb5,"flixel.FlxObject.beginDrawDebug","flixel/FlxObject.hx",1286,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1299_endDrawDebug,"flixel.FlxObject","endDrawDebug",0x2518e603,"flixel.FlxObject.endDrawDebug","flixel/FlxObject.hx",1299,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1306_getBoundingBox,"flixel.FlxObject","getBoundingBox",0x58364780,"flixel.FlxObject.getBoundingBox","flixel/FlxObject.hx",1306,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1330_getRotatedBounds,"flixel.FlxObject","getRotatedBounds",0x6b926bb7,"flixel.FlxObject.getRotatedBounds","flixel/FlxObject.hx",1330,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1343_toString,"flixel.FlxObject","toString",0x9e14e2db,"flixel.FlxObject.toString","flixel/FlxObject.hx",1343,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1356_set_x,"flixel.FlxObject","set_x",0xb024e5cc,"flixel.FlxObject.set_x","flixel/FlxObject.hx",1356,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1362_set_y,"flixel.FlxObject","set_y",0xb024e5cd,"flixel.FlxObject.set_y","flixel/FlxObject.hx",1362,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1367_set_width,"flixel.FlxObject","set_width",0x7d06d55a,"flixel.FlxObject.set_width","flixel/FlxObject.hx",1367,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1381_set_height,"flixel.FlxObject","set_height",0x9f435213,"flixel.FlxObject.set_height","flixel/FlxObject.hx",1381,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1396_get_width,"flixel.FlxObject","get_width",0x99b5e94e,"flixel.FlxObject.get_width","flixel/FlxObject.hx",1396,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1402_get_height,"flixel.FlxObject","get_height",0x9bc5b39f,"flixel.FlxObject.get_height","flixel/FlxObject.hx",1402,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1408_get_solid,"flixel.FlxObject","get_solid",0x5018e773,"flixel.FlxObject.get_solid","flixel/FlxObject.hx",1408,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1413_set_solid,"flixel.FlxObject","set_solid",0x3369d37f,"flixel.FlxObject.set_solid","flixel/FlxObject.hx",1413,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1421_set_angle,"flixel.FlxObject","set_angle",0xd5866327,"flixel.FlxObject.set_angle","flixel/FlxObject.hx",1421,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1427_set_moves,"flixel.FlxObject","set_moves",0xbf09eb96,"flixel.FlxObject.set_moves","flixel/FlxObject.hx",1427,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1433_set_immovable,"flixel.FlxObject","set_immovable",0xc5b8805e,"flixel.FlxObject.set_immovable","flixel/FlxObject.hx",1433,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1439_set_pixelPerfectRender,"flixel.FlxObject","set_pixelPerfectRender",0x84233609,"flixel.FlxObject.set_pixelPerfectRender","flixel/FlxObject.hx",1439,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1445_set_allowCollisions,"flixel.FlxObject","set_allowCollisions",0x7975d9fe,"flixel.FlxObject.set_allowCollisions","flixel/FlxObject.hx",1445,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1452_set_debugBoundingBoxColorSolid,"flixel.FlxObject","set_debugBoundingBoxColorSolid",0xb8a23688,"flixel.FlxObject.set_debugBoundingBoxColorSolid","flixel/FlxObject.hx",1452,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1458_set_debugBoundingBoxColorNotSolid,"flixel.FlxObject","set_debugBoundingBoxColorNotSolid",0x55ae1bdb,"flixel.FlxObject.set_debugBoundingBoxColorNotSolid","flixel/FlxObject.hx",1458,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1464_set_debugBoundingBoxColorPartial,"flixel.FlxObject","set_debugBoundingBoxColorPartial",0x34746b1e,"flixel.FlxObject.set_debugBoundingBoxColorPartial","flixel/FlxObject.hx",1464,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_1470_set_path,"flixel.FlxObject","set_path",0xde100cd1,"flixel.FlxObject.set_path","flixel/FlxObject.hx",1470,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_98_allowCollisionDrag,"flixel.FlxObject","allowCollisionDrag",0x3ed42e2c,"flixel.FlxObject.allowCollisionDrag","flixel/FlxObject.hx",98,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_122_processCheckTilemap,"flixel.FlxObject","processCheckTilemap",0x19484f86,"flixel.FlxObject.processCheckTilemap","flixel/FlxObject.hx",122,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_135_processCheckTilemap,"flixel.FlxObject","processCheckTilemap",0x19484f86,"flixel.FlxObject.processCheckTilemap","flixel/FlxObject.hx",135,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_146_processCheckTilemap,"flixel.FlxObject","processCheckTilemap",0x19484f86,"flixel.FlxObject.processCheckTilemap","flixel/FlxObject.hx",146,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_161_separate,"flixel.FlxObject","separate",0x6cc23192,"flixel.FlxObject.separate","flixel/FlxObject.hx",161,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_189_separateX,"flixel.FlxObject","separateX",0xbd292e86,"flixel.FlxObject.separateX","flixel/FlxObject.hx",189,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_200_separateY,"flixel.FlxObject","separateY",0xbd292e87,"flixel.FlxObject.separateY","flixel/FlxObject.hx",200,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_207_separateXHelper,"flixel.FlxObject","separateXHelper",0x5a5ec894,"flixel.FlxObject.separateXHelper","flixel/FlxObject.hx",207,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_259_separateYHelper,"flixel.FlxObject","separateYHelper",0x83f43f55,"flixel.FlxObject.separateYHelper","flixel/FlxObject.hx",259,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_314_legacySeparateX,"flixel.FlxObject","legacySeparateX",0x766fcdbd,"flixel.FlxObject.legacySeparateX","flixel/FlxObject.hx",314,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_336_legacySeparateY,"flixel.FlxObject","legacySeparateY",0x766fcdbe,"flixel.FlxObject.legacySeparateY","flixel/FlxObject.hx",336,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_362_updateTouchingFlags,"flixel.FlxObject","updateTouchingFlags",0x15a0502c,"flixel.FlxObject.updateTouchingFlags","flixel/FlxObject.hx",362,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_360_updateTouchingFlags,"flixel.FlxObject","updateTouchingFlags",0x15a0502c,"flixel.FlxObject.updateTouchingFlags","flixel/FlxObject.hx",360,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_378_updateTouchingFlagsX,"flixel.FlxObject","updateTouchingFlagsX",0xd6a5d6ac,"flixel.FlxObject.updateTouchingFlagsX","flixel/FlxObject.hx",378,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_384_updateTouchingFlagsXHelper,"flixel.FlxObject","updateTouchingFlagsXHelper",0xfaf9113a,"flixel.FlxObject.updateTouchingFlagsXHelper","flixel/FlxObject.hx",384,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_395_updateTouchingFlagsY,"flixel.FlxObject","updateTouchingFlagsY",0xd6a5d6ad,"flixel.FlxObject.updateTouchingFlagsY","flixel/FlxObject.hx",395,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_401_updateTouchingFlagsYHelper,"flixel.FlxObject","updateTouchingFlagsYHelper",0x248e87fb,"flixel.FlxObject.updateTouchingFlagsYHelper","flixel/FlxObject.hx",401,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_410_computeOverlapX,"flixel.FlxObject","computeOverlapX",0x240ec739,"flixel.FlxObject.computeOverlapX","flixel/FlxObject.hx",410,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_480_computeOverlapY,"flixel.FlxObject","computeOverlapY",0x240ec73a,"flixel.FlxObject.computeOverlapY","flixel/FlxObject.hx",480,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_80_boot,"flixel.FlxObject","boot",0x1dc312e1,"flixel.FlxObject.boot","flixel/FlxObject.hx",80,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_87_boot,"flixel.FlxObject","boot",0x1dc312e1,"flixel.FlxObject.boot","flixel/FlxObject.hx",87,0xf0fe0d80)
HX_LOCAL_STACK_FRAME(_hx_pos_c625bfaa5b4263df_94_boot,"flixel.FlxObject","boot",0x1dc312e1,"flixel.FlxObject.boot","flixel/FlxObject.hx",94,0xf0fe0d80)
namespace flixel{

void FlxObject_obj::__construct(::hx::Null< Float >  __o_x,::hx::Null< Float >  __o_y,::hx::Null< Float >  __o_width,::hx::Null< Float >  __o_height){
            		Float x = __o_x.Default(0);
            		Float y = __o_y.Default(0);
            		Float width = __o_width.Default(0);
            		Float height = __o_height.Default(0);
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_75_new)
HXLINE( 758)		 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get().StaticCast<  ::flixel::math::FlxRect >();
HXDLIN( 758)		_this->x = ( (Float)(0) );
HXDLIN( 758)		_this->y = ( (Float)(0) );
HXDLIN( 758)		_this->width = ( (Float)(0) );
HXDLIN( 758)		_this->height = ( (Float)(0) );
HXDLIN( 758)		 ::flixel::math::FlxRect rect = _this;
HXDLIN( 758)		rect->_inPool = false;
HXDLIN( 758)		this->_rect = rect;
HXLINE( 756)		 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN( 756)		point->_inPool = false;
HXDLIN( 756)		this->_point = point;
HXLINE( 753)		this->path = null();
HXLINE( 744)		this->ignoreDrawDebug = false;
HXLINE( 738)		this->debugBoundingBoxColorPartial = -16744448;
HXLINE( 730)		this->debugBoundingBoxColorNotSolid = -16776961;
HXLINE( 724)		this->debugBoundingBoxColorSolid = -65536;
HXLINE( 718)		this->debugBoundingBoxColor = null();
HXLINE( 711)		this->collisionYDrag = 0;
HXLINE( 703)		this->collisionXDrag = 2;
HXLINE( 695)		this->allowCollisions = 4369;
HXLINE( 689)		this->wasTouching = 0;
HXLINE( 683)		this->touching = 0;
HXLINE( 676)		this->health = ((Float)1);
HXLINE( 667)		this->maxAngular = ((Float)10000);
HXLINE( 662)		this->angularDrag = ((Float)0);
HXLINE( 657)		this->angularAcceleration = ((Float)0);
HXLINE( 652)		this->angularVelocity = ((Float)0);
HXLINE( 647)		this->elasticity = ((Float)0);
HXLINE( 642)		this->mass = ((Float)1);
HXLINE( 594)		this->immovable = false;
HXLINE( 589)		this->moves = ::flixel::FlxObject_obj::defaultMoves;
HXLINE( 583)		this->angle = ((Float)0);
HXLINE( 577)		this->pixelPerfectPosition = true;
HXLINE( 552)		this->y = ((Float)0);
HXLINE( 547)		this->x = ((Float)0);
HXLINE( 768)		super::__construct();
HXLINE( 770)		this->set_x(x);
HXLINE( 771)		this->set_y(y);
HXLINE( 772)		this->set_width(width);
HXLINE( 773)		this->set_height(height);
HXLINE( 775)		this->initVars();
            	}

Dynamic FlxObject_obj::__CreateEmpty() { return new FlxObject_obj; }

void *FlxObject_obj::_hx_vtable = 0;

Dynamic FlxObject_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< FlxObject_obj > _hx_result = new FlxObject_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3]);
	return _hx_result;
}

bool FlxObject_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x7ccf8994) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x7ccf8994;
	} else {
		return inClassId==(int)0x7dab0655;
	}
}

void FlxObject_obj::initVars(){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_783_initVars)
HXLINE( 784)		this->flixelType = 1;
HXLINE( 785)		Float x = this->x;
HXDLIN( 785)		Float y = this->y;
HXDLIN( 785)		 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(x,y);
HXDLIN( 785)		point->_inPool = false;
HXDLIN( 785)		this->last = point;
HXLINE( 786)		 ::flixel::math::FlxBasePoint point1 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(1,1);
HXDLIN( 786)		point1->_inPool = false;
HXDLIN( 786)		this->scrollFactor = point1;
HXLINE( 787)		this->pixelPerfectPosition = ::flixel::FlxObject_obj::defaultPixelPerfectPosition;
HXLINE( 789)		{
HXLINE( 789)			 ::flixel::math::FlxBasePoint point2 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN( 789)			point2->_inPool = false;
HXDLIN( 789)			this->velocity = point2;
HXDLIN( 789)			 ::flixel::math::FlxBasePoint point3 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN( 789)			point3->_inPool = false;
HXDLIN( 789)			this->acceleration = point3;
HXDLIN( 789)			 ::flixel::math::FlxBasePoint point4 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN( 789)			point4->_inPool = false;
HXDLIN( 789)			this->drag = point4;
HXDLIN( 789)			 ::flixel::math::FlxBasePoint point5 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(10000,10000);
HXDLIN( 789)			point5->_inPool = false;
HXDLIN( 789)			this->maxVelocity = point5;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxObject_obj,initVars,(void))

void FlxObject_obj::initMotionVars(){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_797_initMotionVars)
HXLINE( 798)		 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN( 798)		point->_inPool = false;
HXDLIN( 798)		this->velocity = point;
HXLINE( 799)		 ::flixel::math::FlxBasePoint point1 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN( 799)		point1->_inPool = false;
HXDLIN( 799)		this->acceleration = point1;
HXLINE( 800)		 ::flixel::math::FlxBasePoint point2 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN( 800)		point2->_inPool = false;
HXDLIN( 800)		this->drag = point2;
HXLINE( 801)		 ::flixel::math::FlxBasePoint point3 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(10000,10000);
HXDLIN( 801)		point3->_inPool = false;
HXDLIN( 801)		this->maxVelocity = point3;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxObject_obj,initMotionVars,(void))

void FlxObject_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_815_destroy)
HXLINE( 816)		this->super::destroy();
HXLINE( 818)		this->velocity = ( ( ::flixel::math::FlxBasePoint)(::flixel::util::FlxDestroyUtil_obj::put(this->velocity)) );
HXLINE( 819)		this->acceleration = ( ( ::flixel::math::FlxBasePoint)(::flixel::util::FlxDestroyUtil_obj::put(this->acceleration)) );
HXLINE( 820)		this->drag = ( ( ::flixel::math::FlxBasePoint)(::flixel::util::FlxDestroyUtil_obj::put(this->drag)) );
HXLINE( 821)		this->maxVelocity = ( ( ::flixel::math::FlxBasePoint)(::flixel::util::FlxDestroyUtil_obj::put(this->maxVelocity)) );
HXLINE( 822)		this->scrollFactor = ( ( ::flixel::math::FlxBasePoint)(::flixel::util::FlxDestroyUtil_obj::put(this->scrollFactor)) );
HXLINE( 823)		this->last = ( ( ::flixel::math::FlxBasePoint)(::flixel::util::FlxDestroyUtil_obj::put(this->last)) );
HXLINE( 824)		this->_point = ( ( ::flixel::math::FlxBasePoint)(::flixel::util::FlxDestroyUtil_obj::put(this->_point)) );
HXLINE( 825)		this->_rect = ( ( ::flixel::math::FlxRect)(::flixel::util::FlxDestroyUtil_obj::put(this->_rect)) );
            	}


void FlxObject_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_833_update)
HXLINE( 836)		this->super::update(elapsed);
HXLINE( 839)		{
HXLINE( 839)			 ::flixel::math::FlxBasePoint this1 = this->last;
HXDLIN( 839)			Float y = this->y;
HXDLIN( 839)			this1->set_x(this->x);
HXDLIN( 839)			this1->set_y(y);
            		}
HXLINE( 841)		bool _hx_tmp;
HXDLIN( 841)		if (::hx::IsNotNull( this->path )) {
HXLINE( 841)			_hx_tmp = this->path->active;
            		}
            		else {
HXLINE( 841)			_hx_tmp = false;
            		}
HXDLIN( 841)		if (_hx_tmp) {
HXLINE( 842)			this->path->update(elapsed);
            		}
HXLINE( 844)		if (this->moves) {
HXLINE( 845)			this->updateMotion(elapsed);
            		}
HXLINE( 847)		this->wasTouching = this->touching;
HXLINE( 848)		this->touching = 0;
            	}


void FlxObject_obj::updateMotion(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_858_updateMotion)
HXLINE( 859)		Float velocityDelta = ::flixel::math::FlxVelocity_obj::computeVelocity(this->angularVelocity,this->angularAcceleration,this->angularDrag,this->maxAngular,elapsed);
HXDLIN( 859)		Float velocityDelta1 = (((Float)0.5) * (velocityDelta - this->angularVelocity));
HXLINE( 860)		 ::flixel::FlxObject _hx_tmp = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 860)		_hx_tmp->angularVelocity = (_hx_tmp->angularVelocity + velocityDelta1);
HXLINE( 861)		this->set_angle((this->angle + (this->angularVelocity * elapsed)));
HXLINE( 862)		 ::flixel::FlxObject _hx_tmp1 = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 862)		_hx_tmp1->angularVelocity = (_hx_tmp1->angularVelocity + velocityDelta1);
HXLINE( 864)		Float velocityDelta2 = ::flixel::math::FlxVelocity_obj::computeVelocity(this->velocity->x,this->acceleration->x,this->drag->x,this->maxVelocity->x,elapsed);
HXDLIN( 864)		velocityDelta1 = (((Float)0.5) * (velocityDelta2 - this->velocity->x));
HXLINE( 865)		this->velocity->set_x((this->velocity->x + velocityDelta1));
HXLINE( 866)		Float delta = (this->velocity->x * elapsed);
HXLINE( 867)		this->velocity->set_x((this->velocity->x + velocityDelta1));
HXLINE( 868)		this->set_x((this->x + delta));
HXLINE( 870)		Float velocityDelta3 = ::flixel::math::FlxVelocity_obj::computeVelocity(this->velocity->y,this->acceleration->y,this->drag->y,this->maxVelocity->y,elapsed);
HXDLIN( 870)		velocityDelta1 = (((Float)0.5) * (velocityDelta3 - this->velocity->y));
HXLINE( 871)		this->velocity->set_y((this->velocity->y + velocityDelta1));
HXLINE( 872)		delta = (this->velocity->y * elapsed);
HXLINE( 873)		this->velocity->set_y((this->velocity->y + velocityDelta1));
HXLINE( 874)		this->set_y((this->y + delta));
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,updateMotion,(void))

void FlxObject_obj::draw(){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_881_draw)
HXLINE( 883)		this->super::draw();
HXLINE( 884)		if (::flixel::FlxG_obj::debugger->drawDebug) {
HXLINE( 885)			this->drawDebug();
            		}
            	}


bool FlxObject_obj::overlaps( ::flixel::FlxBasic objectOrGroup,::hx::Null< bool >  __o_inScreenSpace, ::flixel::FlxCamera camera){
            		bool inScreenSpace = __o_inScreenSpace.Default(false);
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_902_overlaps)
HXLINE( 903)		 ::flixel::group::FlxTypedGroup group = ::flixel::group::FlxTypedGroup_obj::resolveGroup(objectOrGroup);
HXLINE( 904)		if (::hx::IsNotNull( group )) {
            			HX_BEGIN_LOCAL_FUNC_S3(::hx::LocalFunc,_hx_Closure_0, ::flixel::FlxObject,_g,bool,inScreenSpace1, ::flixel::FlxCamera,camera1) HXARGC(1)
            			bool _hx_run( ::flixel::FlxBasic objectOrGroup){
            				HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_906_overlaps)
HXLINE( 906)				return _g->overlaps(objectOrGroup,inScreenSpace1,camera1);
            			}
            			HX_END_LOCAL_FUNC1(return)

HXLINE( 906)			 ::flixel::FlxObject _g = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 906)			Float x = ( (Float)(0) );
HXDLIN( 906)			Float y = ( (Float)(0) );
HXDLIN( 906)			bool inScreenSpace1 = inScreenSpace;
HXDLIN( 906)			 ::flixel::FlxCamera camera1 = camera;
HXDLIN( 906)			return group->any( ::Dynamic(new _hx_Closure_0(_g,inScreenSpace1,camera1)));
            		}
HXLINE( 909)		if ((objectOrGroup->flixelType == 3)) {
HXLINE( 913)			 ::flixel::tile::FlxBaseTilemap tilemap = ( ( ::flixel::tile::FlxBaseTilemap)(objectOrGroup) );
HXLINE( 914)			return tilemap->overlaps(::hx::ObjectPtr<OBJ_>(this),inScreenSpace,camera);
            		}
HXLINE( 917)		 ::flixel::FlxObject object = ( ( ::flixel::FlxObject)(objectOrGroup) );
HXLINE( 918)		if (!(inScreenSpace)) {
HXLINE( 920)			bool _hx_tmp;
HXDLIN( 920)			bool _hx_tmp1;
HXDLIN( 920)			Float object1 = object->x;
HXDLIN( 920)			Float _hx_tmp2 = (object1 + object->get_width());
HXDLIN( 920)			if ((_hx_tmp2 > this->x)) {
HXLINE( 920)				Float object2 = object->x;
HXDLIN( 920)				Float _hx_tmp3 = this->x;
HXDLIN( 920)				_hx_tmp1 = (object2 < (_hx_tmp3 + this->get_width()));
            			}
            			else {
HXLINE( 920)				_hx_tmp1 = false;
            			}
HXDLIN( 920)			if (_hx_tmp1) {
HXLINE( 920)				Float object3 = object->y;
HXDLIN( 920)				Float _hx_tmp4 = (object3 + object->get_height());
HXDLIN( 920)				_hx_tmp = (_hx_tmp4 > this->y);
            			}
            			else {
HXLINE( 920)				_hx_tmp = false;
            			}
HXDLIN( 920)			if (_hx_tmp) {
HXLINE( 920)				Float object4 = object->y;
HXDLIN( 920)				Float _hx_tmp5 = this->y;
HXDLIN( 920)				return (object4 < (_hx_tmp5 + this->get_height()));
            			}
            			else {
HXLINE( 920)				return false;
            			}
            		}
HXLINE( 923)		if (::hx::IsNull( camera )) {
HXLINE( 924)			camera = this->getDefaultCamera();
            		}
HXLINE( 926)		 ::flixel::math::FlxBasePoint objectScreenPos = object->getScreenPosition(null(),camera);
HXLINE( 927)		this->getScreenPosition(this->_point,camera);
HXLINE( 928)		bool _hx_tmp6;
HXDLIN( 928)		bool _hx_tmp7;
HXDLIN( 928)		Float objectScreenPos1 = objectScreenPos->x;
HXDLIN( 928)		Float _hx_tmp8 = (objectScreenPos1 + object->get_width());
HXDLIN( 928)		if ((_hx_tmp8 > this->_point->x)) {
HXLINE( 929)			Float objectScreenPos2 = objectScreenPos->x;
HXDLIN( 929)			Float _hx_tmp9 = this->_point->x;
HXLINE( 928)			_hx_tmp7 = (objectScreenPos2 < (_hx_tmp9 + this->get_width()));
            		}
            		else {
HXLINE( 928)			_hx_tmp7 = false;
            		}
HXDLIN( 928)		if (_hx_tmp7) {
HXLINE( 930)			Float objectScreenPos3 = objectScreenPos->y;
HXDLIN( 930)			Float _hx_tmp10 = (objectScreenPos3 + object->get_height());
HXLINE( 928)			_hx_tmp6 = (_hx_tmp10 > this->_point->y);
            		}
            		else {
HXLINE( 928)			_hx_tmp6 = false;
            		}
HXDLIN( 928)		if (_hx_tmp6) {
HXLINE( 931)			Float objectScreenPos4 = objectScreenPos->y;
HXDLIN( 931)			Float _hx_tmp11 = this->_point->y;
HXDLIN( 931)			return (objectScreenPos4 < (_hx_tmp11 + this->get_height()));
            		}
            		else {
HXLINE( 928)			return false;
            		}
HXDLIN( 928)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxObject_obj,overlaps,return )

bool FlxObject_obj::overlapsCallback( ::flixel::FlxBasic objectOrGroup,Float x,Float y,bool inScreenSpace, ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_937_overlapsCallback)
HXDLIN( 937)		return this->overlaps(objectOrGroup,inScreenSpace,camera);
            	}


HX_DEFINE_DYNAMIC_FUNC5(FlxObject_obj,overlapsCallback,return )

bool FlxObject_obj::overlapsAt(Float x,Float y, ::flixel::FlxBasic objectOrGroup,::hx::Null< bool >  __o_inScreenSpace, ::flixel::FlxCamera camera){
            		bool inScreenSpace = __o_inScreenSpace.Default(false);
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_959_overlapsAt)
HXLINE( 960)		 ::flixel::group::FlxTypedGroup group = ::flixel::group::FlxTypedGroup_obj::resolveGroup(objectOrGroup);
HXLINE( 961)		if (::hx::IsNotNull( group )) {
            			HX_BEGIN_LOCAL_FUNC_S5(::hx::LocalFunc,_hx_Closure_0,Float,y1,Float,x1, ::flixel::FlxObject,_g,bool,inScreenSpace1, ::flixel::FlxCamera,camera1) HXARGC(1)
            			bool _hx_run( ::flixel::FlxBasic objectOrGroup){
            				HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_963_overlapsAt)
HXLINE( 963)				return _g->overlapsAt(x1,y1,objectOrGroup,inScreenSpace1,camera1);
            			}
            			HX_END_LOCAL_FUNC1(return)

HXLINE( 963)			 ::flixel::FlxObject _g = ::hx::ObjectPtr<OBJ_>(this);
HXDLIN( 963)			Float x1 = x;
HXDLIN( 963)			Float y1 = y;
HXDLIN( 963)			bool inScreenSpace1 = inScreenSpace;
HXDLIN( 963)			 ::flixel::FlxCamera camera1 = camera;
HXDLIN( 963)			return group->any( ::Dynamic(new _hx_Closure_0(y1,x1,_g,inScreenSpace1,camera1)));
            		}
HXLINE( 966)		if ((objectOrGroup->flixelType == 3)) {
HXLINE( 972)			 ::flixel::tile::FlxBaseTilemap tilemap = ( ( ::flixel::tile::FlxBaseTilemap)(objectOrGroup) );
HXLINE( 973)			return tilemap->overlapsAt((tilemap->x - (x - this->x)),(tilemap->y - (y - this->y)),::hx::ObjectPtr<OBJ_>(this),inScreenSpace,camera);
            		}
HXLINE( 976)		 ::flixel::FlxObject object = ( ( ::flixel::FlxObject)(objectOrGroup) );
HXLINE( 977)		if (!(inScreenSpace)) {
HXLINE( 979)			bool _hx_tmp;
HXDLIN( 979)			bool _hx_tmp1;
HXDLIN( 979)			Float object1 = object->x;
HXDLIN( 979)			if (((object1 + object->get_width()) > x)) {
HXLINE( 979)				Float object2 = object->x;
HXDLIN( 979)				_hx_tmp1 = (object2 < (x + this->get_width()));
            			}
            			else {
HXLINE( 979)				_hx_tmp1 = false;
            			}
HXDLIN( 979)			if (_hx_tmp1) {
HXLINE( 979)				Float object3 = object->y;
HXDLIN( 979)				_hx_tmp = ((object3 + object->get_height()) > y);
            			}
            			else {
HXLINE( 979)				_hx_tmp = false;
            			}
HXDLIN( 979)			if (_hx_tmp) {
HXLINE( 979)				Float object4 = object->y;
HXDLIN( 979)				return (object4 < (y + this->get_height()));
            			}
            			else {
HXLINE( 979)				return false;
            			}
            		}
HXLINE( 982)		if (::hx::IsNull( camera )) {
HXLINE( 983)			camera = this->getDefaultCamera();
            		}
HXLINE( 985)		 ::flixel::math::FlxBasePoint objectScreenPos = object->getScreenPosition(null(),camera);
HXLINE( 986)		this->getScreenPosition(this->_point,camera);
HXLINE( 987)		bool _hx_tmp2;
HXDLIN( 987)		bool _hx_tmp3;
HXDLIN( 987)		Float objectScreenPos1 = objectScreenPos->x;
HXDLIN( 987)		Float _hx_tmp4 = (objectScreenPos1 + object->get_width());
HXDLIN( 987)		if ((_hx_tmp4 > this->_point->x)) {
HXLINE( 988)			Float objectScreenPos2 = objectScreenPos->x;
HXDLIN( 988)			Float _hx_tmp5 = this->_point->x;
HXLINE( 987)			_hx_tmp3 = (objectScreenPos2 < (_hx_tmp5 + this->get_width()));
            		}
            		else {
HXLINE( 987)			_hx_tmp3 = false;
            		}
HXDLIN( 987)		if (_hx_tmp3) {
HXLINE( 989)			Float objectScreenPos3 = objectScreenPos->y;
HXDLIN( 989)			Float _hx_tmp6 = (objectScreenPos3 + object->get_height());
HXLINE( 987)			_hx_tmp2 = (_hx_tmp6 > this->_point->y);
            		}
            		else {
HXLINE( 987)			_hx_tmp2 = false;
            		}
HXDLIN( 987)		if (_hx_tmp2) {
HXLINE( 990)			Float objectScreenPos4 = objectScreenPos->y;
HXDLIN( 990)			Float _hx_tmp7 = this->_point->y;
HXDLIN( 990)			return (objectScreenPos4 < (_hx_tmp7 + this->get_height()));
            		}
            		else {
HXLINE( 987)			return false;
            		}
HXDLIN( 987)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC5(FlxObject_obj,overlapsAt,return )

bool FlxObject_obj::overlapsAtCallback( ::flixel::FlxBasic objectOrGroup,Float x,Float y,bool inScreenSpace, ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_996_overlapsAtCallback)
HXDLIN( 996)		return this->overlapsAt(x,y,objectOrGroup,inScreenSpace,camera);
            	}


HX_DEFINE_DYNAMIC_FUNC5(FlxObject_obj,overlapsAtCallback,return )

bool FlxObject_obj::overlapsPoint( ::flixel::math::FlxBasePoint point,::hx::Null< bool >  __o_inScreenSpace, ::flixel::FlxCamera camera){
            		bool inScreenSpace = __o_inScreenSpace.Default(false);
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1008_overlapsPoint)
HXLINE(1009)		if (!(inScreenSpace)) {
HXLINE(1011)			bool _hx_tmp;
HXDLIN(1011)			bool _hx_tmp1;
HXDLIN(1011)			if ((point->x >= this->x)) {
HXLINE(1011)				Float point1 = point->x;
HXDLIN(1011)				Float _hx_tmp2 = this->x;
HXDLIN(1011)				_hx_tmp1 = (point1 < (_hx_tmp2 + this->get_width()));
            			}
            			else {
HXLINE(1011)				_hx_tmp1 = false;
            			}
HXDLIN(1011)			if (_hx_tmp1) {
HXLINE(1011)				_hx_tmp = (point->y >= this->y);
            			}
            			else {
HXLINE(1011)				_hx_tmp = false;
            			}
HXDLIN(1011)			if (_hx_tmp) {
HXLINE(1011)				Float point2 = point->y;
HXDLIN(1011)				Float _hx_tmp3 = this->y;
HXDLIN(1011)				return (point2 < (_hx_tmp3 + this->get_height()));
            			}
            			else {
HXLINE(1011)				return false;
            			}
            		}
HXLINE(1014)		if (::hx::IsNull( camera )) {
HXLINE(1015)			camera = this->getDefaultCamera();
            		}
HXLINE(1017)		Float xPos = (point->x - camera->scroll->x);
HXLINE(1018)		Float yPos = (point->y - camera->scroll->y);
HXLINE(1019)		this->getScreenPosition(this->_point,camera);
HXLINE(1020)		{
HXLINE(1020)			 ::flixel::math::FlxBasePoint _this = point;
HXDLIN(1020)			if (_this->_weak) {
HXLINE(1020)				_this->put();
            			}
            		}
HXLINE(1021)		bool _hx_tmp4;
HXDLIN(1021)		bool _hx_tmp5;
HXDLIN(1021)		if ((xPos >= this->_point->x)) {
HXLINE(1021)			Float _hx_tmp6 = this->_point->x;
HXDLIN(1021)			_hx_tmp5 = (xPos < (_hx_tmp6 + this->get_width()));
            		}
            		else {
HXLINE(1021)			_hx_tmp5 = false;
            		}
HXDLIN(1021)		if (_hx_tmp5) {
HXLINE(1021)			_hx_tmp4 = (yPos >= this->_point->y);
            		}
            		else {
HXLINE(1021)			_hx_tmp4 = false;
            		}
HXDLIN(1021)		if (_hx_tmp4) {
HXLINE(1021)			Float _hx_tmp7 = this->_point->y;
HXDLIN(1021)			return (yPos < (_hx_tmp7 + this->get_height()));
            		}
            		else {
HXLINE(1021)			return false;
            		}
HXDLIN(1021)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxObject_obj,overlapsPoint,return )

bool FlxObject_obj::inWorldBounds(){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1032_inWorldBounds)
HXDLIN(1032)		bool _hx_tmp;
HXDLIN(1032)		bool _hx_tmp1;
HXDLIN(1032)		Float _hx_tmp2 = this->x;
HXDLIN(1032)		Float _hx_tmp3 = (_hx_tmp2 + this->get_width());
HXDLIN(1032)		if ((_hx_tmp3 > ::flixel::FlxG_obj::worldBounds->x)) {
HXDLIN(1032)			 ::flixel::math::FlxRect _this = ::flixel::FlxG_obj::worldBounds;
HXDLIN(1032)			_hx_tmp1 = (this->x < (_this->x + _this->width));
            		}
            		else {
HXDLIN(1032)			_hx_tmp1 = false;
            		}
HXDLIN(1032)		if (_hx_tmp1) {
HXDLIN(1032)			Float _hx_tmp4 = this->y;
HXDLIN(1032)			Float _hx_tmp5 = (_hx_tmp4 + this->get_height());
HXDLIN(1032)			_hx_tmp = (_hx_tmp5 > ::flixel::FlxG_obj::worldBounds->y);
            		}
            		else {
HXDLIN(1032)			_hx_tmp = false;
            		}
HXDLIN(1032)		if (_hx_tmp) {
HXDLIN(1032)			 ::flixel::math::FlxRect _this1 = ::flixel::FlxG_obj::worldBounds;
HXDLIN(1032)			return (this->y < (_this1->y + _this1->height));
            		}
            		else {
HXDLIN(1032)			return false;
            		}
HXDLIN(1032)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxObject_obj,inWorldBounds,return )

 ::flixel::math::FlxBasePoint FlxObject_obj::getScreenPosition( ::flixel::math::FlxBasePoint result, ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1043_getScreenPosition)
HXLINE(1044)		if (::hx::IsNull( result )) {
HXLINE(1045)			 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN(1045)			point->_inPool = false;
HXDLIN(1045)			result = point;
            		}
HXLINE(1047)		if (::hx::IsNull( camera )) {
HXLINE(1048)			camera = this->getDefaultCamera();
            		}
HXLINE(1050)		{
HXLINE(1050)			Float y = this->y;
HXDLIN(1050)			result->set_x(this->x);
HXDLIN(1050)			result->set_y(y);
            		}
HXLINE(1051)		if (this->pixelPerfectPosition) {
HXLINE(1052)			result->set_x(( (Float)(::Math_obj::floor(result->x)) ));
HXDLIN(1052)			result->set_y(( (Float)(::Math_obj::floor(result->y)) ));
            		}
HXLINE(1054)		Float y1 = (camera->scroll->y * this->scrollFactor->y);
HXDLIN(1054)		result->set_x((result->x - (camera->scroll->x * this->scrollFactor->x)));
HXDLIN(1054)		result->set_y((result->y - y1));
HXDLIN(1054)		return result;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxObject_obj,getScreenPosition,return )

 ::flixel::math::FlxBasePoint FlxObject_obj::getPosition( ::flixel::math::FlxBasePoint result){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1064_getPosition)
HXLINE(1065)		if (::hx::IsNull( result )) {
HXLINE(1066)			 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN(1066)			point->_inPool = false;
HXDLIN(1066)			result = point;
            		}
HXLINE(1068)		Float y = this->y;
HXDLIN(1068)		result->set_x(this->x);
HXDLIN(1068)		result->set_y(y);
HXDLIN(1068)		return result;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,getPosition,return )

 ::flixel::math::FlxBasePoint FlxObject_obj::getMidpoint( ::flixel::math::FlxBasePoint point){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1079_getMidpoint)
HXLINE(1080)		if (::hx::IsNull( point )) {
HXLINE(1081)			 ::flixel::math::FlxBasePoint point1 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN(1081)			point1->_inPool = false;
HXDLIN(1081)			point = point1;
            		}
HXLINE(1082)		Float x = this->x;
HXDLIN(1082)		Float x1 = (x + (this->get_width() * ((Float)0.5)));
HXDLIN(1082)		Float y = this->y;
HXDLIN(1082)		Float y1 = (y + (this->get_height() * ((Float)0.5)));
HXDLIN(1082)		point->set_x(x1);
HXDLIN(1082)		point->set_y(y1);
HXDLIN(1082)		return point;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,getMidpoint,return )

 ::flixel::math::FlxRect FlxObject_obj::getHitbox( ::flixel::math::FlxRect rect){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1086_getHitbox)
HXLINE(1087)		if (::hx::IsNull( rect )) {
HXLINE(1088)			 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get().StaticCast<  ::flixel::math::FlxRect >();
HXDLIN(1088)			_this->x = ( (Float)(0) );
HXDLIN(1088)			_this->y = ( (Float)(0) );
HXDLIN(1088)			_this->width = ( (Float)(0) );
HXDLIN(1088)			_this->height = ( (Float)(0) );
HXDLIN(1088)			 ::flixel::math::FlxRect rect1 = _this;
HXDLIN(1088)			rect1->_inPool = false;
HXDLIN(1088)			rect = rect1;
            		}
HXLINE(1089)		Float x = this->x;
HXDLIN(1089)		Float y = this->y;
HXDLIN(1089)		Float width = this->get_width();
HXDLIN(1089)		Float height = this->get_height();
HXDLIN(1089)		rect->x = x;
HXDLIN(1089)		rect->y = y;
HXDLIN(1089)		rect->width = width;
HXDLIN(1089)		rect->height = height;
HXDLIN(1089)		return rect;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,getHitbox,return )

void FlxObject_obj::reset(Float x,Float y){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1100_reset)
HXLINE(1101)		this->touching = 0;
HXLINE(1102)		this->wasTouching = 0;
HXLINE(1103)		this->setPosition(x,y);
HXLINE(1104)		{
HXLINE(1104)			 ::flixel::math::FlxBasePoint this1 = this->last;
HXDLIN(1104)			Float y1 = this->y;
HXDLIN(1104)			this1->set_x(this->x);
HXDLIN(1104)			this1->set_y(y1);
            		}
HXLINE(1105)		{
HXLINE(1105)			 ::flixel::math::FlxBasePoint this2 = this->velocity;
HXDLIN(1105)			this2->set_x(( (Float)(0) ));
HXDLIN(1105)			this2->set_y(( (Float)(0) ));
            		}
HXLINE(1106)		this->revive();
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxObject_obj,reset,(void))

bool FlxObject_obj::isOnScreen( ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1116_isOnScreen)
HXLINE(1117)		if (::hx::IsNull( camera )) {
HXLINE(1118)			camera = this->getDefaultCamera();
            		}
HXLINE(1120)		this->getScreenPosition(this->_point,camera);
HXLINE(1121)		 ::flixel::math::FlxBasePoint point = this->_point;
HXDLIN(1121)		Float width = this->get_width();
HXDLIN(1121)		Float height = this->get_height();
HXDLIN(1121)		bool contained;
HXDLIN(1121)		bool contained1;
HXDLIN(1121)		bool contained2;
HXDLIN(1121)		if (((point->x + width) > camera->viewMarginX)) {
HXLINE(1121)			contained2 = (point->x < (( (Float)(camera->width) ) - camera->viewMarginX));
            		}
            		else {
HXLINE(1121)			contained2 = false;
            		}
HXDLIN(1121)		if (contained2) {
HXLINE(1121)			contained1 = ((point->y + height) > camera->viewMarginY);
            		}
            		else {
HXLINE(1121)			contained1 = false;
            		}
HXDLIN(1121)		if (contained1) {
HXLINE(1121)			contained = (point->y < (( (Float)(camera->height) ) - camera->viewMarginY));
            		}
            		else {
HXLINE(1121)			contained = false;
            		}
HXDLIN(1121)		{
HXLINE(1121)			 ::flixel::math::FlxBasePoint _this = point;
HXDLIN(1121)			if (_this->_weak) {
HXLINE(1121)				_this->put();
            			}
            		}
HXDLIN(1121)		return contained;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,isOnScreen,return )

bool FlxObject_obj::isPixelPerfectRender( ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1128_isPixelPerfectRender)
HXLINE(1129)		if (::hx::IsNull( camera )) {
HXLINE(1130)			camera = this->getDefaultCamera();
            		}
HXLINE(1131)		if (::hx::IsNull( this->pixelPerfectRender )) {
HXLINE(1131)			return camera->pixelPerfectRender;
            		}
            		else {
HXLINE(1131)			return ( (bool)(this->pixelPerfectRender) );
            		}
HXDLIN(1131)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,isPixelPerfectRender,return )

bool FlxObject_obj::isTouching(int direction){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1143_isTouching)
HXDLIN(1143)		return ((this->touching & direction) > 0);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,isTouching,return )

bool FlxObject_obj::justTouched(int direction){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1155_justTouched)
HXDLIN(1155)		if (((this->touching & direction) > 0)) {
HXDLIN(1155)			return ((this->wasTouching & direction) <= 0);
            		}
            		else {
HXDLIN(1155)			return false;
            		}
HXDLIN(1155)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,justTouched,return )

void FlxObject_obj::hurt(Float damage){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1170_hurt)
HXLINE(1171)		this->health = (this->health - damage);
HXLINE(1172)		if ((this->health <= 0)) {
HXLINE(1173)			this->kill();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,hurt,(void))

 ::flixel::FlxObject FlxObject_obj::screenCenter(::hx::Null< int >  __o_axes){
            		int axes = __o_axes.Default(17);
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1184_screenCenter)
HXLINE(1185)		bool _hx_tmp;
HXDLIN(1185)		if ((axes != 1)) {
HXLINE(1185)			_hx_tmp = (axes == 17);
            		}
            		else {
HXLINE(1185)			_hx_tmp = true;
            		}
HXDLIN(1185)		if (_hx_tmp) {
HXLINE(1186)			int _hx_tmp1 = ::flixel::FlxG_obj::width;
HXDLIN(1186)			this->set_x(((( (Float)(_hx_tmp1) ) - this->get_width()) / ( (Float)(2) )));
            		}
HXLINE(1188)		bool _hx_tmp2;
HXDLIN(1188)		if ((axes != 16)) {
HXLINE(1188)			_hx_tmp2 = (axes == 17);
            		}
            		else {
HXLINE(1188)			_hx_tmp2 = true;
            		}
HXDLIN(1188)		if (_hx_tmp2) {
HXLINE(1189)			int _hx_tmp3 = ::flixel::FlxG_obj::height;
HXDLIN(1189)			this->set_y(((( (Float)(_hx_tmp3) ) - this->get_height()) / ( (Float)(2) )));
            		}
HXLINE(1191)		return ::hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,screenCenter,return )

void FlxObject_obj::setPosition(::hx::Null< Float >  __o_x,::hx::Null< Float >  __o_y){
            		Float x = __o_x.Default(((Float)0.0));
            		Float y = __o_y.Default(((Float)0.0));
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1202_setPosition)
HXLINE(1203)		this->set_x(x);
HXLINE(1204)		this->set_y(y);
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxObject_obj,setPosition,(void))

void FlxObject_obj::setSize(Float width,Float height){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1214_setSize)
HXLINE(1215)		this->set_width(width);
HXLINE(1216)		this->set_height(height);
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxObject_obj,setSize,(void))

void FlxObject_obj::drawDebug(){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1221_drawDebug)
HXLINE(1222)		if (this->ignoreDrawDebug) {
HXLINE(1223)			return;
            		}
HXLINE(1225)		bool drawPath;
HXDLIN(1225)		if (::hx::IsNotNull( this->path )) {
HXLINE(1225)			drawPath = !(this->path->ignoreDrawDebug);
            		}
            		else {
HXLINE(1225)			drawPath = false;
            		}
HXLINE(1227)		{
HXLINE(1227)			int _g = 0;
HXDLIN(1227)			::Array< ::Dynamic> _g1 = this->getCamerasLegacy();
HXDLIN(1227)			while((_g < _g1->length)){
HXLINE(1227)				 ::flixel::FlxCamera camera = _g1->__get(_g).StaticCast<  ::flixel::FlxCamera >();
HXDLIN(1227)				_g = (_g + 1);
HXLINE(1229)				this->drawDebugOnCamera(camera);
HXLINE(1231)				if (drawPath) {
HXLINE(1233)					this->path->drawDebugOnCamera(camera);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxObject_obj,drawDebug,(void))

void FlxObject_obj::drawDebugOnCamera( ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1245_drawDebugOnCamera)
HXLINE(1246)		bool _hx_tmp;
HXDLIN(1246)		bool _hx_tmp1;
HXDLIN(1246)		if (camera->visible) {
HXLINE(1246)			_hx_tmp1 = !(camera->exists);
            		}
            		else {
HXLINE(1246)			_hx_tmp1 = true;
            		}
HXDLIN(1246)		if (!(_hx_tmp1)) {
HXLINE(1246)			_hx_tmp = !(this->isOnScreen(camera));
            		}
            		else {
HXLINE(1246)			_hx_tmp = true;
            		}
HXDLIN(1246)		if (_hx_tmp) {
HXLINE(1247)			return;
            		}
HXLINE(1249)		 ::flixel::math::FlxRect rect = this->getBoundingBox(camera);
HXLINE(1250)		 ::openfl::display::Graphics gfx;
HXDLIN(1250)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE(1250)			::flixel::util::FlxSpriteUtil_obj::flashGfx->clear();
HXDLIN(1250)			gfx = ::flixel::util::FlxSpriteUtil_obj::flashGfx;
            		}
            		else {
HXLINE(1250)			gfx = camera->debugLayer->get_graphics();
            		}
HXLINE(1251)		this->drawDebugBoundingBox(gfx,rect,this->allowCollisions,this->immovable);
HXLINE(1252)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE(1252)			camera->buffer->draw(::flixel::util::FlxSpriteUtil_obj::flashGfxSprite,null(),null(),null(),null(),null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,drawDebugOnCamera,(void))

void FlxObject_obj::drawDebugBoundingBox( ::openfl::display::Graphics gfx, ::flixel::math::FlxRect rect,int allowCollisions,bool partial){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1256_drawDebugBoundingBox)
HXLINE(1258)		 ::Dynamic color = this->getDebugBoundingBoxColor(allowCollisions);
HXLINE(1259)		this->drawDebugBoundingBoxColor(gfx,rect,( (int)(color) ));
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxObject_obj,drawDebugBoundingBox,(void))

 ::Dynamic FlxObject_obj::getDebugBoundingBoxColor(int allowCollisions){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1263_getDebugBoundingBoxColor)
HXLINE(1264)		if (::hx::IsNotNull( this->debugBoundingBoxColor )) {
HXLINE(1265)			return this->debugBoundingBoxColor;
            		}
HXLINE(1267)		if ((allowCollisions == 0)) {
HXLINE(1268)			return this->debugBoundingBoxColorNotSolid;
            		}
HXLINE(1270)		if ((allowCollisions == 4369)) {
HXLINE(1271)			return this->debugBoundingBoxColorSolid;
            		}
HXLINE(1273)		return this->debugBoundingBoxColorPartial;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,getDebugBoundingBoxColor,return )

void FlxObject_obj::drawDebugBoundingBoxColor( ::openfl::display::Graphics gfx, ::flixel::math::FlxRect rect,int color){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1278_drawDebugBoundingBoxColor)
HXLINE(1280)		gfx->lineStyle(1,color,((Float)0.75),null(),null(),null(),null(),null());
HXLINE(1281)		gfx->drawRect((rect->x + ((Float)0.5)),(rect->y + ((Float)0.5)),(rect->width - ((Float)1.0)),(rect->height - ((Float)1.0)));
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxObject_obj,drawDebugBoundingBoxColor,(void))

 ::openfl::display::Graphics FlxObject_obj::beginDrawDebug( ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1286_beginDrawDebug)
HXDLIN(1286)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE(1288)			::flixel::util::FlxSpriteUtil_obj::flashGfx->clear();
HXLINE(1289)			return ::flixel::util::FlxSpriteUtil_obj::flashGfx;
            		}
            		else {
HXLINE(1293)			return camera->debugLayer->get_graphics();
            		}
HXLINE(1286)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,beginDrawDebug,return )

void FlxObject_obj::endDrawDebug( ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1299_endDrawDebug)
HXDLIN(1299)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE(1300)			camera->buffer->draw(::flixel::util::FlxSpriteUtil_obj::flashGfxSprite,null(),null(),null(),null(),null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,endDrawDebug,(void))

 ::flixel::math::FlxRect FlxObject_obj::getBoundingBox( ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1306_getBoundingBox)
HXLINE(1307)		this->getScreenPosition(this->_point,camera);
HXLINE(1309)		{
HXLINE(1309)			 ::flixel::math::FlxRect _this = this->_rect;
HXDLIN(1309)			Float x = this->_point->x;
HXDLIN(1309)			Float y = this->_point->y;
HXDLIN(1309)			Float width = this->get_width();
HXDLIN(1309)			Float height = this->get_height();
HXDLIN(1309)			_this->x = x;
HXDLIN(1309)			_this->y = y;
HXDLIN(1309)			_this->width = width;
HXDLIN(1309)			_this->height = height;
            		}
HXLINE(1310)		this->_rect = camera->transformRect(this->_rect);
HXLINE(1312)		if (this->isPixelPerfectRender(camera)) {
HXLINE(1314)			 ::flixel::math::FlxRect _this1 = this->_rect;
HXDLIN(1314)			_this1->x = ( (Float)(::Math_obj::floor(_this1->x)) );
HXDLIN(1314)			_this1->y = ( (Float)(::Math_obj::floor(_this1->y)) );
HXDLIN(1314)			_this1->width = ( (Float)(::Math_obj::floor(_this1->width)) );
HXDLIN(1314)			_this1->height = ( (Float)(::Math_obj::floor(_this1->height)) );
            		}
HXLINE(1317)		return this->_rect;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,getBoundingBox,return )

 ::flixel::math::FlxRect FlxObject_obj::getRotatedBounds( ::flixel::math::FlxRect newRect){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1330_getRotatedBounds)
HXLINE(1331)		if (::hx::IsNull( newRect )) {
HXLINE(1332)			 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get().StaticCast<  ::flixel::math::FlxRect >();
HXDLIN(1332)			_this->x = ( (Float)(0) );
HXDLIN(1332)			_this->y = ( (Float)(0) );
HXDLIN(1332)			_this->width = ( (Float)(0) );
HXDLIN(1332)			_this->height = ( (Float)(0) );
HXDLIN(1332)			 ::flixel::math::FlxRect rect = _this;
HXDLIN(1332)			rect->_inPool = false;
HXDLIN(1332)			newRect = rect;
            		}
HXLINE(1334)		{
HXLINE(1334)			Float x = this->x;
HXDLIN(1334)			Float y = this->y;
HXDLIN(1334)			Float width = this->get_width();
HXDLIN(1334)			Float height = this->get_height();
HXDLIN(1334)			newRect->x = x;
HXDLIN(1334)			newRect->y = y;
HXDLIN(1334)			newRect->width = width;
HXDLIN(1334)			newRect->height = height;
            		}
HXLINE(1335)		return newRect->getRotatedBounds(this->angle,null(),newRect);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,getRotatedBounds,return )

::String FlxObject_obj::toString(){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1343_toString)
HXLINE(1344)		 ::Dynamic value = this->x;
HXDLIN(1344)		 ::flixel::util::LabelValuePair _this = ::flixel::util::LabelValuePair_obj::_pool->get().StaticCast<  ::flixel::util::LabelValuePair >();
HXDLIN(1344)		_this->label = HX_("x",78,00,00,00);
HXDLIN(1344)		_this->value = value;
HXLINE(1345)		 ::Dynamic value1 = this->y;
HXDLIN(1345)		 ::flixel::util::LabelValuePair _this1 = ::flixel::util::LabelValuePair_obj::_pool->get().StaticCast<  ::flixel::util::LabelValuePair >();
HXDLIN(1345)		_this1->label = HX_("y",79,00,00,00);
HXDLIN(1345)		_this1->value = value1;
HXLINE(1346)		 ::Dynamic value2 = this->get_width();
HXDLIN(1346)		 ::flixel::util::LabelValuePair _this2 = ::flixel::util::LabelValuePair_obj::_pool->get().StaticCast<  ::flixel::util::LabelValuePair >();
HXDLIN(1346)		_this2->label = HX_("w",77,00,00,00);
HXDLIN(1346)		_this2->value = value2;
HXLINE(1347)		 ::Dynamic value3 = this->get_height();
HXDLIN(1347)		 ::flixel::util::LabelValuePair _this3 = ::flixel::util::LabelValuePair_obj::_pool->get().StaticCast<  ::flixel::util::LabelValuePair >();
HXDLIN(1347)		_this3->label = HX_("h",68,00,00,00);
HXDLIN(1347)		_this3->value = value3;
HXLINE(1348)		 ::Dynamic value4 = this->visible;
HXDLIN(1348)		 ::flixel::util::LabelValuePair _this4 = ::flixel::util::LabelValuePair_obj::_pool->get().StaticCast<  ::flixel::util::LabelValuePair >();
HXDLIN(1348)		_this4->label = HX_("visible",72,78,24,a3);
HXDLIN(1348)		_this4->value = value4;
HXLINE(1349)		 ::Dynamic value5 = this->velocity;
HXDLIN(1349)		 ::flixel::util::LabelValuePair _this5 = ::flixel::util::LabelValuePair_obj::_pool->get().StaticCast<  ::flixel::util::LabelValuePair >();
HXDLIN(1349)		_this5->label = HX_("velocity",1d,02,fe,1e);
HXDLIN(1349)		_this5->value = value5;
HXLINE(1343)		return ::flixel::util::FlxStringUtil_obj::getDebugString(::Array_obj< ::Dynamic>::__new(6)->init(0,_this)->init(1,_this1)->init(2,_this2)->init(3,_this3)->init(4,_this4)->init(5,_this5));
            	}


Float FlxObject_obj::set_x(Float value){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1356_set_x)
HXDLIN(1356)		return (this->x = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,set_x,return )

Float FlxObject_obj::set_y(Float value){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1362_set_y)
HXDLIN(1362)		return (this->y = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,set_y,return )

Float FlxObject_obj::set_width(Float value){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1367_set_width)
HXLINE(1369)		if ((value < 0)) {
HXLINE(1371)			::flixel::FlxG_obj::log->advanced(HX_("An object's width cannot be smaller than 0. Use offset for sprites to control the hitbox position!",f5,8d,0b,95),::flixel::_hx_system::debug::log::LogStyle_obj::WARNING,true,::hx::SourceInfo(HX_("flixel/FlxObject.hx",80,0d,fe,f0),1371,HX_("flixel.FlxObject",1f,50,95,35),HX_("set_width",69,fe,5c,f1)));
HXLINE(1372)			return value;
            		}
HXLINE(1376)		return (this->width = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,set_width,return )

Float FlxObject_obj::set_height(Float value){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1381_set_height)
HXLINE(1383)		if ((value < 0)) {
HXLINE(1385)			::flixel::FlxG_obj::log->advanced(HX_("An object's height cannot be smaller than 0. Use offset for sprites to control the hitbox position!",b0,49,90,e4),::flixel::_hx_system::debug::log::LogStyle_obj::WARNING,true,::hx::SourceInfo(HX_("flixel/FlxObject.hx",80,0d,fe,f0),1385,HX_("flixel.FlxObject",1f,50,95,35),HX_("set_height",24,16,51,f6)));
HXLINE(1386)			return value;
            		}
HXLINE(1390)		return (this->height = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,set_height,return )

Float FlxObject_obj::get_width(){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1396_get_width)
HXDLIN(1396)		return this->width;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxObject_obj,get_width,return )

Float FlxObject_obj::get_height(){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1402_get_height)
HXDLIN(1402)		return this->height;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxObject_obj,get_height,return )

bool FlxObject_obj::get_solid(){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1408_get_solid)
HXDLIN(1408)		return ((this->allowCollisions & 4369) > 0);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxObject_obj,get_solid,return )

bool FlxObject_obj::set_solid(bool value){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1413_set_solid)
HXLINE(1414)		int _hx_tmp;
HXDLIN(1414)		if (value) {
HXLINE(1414)			_hx_tmp = 4369;
            		}
            		else {
HXLINE(1414)			_hx_tmp = 0;
            		}
HXDLIN(1414)		this->set_allowCollisions(_hx_tmp);
HXLINE(1415)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,set_solid,return )

Float FlxObject_obj::set_angle(Float value){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1421_set_angle)
HXDLIN(1421)		return (this->angle = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,set_angle,return )

bool FlxObject_obj::set_moves(bool value){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1427_set_moves)
HXDLIN(1427)		return (this->moves = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,set_moves,return )

bool FlxObject_obj::set_immovable(bool value){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1433_set_immovable)
HXDLIN(1433)		return (this->immovable = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,set_immovable,return )

bool FlxObject_obj::set_pixelPerfectRender(bool value){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1439_set_pixelPerfectRender)
HXDLIN(1439)		return ( (bool)((this->pixelPerfectRender = value)) );
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,set_pixelPerfectRender,return )

int FlxObject_obj::set_allowCollisions(int value){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1445_set_allowCollisions)
HXDLIN(1445)		return (this->allowCollisions = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,set_allowCollisions,return )

int FlxObject_obj::set_debugBoundingBoxColorSolid(int color){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1452_set_debugBoundingBoxColorSolid)
HXDLIN(1452)		return (this->debugBoundingBoxColorSolid = color);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,set_debugBoundingBoxColorSolid,return )

int FlxObject_obj::set_debugBoundingBoxColorNotSolid(int color){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1458_set_debugBoundingBoxColorNotSolid)
HXDLIN(1458)		return (this->debugBoundingBoxColorNotSolid = color);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,set_debugBoundingBoxColorNotSolid,return )

int FlxObject_obj::set_debugBoundingBoxColorPartial(int color){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1464_set_debugBoundingBoxColorPartial)
HXDLIN(1464)		return (this->debugBoundingBoxColorPartial = color);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,set_debugBoundingBoxColorPartial,return )

 ::flixel::path::FlxPath FlxObject_obj::set_path( ::flixel::path::FlxPath path){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_1470_set_path)
HXLINE(1471)		if (::hx::IsInstanceEq( this->path,path )) {
HXLINE(1472)			return path;
            		}
HXLINE(1474)		if (::hx::IsNotNull( this->path )) {
HXLINE(1475)			this->path->set_object(null());
            		}
HXLINE(1477)		if (::hx::IsNotNull( path )) {
HXLINE(1478)			path->set_object(::hx::ObjectPtr<OBJ_>(this));
            		}
HXLINE(1479)		return (this->path = path);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxObject_obj,set_path,return )

bool FlxObject_obj::defaultPixelPerfectPosition;

Float FlxObject_obj::SEPARATE_BIAS;

bool FlxObject_obj::defaultMoves;

bool FlxObject_obj::allowCollisionDrag(int type, ::flixel::FlxObject object1, ::flixel::FlxObject object2){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_98_allowCollisionDrag)
HXDLIN(  98)		bool _hx_tmp;
HXDLIN(  98)		if (object2->active) {
HXDLIN(  98)			_hx_tmp = object2->moves;
            		}
            		else {
HXDLIN(  98)			_hx_tmp = false;
            		}
HXDLIN(  98)		if (_hx_tmp) {
HXDLIN(  98)			switch((int)(type)){
            				case (int)0: {
HXLINE( 100)					return false;
            				}
            				break;
            				case (int)1: {
HXLINE( 101)					return true;
            				}
            				break;
            				case (int)2: {
HXLINE( 102)					return object2->immovable;
            				}
            				break;
            				case (int)3: {
HXLINE( 103)					if (!(object2->immovable)) {
HXLINE( 103)						return (object2->mass > object1->mass);
            					}
            					else {
HXLINE( 103)						return true;
            					}
            				}
            				break;
            			}
            		}
            		else {
HXDLIN(  98)			return false;
            		}
HXDLIN(  98)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(FlxObject_obj,allowCollisionDrag,return )

bool FlxObject_obj::processCheckTilemap( ::flixel::FlxObject object1, ::flixel::FlxObject object2, ::Dynamic func, ::flixel::math::FlxBasePoint position,::hx::Null< bool >  __o_isCollision){
            		bool isCollision = __o_isCollision.Default(true);
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_122_processCheckTilemap)
HXLINE( 124)		bool _hx_tmp;
HXDLIN( 124)		bool _hx_tmp1;
HXDLIN( 124)		if (isCollision) {
HXLINE( 124)			_hx_tmp1 = object1->immovable;
            		}
            		else {
HXLINE( 124)			_hx_tmp1 = false;
            		}
HXDLIN( 124)		if (_hx_tmp1) {
HXLINE( 124)			_hx_tmp = object2->immovable;
            		}
            		else {
HXLINE( 124)			_hx_tmp = false;
            		}
HXDLIN( 124)		if (_hx_tmp) {
HXLINE( 125)			return false;
            		}
HXLINE( 128)		if ((object1->flixelType == 3)) {
            			HX_BEGIN_LOCAL_FUNC_S4(::hx::LocalFunc,_hx_Closure_0, ::flixel::FlxObject,object2, ::Dynamic,func,bool,isCollision, ::flixel::math::FlxBasePoint,position) HXARGC(2)
            			bool _hx_run( ::flixel::FlxObject tile, ::flixel::FlxObject _){
            				HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_135_processCheckTilemap)
HXLINE( 135)				return ::flixel::FlxObject_obj::processCheckTilemap(tile,object2,func,position,isCollision);
            			}
            			HX_END_LOCAL_FUNC2(return)

HXLINE( 130)			 ::flixel::tile::FlxBaseTilemap tilemap = ( ( ::flixel::tile::FlxBaseTilemap)(object1) );
HXLINE( 132)			 ::Dynamic recurseProcess =  ::Dynamic(new _hx_Closure_0(object2,func,isCollision,position));
HXLINE( 137)			return tilemap->overlapsWithCallback(object2,recurseProcess,false,position);
            		}
            		else {
HXLINE( 139)			if ((object2->flixelType == 3)) {
            				HX_BEGIN_LOCAL_FUNC_S4(::hx::LocalFunc,_hx_Closure_1, ::Dynamic,func,bool,isCollision, ::flixel::math::FlxBasePoint,position, ::flixel::FlxObject,object1) HXARGC(2)
            				bool _hx_run( ::flixel::FlxObject tile, ::flixel::FlxObject _){
            					HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_146_processCheckTilemap)
HXLINE( 146)					return ::flixel::FlxObject_obj::processCheckTilemap(object1,tile,func,position,isCollision);
            				}
            				HX_END_LOCAL_FUNC2(return)

HXLINE( 141)				 ::flixel::tile::FlxBaseTilemap tilemap1 = ( ( ::flixel::tile::FlxBaseTilemap)(object2) );
HXLINE( 143)				 ::Dynamic recurseProcess1 =  ::Dynamic(new _hx_Closure_1(func,isCollision,position,object1));
HXLINE( 148)				return tilemap1->overlapsWithCallback(object1,recurseProcess1,false,position);
            			}
            		}
HXLINE( 151)		return ( (bool)(func(object1,object2)) );
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(FlxObject_obj,processCheckTilemap,return )

bool FlxObject_obj::separate( ::flixel::FlxObject object1, ::flixel::FlxObject object2){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_161_separate)
HXLINE( 162)		bool separatedX = ::flixel::FlxObject_obj::separateX(object1,object2);
HXLINE( 163)		bool separatedY = ::flixel::FlxObject_obj::separateY(object1,object2);
HXLINE( 164)		if (!(separatedX)) {
HXLINE( 164)			return separatedY;
            		}
            		else {
HXLINE( 164)			return true;
            		}
HXDLIN( 164)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxObject_obj,separate,return )

bool FlxObject_obj::separateX( ::flixel::FlxObject object1, ::flixel::FlxObject object2){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_189_separateX)
HXDLIN( 189)		return ::flixel::FlxObject_obj::processCheckTilemap(object1,object2,::flixel::FlxObject_obj::separateXHelper_dyn(),null(),null());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxObject_obj,separateX,return )

bool FlxObject_obj::separateY( ::flixel::FlxObject object1, ::flixel::FlxObject object2){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_200_separateY)
HXDLIN( 200)		return ::flixel::FlxObject_obj::processCheckTilemap(object1,object2,::flixel::FlxObject_obj::separateYHelper_dyn(),null(),null());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxObject_obj,separateY,return )

bool FlxObject_obj::separateXHelper( ::flixel::FlxObject object1, ::flixel::FlxObject object2){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_207_separateXHelper)
HXLINE( 208)		Float overlap = ::flixel::FlxObject_obj::computeOverlapX(object1,object2,null());
HXLINE( 210)		if ((overlap != 0)) {
HXLINE( 212)			Float delta1 = (object1->x - object1->last->x);
HXLINE( 213)			Float delta2 = (object2->x - object2->last->x);
HXLINE( 214)			Float vel1 = object1->velocity->x;
HXLINE( 215)			Float vel2 = object2->velocity->x;
HXLINE( 217)			bool _hx_tmp;
HXDLIN( 217)			if (!(object1->immovable)) {
HXLINE( 217)				_hx_tmp = !(object2->immovable);
            			}
            			else {
HXLINE( 217)				_hx_tmp = false;
            			}
HXDLIN( 217)			if (_hx_tmp) {
HXLINE( 222)				object1->set_x((object1->x - (overlap * ((Float)0.5))));
HXLINE( 223)				object2->set_x((object2->x + (overlap * ((Float)0.5))));
HXLINE( 225)				Float mass1 = object1->mass;
HXLINE( 226)				Float mass2 = object2->mass;
HXLINE( 227)				Float momentum = ((mass1 * vel1) + (mass2 * vel2));
HXLINE( 228)				object1->velocity->set_x(((momentum + ((object1->elasticity * mass2) * (vel2 - vel1))) / (mass1 + mass2)));
HXLINE( 229)				object2->velocity->set_x(((momentum + ((object2->elasticity * mass1) * (vel1 - vel2))) / (mass1 + mass2)));
            			}
            			else {
HXLINE( 232)				if (!(object1->immovable)) {
HXLINE( 234)					object1->set_x((object1->x - overlap));
HXLINE( 235)					object1->velocity->set_x((vel2 - (vel1 * object1->elasticity)));
            				}
            				else {
HXLINE( 237)					if (!(object2->immovable)) {
HXLINE( 239)						object2->set_x((object2->x + overlap));
HXLINE( 240)						object2->velocity->set_x((vel1 - (vel2 * object2->elasticity)));
            					}
            				}
            			}
HXLINE( 244)			bool _hx_tmp1;
HXDLIN( 244)			if (::flixel::FlxObject_obj::allowCollisionDrag(object1->collisionYDrag,object1,object2)) {
HXLINE( 244)				_hx_tmp1 = (delta1 > delta2);
            			}
            			else {
HXLINE( 244)				_hx_tmp1 = false;
            			}
HXDLIN( 244)			if (_hx_tmp1) {
HXLINE( 245)				object1->set_y((object1->y + (object2->y - object2->last->y)));
            			}
            			else {
HXLINE( 246)				bool _hx_tmp2;
HXDLIN( 246)				if (::flixel::FlxObject_obj::allowCollisionDrag(object2->collisionYDrag,object2,object1)) {
HXLINE( 246)					_hx_tmp2 = (delta2 > delta1);
            				}
            				else {
HXLINE( 246)					_hx_tmp2 = false;
            				}
HXDLIN( 246)				if (_hx_tmp2) {
HXLINE( 247)					object2->set_y((object2->y + (object1->y - object1->last->y)));
            				}
            			}
HXLINE( 249)			return true;
            		}
HXLINE( 252)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxObject_obj,separateXHelper,return )

bool FlxObject_obj::separateYHelper( ::flixel::FlxObject object1, ::flixel::FlxObject object2){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_259_separateYHelper)
HXLINE( 260)		Float overlap = ::flixel::FlxObject_obj::computeOverlapY(object1,object2,null());
HXLINE( 262)		if ((overlap != 0)) {
HXLINE( 264)			Float delta1 = (object1->y - object1->last->y);
HXLINE( 265)			Float delta2 = (object2->y - object2->last->y);
HXLINE( 266)			Float vel1 = object1->velocity->y;
HXLINE( 267)			Float vel2 = object2->velocity->y;
HXLINE( 269)			bool _hx_tmp;
HXDLIN( 269)			if (!(object1->immovable)) {
HXLINE( 269)				_hx_tmp = !(object2->immovable);
            			}
            			else {
HXLINE( 269)				_hx_tmp = false;
            			}
HXDLIN( 269)			if (_hx_tmp) {
HXLINE( 274)				object1->set_y((object1->y - (overlap / ( (Float)(2) ))));
HXLINE( 275)				object2->set_y((object2->y + (overlap / ( (Float)(2) ))));
HXLINE( 277)				Float mass1 = object1->mass;
HXLINE( 278)				Float mass2 = object2->mass;
HXLINE( 279)				Float momentum = ((mass1 * vel1) + (mass2 * vel2));
HXLINE( 280)				Float newVel1 = ((momentum + ((object1->elasticity * mass2) * (vel2 - vel1))) / (mass1 + mass2));
HXLINE( 281)				Float newVel2 = ((momentum + ((object2->elasticity * mass1) * (vel1 - vel2))) / (mass1 + mass2));
HXLINE( 282)				object1->velocity->set_y(newVel1);
HXLINE( 283)				object2->velocity->set_y(newVel2);
            			}
            			else {
HXLINE( 286)				if (!(object1->immovable)) {
HXLINE( 288)					object1->set_y((object1->y - overlap));
HXLINE( 289)					object1->velocity->set_y((vel2 - (vel1 * object1->elasticity)));
            				}
            				else {
HXLINE( 291)					if (!(object2->immovable)) {
HXLINE( 293)						object2->set_y((object2->y + overlap));
HXLINE( 294)						object2->velocity->set_y((vel1 - (vel2 * object2->elasticity)));
            					}
            				}
            			}
HXLINE( 298)			bool _hx_tmp1;
HXDLIN( 298)			if (::flixel::FlxObject_obj::allowCollisionDrag(object1->collisionXDrag,object1,object2)) {
HXLINE( 298)				_hx_tmp1 = (delta1 > delta2);
            			}
            			else {
HXLINE( 298)				_hx_tmp1 = false;
            			}
HXDLIN( 298)			if (_hx_tmp1) {
HXLINE( 299)				object1->set_x((object1->x + (object2->x - object2->last->x)));
            			}
            			else {
HXLINE( 300)				bool _hx_tmp2;
HXDLIN( 300)				if (::flixel::FlxObject_obj::allowCollisionDrag(object2->collisionXDrag,object2,object1)) {
HXLINE( 300)					_hx_tmp2 = (delta2 > delta1);
            				}
            				else {
HXLINE( 300)					_hx_tmp2 = false;
            				}
HXDLIN( 300)				if (_hx_tmp2) {
HXLINE( 301)					object2->set_x((object2->x + (object1->x - object1->last->x)));
            				}
            			}
HXLINE( 303)			return true;
            		}
HXLINE( 306)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxObject_obj,separateYHelper,return )

void FlxObject_obj::legacySeparateX( ::flixel::FlxObject object1, ::flixel::FlxObject object2,Float overlap){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_314_legacySeparateX)
HXLINE( 315)		Float vel1 = object1->velocity->x;
HXLINE( 316)		Float vel2 = object2->velocity->x;
HXLINE( 317)		Float mass1 = object1->mass;
HXLINE( 318)		Float mass2 = object2->mass;
HXLINE( 319)		object1->set_x((object1->x - (overlap * ((Float)0.5))));
HXLINE( 320)		object2->set_x((object2->x + (overlap * ((Float)0.5))));
HXLINE( 322)		int newVel1;
HXDLIN( 322)		if ((vel2 > 0)) {
HXLINE( 322)			newVel1 = 1;
            		}
            		else {
HXLINE( 322)			newVel1 = -1;
            		}
HXDLIN( 322)		Float newVel11 = (::Math_obj::sqrt((((vel2 * vel2) * mass2) / mass1)) * ( (Float)(newVel1) ));
HXLINE( 323)		int newVel2;
HXDLIN( 323)		if ((vel1 > 0)) {
HXLINE( 323)			newVel2 = 1;
            		}
            		else {
HXLINE( 323)			newVel2 = -1;
            		}
HXDLIN( 323)		Float newVel21 = (::Math_obj::sqrt((((vel1 * vel1) * mass1) / mass2)) * ( (Float)(newVel2) ));
HXLINE( 324)		Float average = ((newVel11 + newVel21) * ((Float)0.5));
HXLINE( 325)		newVel11 = (newVel11 - average);
HXLINE( 326)		newVel21 = (newVel21 - average);
HXLINE( 327)		object1->velocity->set_x((average + (newVel11 * object1->elasticity)));
HXLINE( 328)		object2->velocity->set_x((average + (newVel21 * object2->elasticity)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(FlxObject_obj,legacySeparateX,(void))

void FlxObject_obj::legacySeparateY( ::flixel::FlxObject object1, ::flixel::FlxObject object2,Float overlap){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_336_legacySeparateY)
HXLINE( 337)		Float vel1 = object1->velocity->y;
HXLINE( 338)		Float vel2 = object2->velocity->y;
HXLINE( 339)		Float mass1 = object1->mass;
HXLINE( 340)		Float mass2 = object2->mass;
HXLINE( 341)		object1->set_y((object1->y - (overlap * ((Float)0.5))));
HXLINE( 342)		object2->set_y((object2->y + (overlap * ((Float)0.5))));
HXLINE( 344)		int newVel1;
HXDLIN( 344)		if ((vel2 > 0)) {
HXLINE( 344)			newVel1 = 1;
            		}
            		else {
HXLINE( 344)			newVel1 = -1;
            		}
HXDLIN( 344)		Float newVel11 = (::Math_obj::sqrt((((vel2 * vel2) * mass2) / mass1)) * ( (Float)(newVel1) ));
HXLINE( 345)		int newVel2;
HXDLIN( 345)		if ((vel1 > 0)) {
HXLINE( 345)			newVel2 = 1;
            		}
            		else {
HXLINE( 345)			newVel2 = -1;
            		}
HXDLIN( 345)		Float newVel21 = (::Math_obj::sqrt((((vel1 * vel1) * mass1) / mass2)) * ( (Float)(newVel2) ));
HXLINE( 346)		Float average = ((newVel11 + newVel21) * ((Float)0.5));
HXLINE( 347)		newVel11 = (newVel11 - average);
HXLINE( 348)		newVel21 = (newVel21 - average);
HXLINE( 349)		object1->velocity->set_y((average + (newVel11 * object1->elasticity)));
HXLINE( 350)		object2->velocity->set_y((average + (newVel21 * object2->elasticity)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(FlxObject_obj,legacySeparateY,(void))

bool FlxObject_obj::updateTouchingFlags( ::flixel::FlxObject object1, ::flixel::FlxObject object2){
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(2)
            		bool _hx_run( ::flixel::FlxObject object1, ::flixel::FlxObject object2){
            			HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_362_updateTouchingFlags)
HXLINE( 363)			bool touchingX = ::flixel::FlxObject_obj::updateTouchingFlagsXHelper(object1,object2);
HXLINE( 364)			bool touchingY = ::flixel::FlxObject_obj::updateTouchingFlagsYHelper(object1,object2);
HXLINE( 365)			if (!(touchingX)) {
HXLINE( 365)				return touchingY;
            			}
            			else {
HXLINE( 365)				return true;
            			}
HXDLIN( 365)			return false;
            		}
            		HX_END_LOCAL_FUNC2(return)

            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_360_updateTouchingFlags)
HXLINE( 361)		 ::Dynamic helper =  ::Dynamic(new _hx_Closure_0());
HXLINE( 367)		return ::flixel::FlxObject_obj::processCheckTilemap(object1,object2,helper,null(),false);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxObject_obj,updateTouchingFlags,return )

bool FlxObject_obj::updateTouchingFlagsX( ::flixel::FlxObject object1, ::flixel::FlxObject object2){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_378_updateTouchingFlagsX)
HXDLIN( 378)		return ::flixel::FlxObject_obj::processCheckTilemap(object1,object2,::flixel::FlxObject_obj::updateTouchingFlagsXHelper_dyn(),null(),false);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxObject_obj,updateTouchingFlagsX,return )

bool FlxObject_obj::updateTouchingFlagsXHelper( ::flixel::FlxObject object1, ::flixel::FlxObject object2){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_384_updateTouchingFlagsXHelper)
HXDLIN( 384)		return (::flixel::FlxObject_obj::computeOverlapX(object1,object2,false) != 0);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxObject_obj,updateTouchingFlagsXHelper,return )

bool FlxObject_obj::updateTouchingFlagsY( ::flixel::FlxObject object1, ::flixel::FlxObject object2){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_395_updateTouchingFlagsY)
HXDLIN( 395)		return ::flixel::FlxObject_obj::processCheckTilemap(object1,object2,::flixel::FlxObject_obj::updateTouchingFlagsYHelper_dyn(),null(),false);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxObject_obj,updateTouchingFlagsY,return )

bool FlxObject_obj::updateTouchingFlagsYHelper( ::flixel::FlxObject object1, ::flixel::FlxObject object2){
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_401_updateTouchingFlagsYHelper)
HXDLIN( 401)		return (::flixel::FlxObject_obj::computeOverlapY(object1,object2,false) != 0);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxObject_obj,updateTouchingFlagsYHelper,return )

Float FlxObject_obj::computeOverlapX( ::flixel::FlxObject object1, ::flixel::FlxObject object2,::hx::Null< bool >  __o_checkMaxOverlap){
            		bool checkMaxOverlap = __o_checkMaxOverlap.Default(true);
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_410_computeOverlapX)
HXLINE( 411)		Float overlap = ( (Float)(0) );
HXLINE( 413)		Float delta1 = (object1->x - object1->last->x);
HXLINE( 414)		Float delta2 = (object2->x - object2->last->x);
HXLINE( 416)		if ((delta1 != delta2)) {
HXLINE( 419)			Float delta1Abs;
HXDLIN( 419)			if ((delta1 > 0)) {
HXLINE( 419)				delta1Abs = delta1;
            			}
            			else {
HXLINE( 419)				delta1Abs = -(delta1);
            			}
HXLINE( 420)			Float delta2Abs;
HXDLIN( 420)			if ((delta2 > 0)) {
HXLINE( 420)				delta2Abs = delta2;
            			}
            			else {
HXLINE( 420)				delta2Abs = -(delta2);
            			}
HXLINE( 422)			Float X;
HXDLIN( 422)			if ((delta1 > 0)) {
HXLINE( 422)				X = delta1;
            			}
            			else {
HXLINE( 422)				X = ( (Float)(0) );
            			}
HXDLIN( 422)			Float X1 = (object1->x - X);
HXDLIN( 422)			Float Y = object1->last->y;
HXDLIN( 422)			Float Width = (object1->get_width() + delta1Abs);
HXDLIN( 422)			Float Height = object1->get_height();
HXDLIN( 422)			 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get().StaticCast<  ::flixel::math::FlxRect >();
HXDLIN( 422)			_this->x = X1;
HXDLIN( 422)			_this->y = Y;
HXDLIN( 422)			_this->width = Width;
HXDLIN( 422)			_this->height = Height;
HXDLIN( 422)			 ::flixel::math::FlxRect rect = _this;
HXDLIN( 422)			rect->_inPool = false;
HXDLIN( 422)			 ::flixel::math::FlxRect rect1 = rect;
HXLINE( 423)			Float X2;
HXDLIN( 423)			if ((delta2 > 0)) {
HXLINE( 423)				X2 = delta2;
            			}
            			else {
HXLINE( 423)				X2 = ( (Float)(0) );
            			}
HXDLIN( 423)			Float X3 = (object2->x - X2);
HXDLIN( 423)			Float Y1 = object2->last->y;
HXDLIN( 423)			Float Width1 = (object2->get_width() + delta2Abs);
HXDLIN( 423)			Float Height1 = object2->get_height();
HXDLIN( 423)			 ::flixel::math::FlxRect _this1 = ::flixel::math::FlxRect_obj::_pool->get().StaticCast<  ::flixel::math::FlxRect >();
HXDLIN( 423)			_this1->x = X3;
HXDLIN( 423)			_this1->y = Y1;
HXDLIN( 423)			_this1->width = Width1;
HXDLIN( 423)			_this1->height = Height1;
HXDLIN( 423)			 ::flixel::math::FlxRect rect2 = _this1;
HXDLIN( 423)			rect2->_inPool = false;
HXDLIN( 423)			 ::flixel::math::FlxRect rect21 = rect2;
HXLINE( 425)			bool result;
HXDLIN( 425)			bool result1;
HXDLIN( 425)			bool result2;
HXDLIN( 425)			if (((rect21->x + rect21->width) > rect1->x)) {
HXLINE( 425)				result2 = (rect21->x < (rect1->x + rect1->width));
            			}
            			else {
HXLINE( 425)				result2 = false;
            			}
HXDLIN( 425)			if (result2) {
HXLINE( 425)				result1 = ((rect21->y + rect21->height) > rect1->y);
            			}
            			else {
HXLINE( 425)				result1 = false;
            			}
HXDLIN( 425)			if (result1) {
HXLINE( 425)				result = (rect21->y < (rect1->y + rect1->height));
            			}
            			else {
HXLINE( 425)				result = false;
            			}
HXDLIN( 425)			if (rect21->_weak) {
HXLINE( 425)				if (!(rect21->_inPool)) {
HXLINE( 425)					rect21->_inPool = true;
HXDLIN( 425)					rect21->_weak = false;
HXDLIN( 425)					::flixel::math::FlxRect_obj::_pool->putUnsafe(rect21);
            				}
            			}
HXDLIN( 425)			if (result) {
HXLINE( 427)				Float maxOverlap;
HXDLIN( 427)				if (checkMaxOverlap) {
HXLINE( 427)					maxOverlap = ((delta1Abs + delta2Abs) + ::flixel::FlxObject_obj::SEPARATE_BIAS);
            				}
            				else {
HXLINE( 427)					maxOverlap = ( (Float)(0) );
            				}
HXLINE( 435)				if ((delta1 > delta2)) {
HXLINE( 437)					Float object11 = object1->x;
HXDLIN( 437)					Float overlap1 = (object11 + object1->get_width());
HXDLIN( 437)					overlap = (overlap1 - object2->x);
HXLINE( 438)					bool _hx_tmp;
HXDLIN( 438)					bool _hx_tmp1;
HXDLIN( 438)					bool _hx_tmp2;
HXDLIN( 438)					if (checkMaxOverlap) {
HXLINE( 438)						_hx_tmp2 = (overlap > maxOverlap);
            					}
            					else {
HXLINE( 438)						_hx_tmp2 = false;
            					}
HXDLIN( 438)					if (!(_hx_tmp2)) {
HXLINE( 439)						int dir = 16;
HXLINE( 438)						_hx_tmp1 = ((object1->allowCollisions & dir) != dir);
            					}
            					else {
HXLINE( 438)						_hx_tmp1 = true;
            					}
HXDLIN( 438)					if (!(_hx_tmp1)) {
HXLINE( 440)						int dir1 = 1;
HXLINE( 438)						_hx_tmp = ((object2->allowCollisions & dir1) != dir1);
            					}
            					else {
HXLINE( 438)						_hx_tmp = true;
            					}
HXDLIN( 438)					if (_hx_tmp) {
HXLINE( 442)						overlap = ( (Float)(0) );
            					}
            					else {
HXLINE( 446)						 ::flixel::FlxObject object12 = object1;
HXDLIN( 446)						object12->touching = (object12->touching | 16);
HXLINE( 447)						 ::flixel::FlxObject object21 = object2;
HXDLIN( 447)						object21->touching = (object21->touching | 1);
            					}
            				}
            				else {
HXLINE( 450)					if ((delta1 < delta2)) {
HXLINE( 452)						Float object13 = object1->x;
HXDLIN( 452)						Float overlap2 = (object13 - object2->get_width());
HXDLIN( 452)						overlap = (overlap2 - object2->x);
HXLINE( 453)						bool _hx_tmp3;
HXDLIN( 453)						bool _hx_tmp4;
HXDLIN( 453)						bool _hx_tmp5;
HXDLIN( 453)						if (checkMaxOverlap) {
HXLINE( 453)							_hx_tmp5 = (-(overlap) > maxOverlap);
            						}
            						else {
HXLINE( 453)							_hx_tmp5 = false;
            						}
HXDLIN( 453)						if (!(_hx_tmp5)) {
HXLINE( 454)							int dir2 = 1;
HXLINE( 453)							_hx_tmp4 = ((object1->allowCollisions & dir2) != dir2);
            						}
            						else {
HXLINE( 453)							_hx_tmp4 = true;
            						}
HXDLIN( 453)						if (!(_hx_tmp4)) {
HXLINE( 455)							int dir3 = 16;
HXLINE( 453)							_hx_tmp3 = ((object2->allowCollisions & dir3) != dir3);
            						}
            						else {
HXLINE( 453)							_hx_tmp3 = true;
            						}
HXDLIN( 453)						if (_hx_tmp3) {
HXLINE( 457)							overlap = ( (Float)(0) );
            						}
            						else {
HXLINE( 461)							 ::flixel::FlxObject object14 = object1;
HXDLIN( 461)							object14->touching = (object14->touching | 1);
HXLINE( 462)							 ::flixel::FlxObject object22 = object2;
HXDLIN( 462)							object22->touching = (object22->touching | 16);
            						}
            					}
            				}
            			}
HXLINE( 467)			if (!(rect1->_inPool)) {
HXLINE( 467)				rect1->_inPool = true;
HXDLIN( 467)				rect1->_weak = false;
HXDLIN( 467)				::flixel::math::FlxRect_obj::_pool->putUnsafe(rect1);
            			}
HXLINE( 468)			if (!(rect21->_inPool)) {
HXLINE( 468)				rect21->_inPool = true;
HXDLIN( 468)				rect21->_weak = false;
HXDLIN( 468)				::flixel::math::FlxRect_obj::_pool->putUnsafe(rect21);
            			}
            		}
HXLINE( 471)		return overlap;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(FlxObject_obj,computeOverlapX,return )

Float FlxObject_obj::computeOverlapY( ::flixel::FlxObject object1, ::flixel::FlxObject object2,::hx::Null< bool >  __o_checkMaxOverlap){
            		bool checkMaxOverlap = __o_checkMaxOverlap.Default(true);
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_480_computeOverlapY)
HXLINE( 481)		Float overlap = ( (Float)(0) );
HXLINE( 483)		Float delta1 = (object1->y - object1->last->y);
HXLINE( 484)		Float delta2 = (object2->y - object2->last->y);
HXLINE( 486)		if ((delta1 != delta2)) {
HXLINE( 489)			Float delta1Abs;
HXDLIN( 489)			if ((delta1 > 0)) {
HXLINE( 489)				delta1Abs = delta1;
            			}
            			else {
HXLINE( 489)				delta1Abs = -(delta1);
            			}
HXLINE( 490)			Float delta2Abs;
HXDLIN( 490)			if ((delta2 > 0)) {
HXLINE( 490)				delta2Abs = delta2;
            			}
            			else {
HXLINE( 490)				delta2Abs = -(delta2);
            			}
HXLINE( 492)			Float X = object1->last->x;
HXDLIN( 492)			Float Y;
HXDLIN( 492)			if ((delta1 > 0)) {
HXLINE( 492)				Y = delta1;
            			}
            			else {
HXLINE( 492)				Y = ( (Float)(0) );
            			}
HXDLIN( 492)			Float Y1 = (object1->y - Y);
HXDLIN( 492)			Float Width = object1->get_width();
HXDLIN( 492)			Float Height = (object1->get_height() + delta1Abs);
HXDLIN( 492)			 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get().StaticCast<  ::flixel::math::FlxRect >();
HXDLIN( 492)			_this->x = X;
HXDLIN( 492)			_this->y = Y1;
HXDLIN( 492)			_this->width = Width;
HXDLIN( 492)			_this->height = Height;
HXDLIN( 492)			 ::flixel::math::FlxRect rect = _this;
HXDLIN( 492)			rect->_inPool = false;
HXDLIN( 492)			 ::flixel::math::FlxRect rect1 = rect;
HXLINE( 493)			Float X1 = object2->last->x;
HXDLIN( 493)			Float Y2;
HXDLIN( 493)			if ((delta2 > 0)) {
HXLINE( 493)				Y2 = delta2;
            			}
            			else {
HXLINE( 493)				Y2 = ( (Float)(0) );
            			}
HXDLIN( 493)			Float Y3 = (object2->y - Y2);
HXDLIN( 493)			Float Width1 = object2->get_width();
HXDLIN( 493)			Float Height1 = (object2->get_height() + delta2Abs);
HXDLIN( 493)			 ::flixel::math::FlxRect _this1 = ::flixel::math::FlxRect_obj::_pool->get().StaticCast<  ::flixel::math::FlxRect >();
HXDLIN( 493)			_this1->x = X1;
HXDLIN( 493)			_this1->y = Y3;
HXDLIN( 493)			_this1->width = Width1;
HXDLIN( 493)			_this1->height = Height1;
HXDLIN( 493)			 ::flixel::math::FlxRect rect2 = _this1;
HXDLIN( 493)			rect2->_inPool = false;
HXDLIN( 493)			 ::flixel::math::FlxRect rect21 = rect2;
HXLINE( 495)			bool result;
HXDLIN( 495)			bool result1;
HXDLIN( 495)			bool result2;
HXDLIN( 495)			if (((rect21->x + rect21->width) > rect1->x)) {
HXLINE( 495)				result2 = (rect21->x < (rect1->x + rect1->width));
            			}
            			else {
HXLINE( 495)				result2 = false;
            			}
HXDLIN( 495)			if (result2) {
HXLINE( 495)				result1 = ((rect21->y + rect21->height) > rect1->y);
            			}
            			else {
HXLINE( 495)				result1 = false;
            			}
HXDLIN( 495)			if (result1) {
HXLINE( 495)				result = (rect21->y < (rect1->y + rect1->height));
            			}
            			else {
HXLINE( 495)				result = false;
            			}
HXDLIN( 495)			if (rect21->_weak) {
HXLINE( 495)				if (!(rect21->_inPool)) {
HXLINE( 495)					rect21->_inPool = true;
HXDLIN( 495)					rect21->_weak = false;
HXDLIN( 495)					::flixel::math::FlxRect_obj::_pool->putUnsafe(rect21);
            				}
            			}
HXDLIN( 495)			if (result) {
HXLINE( 497)				Float maxOverlap;
HXDLIN( 497)				if (checkMaxOverlap) {
HXLINE( 497)					maxOverlap = ((delta1Abs + delta2Abs) + ::flixel::FlxObject_obj::SEPARATE_BIAS);
            				}
            				else {
HXLINE( 497)					maxOverlap = ( (Float)(0) );
            				}
HXLINE( 505)				if ((delta1 > delta2)) {
HXLINE( 507)					Float object11 = object1->y;
HXDLIN( 507)					Float overlap1 = (object11 + object1->get_height());
HXDLIN( 507)					overlap = (overlap1 - object2->y);
HXLINE( 508)					bool _hx_tmp;
HXDLIN( 508)					bool _hx_tmp1;
HXDLIN( 508)					bool _hx_tmp2;
HXDLIN( 508)					if (checkMaxOverlap) {
HXLINE( 508)						_hx_tmp2 = (overlap > maxOverlap);
            					}
            					else {
HXLINE( 508)						_hx_tmp2 = false;
            					}
HXDLIN( 508)					if (!(_hx_tmp2)) {
HXLINE( 509)						int dir = 4096;
HXLINE( 508)						_hx_tmp1 = ((object1->allowCollisions & dir) != dir);
            					}
            					else {
HXLINE( 508)						_hx_tmp1 = true;
            					}
HXDLIN( 508)					if (!(_hx_tmp1)) {
HXLINE( 510)						int dir1 = 256;
HXLINE( 508)						_hx_tmp = ((object2->allowCollisions & dir1) != dir1);
            					}
            					else {
HXLINE( 508)						_hx_tmp = true;
            					}
HXDLIN( 508)					if (_hx_tmp) {
HXLINE( 512)						overlap = ( (Float)(0) );
            					}
            					else {
HXLINE( 516)						 ::flixel::FlxObject object12 = object1;
HXDLIN( 516)						object12->touching = (object12->touching | 4096);
HXLINE( 517)						 ::flixel::FlxObject object21 = object2;
HXDLIN( 517)						object21->touching = (object21->touching | 256);
            					}
            				}
            				else {
HXLINE( 520)					if ((delta1 < delta2)) {
HXLINE( 522)						Float object13 = object1->y;
HXDLIN( 522)						Float overlap2 = (object13 - object2->get_height());
HXDLIN( 522)						overlap = (overlap2 - object2->y);
HXLINE( 523)						bool _hx_tmp3;
HXDLIN( 523)						bool _hx_tmp4;
HXDLIN( 523)						bool _hx_tmp5;
HXDLIN( 523)						if (checkMaxOverlap) {
HXLINE( 523)							_hx_tmp5 = (-(overlap) > maxOverlap);
            						}
            						else {
HXLINE( 523)							_hx_tmp5 = false;
            						}
HXDLIN( 523)						if (!(_hx_tmp5)) {
HXLINE( 524)							int dir2 = 256;
HXLINE( 523)							_hx_tmp4 = ((object1->allowCollisions & dir2) != dir2);
            						}
            						else {
HXLINE( 523)							_hx_tmp4 = true;
            						}
HXDLIN( 523)						if (!(_hx_tmp4)) {
HXLINE( 525)							int dir3 = 4096;
HXLINE( 523)							_hx_tmp3 = ((object2->allowCollisions & dir3) != dir3);
            						}
            						else {
HXLINE( 523)							_hx_tmp3 = true;
            						}
HXDLIN( 523)						if (_hx_tmp3) {
HXLINE( 527)							overlap = ( (Float)(0) );
            						}
            						else {
HXLINE( 531)							 ::flixel::FlxObject object14 = object1;
HXDLIN( 531)							object14->touching = (object14->touching | 256);
HXLINE( 532)							 ::flixel::FlxObject object22 = object2;
HXDLIN( 532)							object22->touching = (object22->touching | 4096);
            						}
            					}
            				}
            			}
HXLINE( 537)			if (!(rect1->_inPool)) {
HXLINE( 537)				rect1->_inPool = true;
HXDLIN( 537)				rect1->_weak = false;
HXDLIN( 537)				::flixel::math::FlxRect_obj::_pool->putUnsafe(rect1);
            			}
HXLINE( 538)			if (!(rect21->_inPool)) {
HXLINE( 538)				rect21->_inPool = true;
HXDLIN( 538)				rect21->_weak = false;
HXDLIN( 538)				::flixel::math::FlxRect_obj::_pool->putUnsafe(rect21);
            			}
            		}
HXLINE( 541)		return overlap;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(FlxObject_obj,computeOverlapY,return )


::hx::ObjectPtr< FlxObject_obj > FlxObject_obj::__new(::hx::Null< Float >  __o_x,::hx::Null< Float >  __o_y,::hx::Null< Float >  __o_width,::hx::Null< Float >  __o_height) {
	::hx::ObjectPtr< FlxObject_obj > __this = new FlxObject_obj();
	__this->__construct(__o_x,__o_y,__o_width,__o_height);
	return __this;
}

::hx::ObjectPtr< FlxObject_obj > FlxObject_obj::__alloc(::hx::Ctx *_hx_ctx,::hx::Null< Float >  __o_x,::hx::Null< Float >  __o_y,::hx::Null< Float >  __o_width,::hx::Null< Float >  __o_height) {
	FlxObject_obj *__this = (FlxObject_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(FlxObject_obj), true, "flixel.FlxObject"));
	*(void **)__this = FlxObject_obj::_hx_vtable;
	__this->__construct(__o_x,__o_y,__o_width,__o_height);
	return __this;
}

FlxObject_obj::FlxObject_obj()
{
}

void FlxObject_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(FlxObject);
	HX_MARK_MEMBER_NAME(x,"x");
	HX_MARK_MEMBER_NAME(y,"y");
	HX_MARK_MEMBER_NAME(width,"width");
	HX_MARK_MEMBER_NAME(height,"height");
	HX_MARK_MEMBER_NAME(pixelPerfectRender,"pixelPerfectRender");
	HX_MARK_MEMBER_NAME(pixelPerfectPosition,"pixelPerfectPosition");
	HX_MARK_MEMBER_NAME(angle,"angle");
	HX_MARK_MEMBER_NAME(moves,"moves");
	HX_MARK_MEMBER_NAME(immovable,"immovable");
	HX_MARK_MEMBER_NAME(scrollFactor,"scrollFactor");
	HX_MARK_MEMBER_NAME(velocity,"velocity");
	HX_MARK_MEMBER_NAME(acceleration,"acceleration");
	HX_MARK_MEMBER_NAME(drag,"drag");
	HX_MARK_MEMBER_NAME(maxVelocity,"maxVelocity");
	HX_MARK_MEMBER_NAME(last,"last");
	HX_MARK_MEMBER_NAME(mass,"mass");
	HX_MARK_MEMBER_NAME(elasticity,"elasticity");
	HX_MARK_MEMBER_NAME(angularVelocity,"angularVelocity");
	HX_MARK_MEMBER_NAME(angularAcceleration,"angularAcceleration");
	HX_MARK_MEMBER_NAME(angularDrag,"angularDrag");
	HX_MARK_MEMBER_NAME(maxAngular,"maxAngular");
	HX_MARK_MEMBER_NAME(health,"health");
	HX_MARK_MEMBER_NAME(touching,"touching");
	HX_MARK_MEMBER_NAME(wasTouching,"wasTouching");
	HX_MARK_MEMBER_NAME(allowCollisions,"allowCollisions");
	HX_MARK_MEMBER_NAME(collisionXDrag,"collisionXDrag");
	HX_MARK_MEMBER_NAME(collisionYDrag,"collisionYDrag");
	HX_MARK_MEMBER_NAME(debugBoundingBoxColor,"debugBoundingBoxColor");
	HX_MARK_MEMBER_NAME(debugBoundingBoxColorSolid,"debugBoundingBoxColorSolid");
	HX_MARK_MEMBER_NAME(debugBoundingBoxColorNotSolid,"debugBoundingBoxColorNotSolid");
	HX_MARK_MEMBER_NAME(debugBoundingBoxColorPartial,"debugBoundingBoxColorPartial");
	HX_MARK_MEMBER_NAME(ignoreDrawDebug,"ignoreDrawDebug");
	HX_MARK_MEMBER_NAME(path,"path");
	HX_MARK_MEMBER_NAME(_point,"_point");
	HX_MARK_MEMBER_NAME(_rect,"_rect");
	 ::flixel::FlxBasic_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void FlxObject_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(x,"x");
	HX_VISIT_MEMBER_NAME(y,"y");
	HX_VISIT_MEMBER_NAME(width,"width");
	HX_VISIT_MEMBER_NAME(height,"height");
	HX_VISIT_MEMBER_NAME(pixelPerfectRender,"pixelPerfectRender");
	HX_VISIT_MEMBER_NAME(pixelPerfectPosition,"pixelPerfectPosition");
	HX_VISIT_MEMBER_NAME(angle,"angle");
	HX_VISIT_MEMBER_NAME(moves,"moves");
	HX_VISIT_MEMBER_NAME(immovable,"immovable");
	HX_VISIT_MEMBER_NAME(scrollFactor,"scrollFactor");
	HX_VISIT_MEMBER_NAME(velocity,"velocity");
	HX_VISIT_MEMBER_NAME(acceleration,"acceleration");
	HX_VISIT_MEMBER_NAME(drag,"drag");
	HX_VISIT_MEMBER_NAME(maxVelocity,"maxVelocity");
	HX_VISIT_MEMBER_NAME(last,"last");
	HX_VISIT_MEMBER_NAME(mass,"mass");
	HX_VISIT_MEMBER_NAME(elasticity,"elasticity");
	HX_VISIT_MEMBER_NAME(angularVelocity,"angularVelocity");
	HX_VISIT_MEMBER_NAME(angularAcceleration,"angularAcceleration");
	HX_VISIT_MEMBER_NAME(angularDrag,"angularDrag");
	HX_VISIT_MEMBER_NAME(maxAngular,"maxAngular");
	HX_VISIT_MEMBER_NAME(health,"health");
	HX_VISIT_MEMBER_NAME(touching,"touching");
	HX_VISIT_MEMBER_NAME(wasTouching,"wasTouching");
	HX_VISIT_MEMBER_NAME(allowCollisions,"allowCollisions");
	HX_VISIT_MEMBER_NAME(collisionXDrag,"collisionXDrag");
	HX_VISIT_MEMBER_NAME(collisionYDrag,"collisionYDrag");
	HX_VISIT_MEMBER_NAME(debugBoundingBoxColor,"debugBoundingBoxColor");
	HX_VISIT_MEMBER_NAME(debugBoundingBoxColorSolid,"debugBoundingBoxColorSolid");
	HX_VISIT_MEMBER_NAME(debugBoundingBoxColorNotSolid,"debugBoundingBoxColorNotSolid");
	HX_VISIT_MEMBER_NAME(debugBoundingBoxColorPartial,"debugBoundingBoxColorPartial");
	HX_VISIT_MEMBER_NAME(ignoreDrawDebug,"ignoreDrawDebug");
	HX_VISIT_MEMBER_NAME(path,"path");
	HX_VISIT_MEMBER_NAME(_point,"_point");
	HX_VISIT_MEMBER_NAME(_rect,"_rect");
	 ::flixel::FlxBasic_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val FlxObject_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { return ::hx::Val( x ); }
		if (HX_FIELD_EQ(inName,"y") ) { return ::hx::Val( y ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"drag") ) { return ::hx::Val( drag ); }
		if (HX_FIELD_EQ(inName,"last") ) { return ::hx::Val( last ); }
		if (HX_FIELD_EQ(inName,"mass") ) { return ::hx::Val( mass ); }
		if (HX_FIELD_EQ(inName,"path") ) { return ::hx::Val( path ); }
		if (HX_FIELD_EQ(inName,"draw") ) { return ::hx::Val( draw_dyn() ); }
		if (HX_FIELD_EQ(inName,"hurt") ) { return ::hx::Val( hurt_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { return ::hx::Val( inCallProp == ::hx::paccAlways ? get_width() : width ); }
		if (HX_FIELD_EQ(inName,"angle") ) { return ::hx::Val( angle ); }
		if (HX_FIELD_EQ(inName,"moves") ) { return ::hx::Val( moves ); }
		if (HX_FIELD_EQ(inName,"solid") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_solid() ); }
		if (HX_FIELD_EQ(inName,"_rect") ) { return ::hx::Val( _rect ); }
		if (HX_FIELD_EQ(inName,"reset") ) { return ::hx::Val( reset_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_x") ) { return ::hx::Val( set_x_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_y") ) { return ::hx::Val( set_y_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { return ::hx::Val( inCallProp == ::hx::paccAlways ? get_height() : height ); }
		if (HX_FIELD_EQ(inName,"health") ) { return ::hx::Val( health ); }
		if (HX_FIELD_EQ(inName,"_point") ) { return ::hx::Val( _point ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"destroy") ) { return ::hx::Val( destroy_dyn() ); }
		if (HX_FIELD_EQ(inName,"setSize") ) { return ::hx::Val( setSize_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"velocity") ) { return ::hx::Val( velocity ); }
		if (HX_FIELD_EQ(inName,"touching") ) { return ::hx::Val( touching ); }
		if (HX_FIELD_EQ(inName,"initVars") ) { return ::hx::Val( initVars_dyn() ); }
		if (HX_FIELD_EQ(inName,"overlaps") ) { return ::hx::Val( overlaps_dyn() ); }
		if (HX_FIELD_EQ(inName,"toString") ) { return ::hx::Val( toString_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_path") ) { return ::hx::Val( set_path_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"immovable") ) { return ::hx::Val( immovable ); }
		if (HX_FIELD_EQ(inName,"getHitbox") ) { return ::hx::Val( getHitbox_dyn() ); }
		if (HX_FIELD_EQ(inName,"drawDebug") ) { return ::hx::Val( drawDebug_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_width") ) { return ::hx::Val( set_width_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_width") ) { return ::hx::Val( get_width_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_solid") ) { return ::hx::Val( get_solid_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_solid") ) { return ::hx::Val( set_solid_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_angle") ) { return ::hx::Val( set_angle_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_moves") ) { return ::hx::Val( set_moves_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"elasticity") ) { return ::hx::Val( elasticity ); }
		if (HX_FIELD_EQ(inName,"maxAngular") ) { return ::hx::Val( maxAngular ); }
		if (HX_FIELD_EQ(inName,"overlapsAt") ) { return ::hx::Val( overlapsAt_dyn() ); }
		if (HX_FIELD_EQ(inName,"isOnScreen") ) { return ::hx::Val( isOnScreen_dyn() ); }
		if (HX_FIELD_EQ(inName,"isTouching") ) { return ::hx::Val( isTouching_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_height") ) { return ::hx::Val( set_height_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_height") ) { return ::hx::Val( get_height_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"maxVelocity") ) { return ::hx::Val( maxVelocity ); }
		if (HX_FIELD_EQ(inName,"angularDrag") ) { return ::hx::Val( angularDrag ); }
		if (HX_FIELD_EQ(inName,"wasTouching") ) { return ::hx::Val( wasTouching ); }
		if (HX_FIELD_EQ(inName,"getPosition") ) { return ::hx::Val( getPosition_dyn() ); }
		if (HX_FIELD_EQ(inName,"getMidpoint") ) { return ::hx::Val( getMidpoint_dyn() ); }
		if (HX_FIELD_EQ(inName,"justTouched") ) { return ::hx::Val( justTouched_dyn() ); }
		if (HX_FIELD_EQ(inName,"setPosition") ) { return ::hx::Val( setPosition_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"scrollFactor") ) { return ::hx::Val( scrollFactor ); }
		if (HX_FIELD_EQ(inName,"acceleration") ) { return ::hx::Val( acceleration ); }
		if (HX_FIELD_EQ(inName,"updateMotion") ) { return ::hx::Val( updateMotion_dyn() ); }
		if (HX_FIELD_EQ(inName,"screenCenter") ) { return ::hx::Val( screenCenter_dyn() ); }
		if (HX_FIELD_EQ(inName,"endDrawDebug") ) { return ::hx::Val( endDrawDebug_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"overlapsPoint") ) { return ::hx::Val( overlapsPoint_dyn() ); }
		if (HX_FIELD_EQ(inName,"inWorldBounds") ) { return ::hx::Val( inWorldBounds_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_immovable") ) { return ::hx::Val( set_immovable_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"collisionXDrag") ) { return ::hx::Val( collisionXDrag ); }
		if (HX_FIELD_EQ(inName,"collisionYDrag") ) { return ::hx::Val( collisionYDrag ); }
		if (HX_FIELD_EQ(inName,"initMotionVars") ) { return ::hx::Val( initMotionVars_dyn() ); }
		if (HX_FIELD_EQ(inName,"beginDrawDebug") ) { return ::hx::Val( beginDrawDebug_dyn() ); }
		if (HX_FIELD_EQ(inName,"getBoundingBox") ) { return ::hx::Val( getBoundingBox_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"angularVelocity") ) { return ::hx::Val( angularVelocity ); }
		if (HX_FIELD_EQ(inName,"allowCollisions") ) { return ::hx::Val( allowCollisions ); }
		if (HX_FIELD_EQ(inName,"ignoreDrawDebug") ) { return ::hx::Val( ignoreDrawDebug ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"overlapsCallback") ) { return ::hx::Val( overlapsCallback_dyn() ); }
		if (HX_FIELD_EQ(inName,"getRotatedBounds") ) { return ::hx::Val( getRotatedBounds_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"getScreenPosition") ) { return ::hx::Val( getScreenPosition_dyn() ); }
		if (HX_FIELD_EQ(inName,"drawDebugOnCamera") ) { return ::hx::Val( drawDebugOnCamera_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"pixelPerfectRender") ) { return ::hx::Val( pixelPerfectRender ); }
		if (HX_FIELD_EQ(inName,"overlapsAtCallback") ) { return ::hx::Val( overlapsAtCallback_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"angularAcceleration") ) { return ::hx::Val( angularAcceleration ); }
		if (HX_FIELD_EQ(inName,"set_allowCollisions") ) { return ::hx::Val( set_allowCollisions_dyn() ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"pixelPerfectPosition") ) { return ::hx::Val( pixelPerfectPosition ); }
		if (HX_FIELD_EQ(inName,"isPixelPerfectRender") ) { return ::hx::Val( isPixelPerfectRender_dyn() ); }
		if (HX_FIELD_EQ(inName,"drawDebugBoundingBox") ) { return ::hx::Val( drawDebugBoundingBox_dyn() ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"debugBoundingBoxColor") ) { return ::hx::Val( debugBoundingBoxColor ); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"set_pixelPerfectRender") ) { return ::hx::Val( set_pixelPerfectRender_dyn() ); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"getDebugBoundingBoxColor") ) { return ::hx::Val( getDebugBoundingBoxColor_dyn() ); }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"drawDebugBoundingBoxColor") ) { return ::hx::Val( drawDebugBoundingBoxColor_dyn() ); }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"debugBoundingBoxColorSolid") ) { return ::hx::Val( debugBoundingBoxColorSolid ); }
		break;
	case 28:
		if (HX_FIELD_EQ(inName,"debugBoundingBoxColorPartial") ) { return ::hx::Val( debugBoundingBoxColorPartial ); }
		break;
	case 29:
		if (HX_FIELD_EQ(inName,"debugBoundingBoxColorNotSolid") ) { return ::hx::Val( debugBoundingBoxColorNotSolid ); }
		break;
	case 30:
		if (HX_FIELD_EQ(inName,"set_debugBoundingBoxColorSolid") ) { return ::hx::Val( set_debugBoundingBoxColorSolid_dyn() ); }
		break;
	case 32:
		if (HX_FIELD_EQ(inName,"set_debugBoundingBoxColorPartial") ) { return ::hx::Val( set_debugBoundingBoxColorPartial_dyn() ); }
		break;
	case 33:
		if (HX_FIELD_EQ(inName,"set_debugBoundingBoxColorNotSolid") ) { return ::hx::Val( set_debugBoundingBoxColorNotSolid_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool FlxObject_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"separate") ) { outValue = separate_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"separateX") ) { outValue = separateX_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"separateY") ) { outValue = separateY_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"defaultMoves") ) { outValue = ( defaultMoves ); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"SEPARATE_BIAS") ) { outValue = ( SEPARATE_BIAS ); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"separateXHelper") ) { outValue = separateXHelper_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"separateYHelper") ) { outValue = separateYHelper_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"legacySeparateX") ) { outValue = legacySeparateX_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"legacySeparateY") ) { outValue = legacySeparateY_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"computeOverlapX") ) { outValue = computeOverlapX_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"computeOverlapY") ) { outValue = computeOverlapY_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"allowCollisionDrag") ) { outValue = allowCollisionDrag_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"processCheckTilemap") ) { outValue = processCheckTilemap_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"updateTouchingFlags") ) { outValue = updateTouchingFlags_dyn(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"updateTouchingFlagsX") ) { outValue = updateTouchingFlagsX_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"updateTouchingFlagsY") ) { outValue = updateTouchingFlagsY_dyn(); return true; }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"updateTouchingFlagsXHelper") ) { outValue = updateTouchingFlagsXHelper_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"updateTouchingFlagsYHelper") ) { outValue = updateTouchingFlagsYHelper_dyn(); return true; }
		break;
	case 27:
		if (HX_FIELD_EQ(inName,"defaultPixelPerfectPosition") ) { outValue = ( defaultPixelPerfectPosition ); return true; }
	}
	return false;
}

::hx::Val FlxObject_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_x(inValue.Cast< Float >()) );x=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_y(inValue.Cast< Float >()) );y=inValue.Cast< Float >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"drag") ) { drag=inValue.Cast<  ::flixel::math::FlxBasePoint >(); return inValue; }
		if (HX_FIELD_EQ(inName,"last") ) { last=inValue.Cast<  ::flixel::math::FlxBasePoint >(); return inValue; }
		if (HX_FIELD_EQ(inName,"mass") ) { mass=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"path") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_path(inValue.Cast<  ::flixel::path::FlxPath >()) );path=inValue.Cast<  ::flixel::path::FlxPath >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"width") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_width(inValue.Cast< Float >()) );width=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"angle") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_angle(inValue.Cast< Float >()) );angle=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"moves") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_moves(inValue.Cast< bool >()) );moves=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"solid") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_solid(inValue.Cast< bool >()) ); }
		if (HX_FIELD_EQ(inName,"_rect") ) { _rect=inValue.Cast<  ::flixel::math::FlxRect >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"height") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_height(inValue.Cast< Float >()) );height=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"health") ) { health=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_point") ) { _point=inValue.Cast<  ::flixel::math::FlxBasePoint >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"velocity") ) { velocity=inValue.Cast<  ::flixel::math::FlxBasePoint >(); return inValue; }
		if (HX_FIELD_EQ(inName,"touching") ) { touching=inValue.Cast< int >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"immovable") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_immovable(inValue.Cast< bool >()) );immovable=inValue.Cast< bool >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"elasticity") ) { elasticity=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"maxAngular") ) { maxAngular=inValue.Cast< Float >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"maxVelocity") ) { maxVelocity=inValue.Cast<  ::flixel::math::FlxBasePoint >(); return inValue; }
		if (HX_FIELD_EQ(inName,"angularDrag") ) { angularDrag=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"wasTouching") ) { wasTouching=inValue.Cast< int >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"scrollFactor") ) { scrollFactor=inValue.Cast<  ::flixel::math::FlxBasePoint >(); return inValue; }
		if (HX_FIELD_EQ(inName,"acceleration") ) { acceleration=inValue.Cast<  ::flixel::math::FlxBasePoint >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"collisionXDrag") ) { collisionXDrag=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"collisionYDrag") ) { collisionYDrag=inValue.Cast< int >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"angularVelocity") ) { angularVelocity=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"allowCollisions") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_allowCollisions(inValue.Cast< int >()) );allowCollisions=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ignoreDrawDebug") ) { ignoreDrawDebug=inValue.Cast< bool >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"pixelPerfectRender") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_pixelPerfectRender(inValue.Cast<  ::Dynamic >()) );pixelPerfectRender=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"angularAcceleration") ) { angularAcceleration=inValue.Cast< Float >(); return inValue; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"pixelPerfectPosition") ) { pixelPerfectPosition=inValue.Cast< bool >(); return inValue; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"debugBoundingBoxColor") ) { debugBoundingBoxColor=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"debugBoundingBoxColorSolid") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_debugBoundingBoxColorSolid(inValue.Cast< int >()) );debugBoundingBoxColorSolid=inValue.Cast< int >(); return inValue; }
		break;
	case 28:
		if (HX_FIELD_EQ(inName,"debugBoundingBoxColorPartial") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_debugBoundingBoxColorPartial(inValue.Cast< int >()) );debugBoundingBoxColorPartial=inValue.Cast< int >(); return inValue; }
		break;
	case 29:
		if (HX_FIELD_EQ(inName,"debugBoundingBoxColorNotSolid") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_debugBoundingBoxColorNotSolid(inValue.Cast< int >()) );debugBoundingBoxColorNotSolid=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool FlxObject_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 12:
		if (HX_FIELD_EQ(inName,"defaultMoves") ) { defaultMoves=ioValue.Cast< bool >(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"SEPARATE_BIAS") ) { SEPARATE_BIAS=ioValue.Cast< Float >(); return true; }
		break;
	case 27:
		if (HX_FIELD_EQ(inName,"defaultPixelPerfectPosition") ) { defaultPixelPerfectPosition=ioValue.Cast< bool >(); return true; }
	}
	return false;
}

void FlxObject_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("x",78,00,00,00));
	outFields->push(HX_("y",79,00,00,00));
	outFields->push(HX_("width",06,b6,62,ca));
	outFields->push(HX_("height",e7,07,4c,02));
	outFields->push(HX_("pixelPerfectRender",dd,59,4f,2f));
	outFields->push(HX_("pixelPerfectPosition",f0,7e,5e,3d));
	outFields->push(HX_("angle",d3,43,e2,22));
	outFields->push(HX_("moves",42,cc,65,0c));
	outFields->push(HX_("immovable",0a,27,70,27));
	outFields->push(HX_("solid",2b,b4,c5,80));
	outFields->push(HX_("scrollFactor",bc,ec,cf,3b));
	outFields->push(HX_("velocity",1d,02,fe,1e));
	outFields->push(HX_("acceleration",40,00,61,9a));
	outFields->push(HX_("drag",f4,2b,70,42));
	outFields->push(HX_("maxVelocity",e1,0c,c4,94));
	outFields->push(HX_("last",56,0a,ad,47));
	outFields->push(HX_("mass",f4,40,56,48));
	outFields->push(HX_("elasticity",79,23,b4,4d));
	outFields->push(HX_("angularVelocity",1f,1f,fe,58));
	outFields->push(HX_("angularAcceleration",42,c6,00,9a));
	outFields->push(HX_("angularDrag",f6,1f,19,9c));
	outFields->push(HX_("maxAngular",9e,28,f6,c2));
	outFields->push(HX_("health",9c,28,06,fd));
	outFields->push(HX_("touching",83,16,25,00));
	outFields->push(HX_("wasTouching",cc,44,e4,5f));
	outFields->push(HX_("allowCollisions",aa,c9,d9,59));
	outFields->push(HX_("collisionXDrag",ba,de,5f,94));
	outFields->push(HX_("collisionYDrag",3b,73,c6,27));
	outFields->push(HX_("debugBoundingBoxColor",4f,f7,30,61));
	outFields->push(HX_("debugBoundingBoxColorSolid",5c,4e,14,21));
	outFields->push(HX_("debugBoundingBoxColorNotSolid",87,a0,85,00));
	outFields->push(HX_("debugBoundingBoxColorPartial",f2,1f,7b,2f));
	outFields->push(HX_("ignoreDrawDebug",3d,fc,11,6b));
	outFields->push(HX_("path",a5,e5,51,4a));
	outFields->push(HX_("_point",91,fb,76,c2));
	outFields->push(HX_("_rect",03,69,b8,fe));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo FlxObject_obj_sMemberStorageInfo[] = {
	{::hx::fsFloat,(int)offsetof(FlxObject_obj,x),HX_("x",78,00,00,00)},
	{::hx::fsFloat,(int)offsetof(FlxObject_obj,y),HX_("y",79,00,00,00)},
	{::hx::fsFloat,(int)offsetof(FlxObject_obj,width),HX_("width",06,b6,62,ca)},
	{::hx::fsFloat,(int)offsetof(FlxObject_obj,height),HX_("height",e7,07,4c,02)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(FlxObject_obj,pixelPerfectRender),HX_("pixelPerfectRender",dd,59,4f,2f)},
	{::hx::fsBool,(int)offsetof(FlxObject_obj,pixelPerfectPosition),HX_("pixelPerfectPosition",f0,7e,5e,3d)},
	{::hx::fsFloat,(int)offsetof(FlxObject_obj,angle),HX_("angle",d3,43,e2,22)},
	{::hx::fsBool,(int)offsetof(FlxObject_obj,moves),HX_("moves",42,cc,65,0c)},
	{::hx::fsBool,(int)offsetof(FlxObject_obj,immovable),HX_("immovable",0a,27,70,27)},
	{::hx::fsObject /*  ::flixel::math::FlxBasePoint */ ,(int)offsetof(FlxObject_obj,scrollFactor),HX_("scrollFactor",bc,ec,cf,3b)},
	{::hx::fsObject /*  ::flixel::math::FlxBasePoint */ ,(int)offsetof(FlxObject_obj,velocity),HX_("velocity",1d,02,fe,1e)},
	{::hx::fsObject /*  ::flixel::math::FlxBasePoint */ ,(int)offsetof(FlxObject_obj,acceleration),HX_("acceleration",40,00,61,9a)},
	{::hx::fsObject /*  ::flixel::math::FlxBasePoint */ ,(int)offsetof(FlxObject_obj,drag),HX_("drag",f4,2b,70,42)},
	{::hx::fsObject /*  ::flixel::math::FlxBasePoint */ ,(int)offsetof(FlxObject_obj,maxVelocity),HX_("maxVelocity",e1,0c,c4,94)},
	{::hx::fsObject /*  ::flixel::math::FlxBasePoint */ ,(int)offsetof(FlxObject_obj,last),HX_("last",56,0a,ad,47)},
	{::hx::fsFloat,(int)offsetof(FlxObject_obj,mass),HX_("mass",f4,40,56,48)},
	{::hx::fsFloat,(int)offsetof(FlxObject_obj,elasticity),HX_("elasticity",79,23,b4,4d)},
	{::hx::fsFloat,(int)offsetof(FlxObject_obj,angularVelocity),HX_("angularVelocity",1f,1f,fe,58)},
	{::hx::fsFloat,(int)offsetof(FlxObject_obj,angularAcceleration),HX_("angularAcceleration",42,c6,00,9a)},
	{::hx::fsFloat,(int)offsetof(FlxObject_obj,angularDrag),HX_("angularDrag",f6,1f,19,9c)},
	{::hx::fsFloat,(int)offsetof(FlxObject_obj,maxAngular),HX_("maxAngular",9e,28,f6,c2)},
	{::hx::fsFloat,(int)offsetof(FlxObject_obj,health),HX_("health",9c,28,06,fd)},
	{::hx::fsInt,(int)offsetof(FlxObject_obj,touching),HX_("touching",83,16,25,00)},
	{::hx::fsInt,(int)offsetof(FlxObject_obj,wasTouching),HX_("wasTouching",cc,44,e4,5f)},
	{::hx::fsInt,(int)offsetof(FlxObject_obj,allowCollisions),HX_("allowCollisions",aa,c9,d9,59)},
	{::hx::fsInt,(int)offsetof(FlxObject_obj,collisionXDrag),HX_("collisionXDrag",ba,de,5f,94)},
	{::hx::fsInt,(int)offsetof(FlxObject_obj,collisionYDrag),HX_("collisionYDrag",3b,73,c6,27)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(FlxObject_obj,debugBoundingBoxColor),HX_("debugBoundingBoxColor",4f,f7,30,61)},
	{::hx::fsInt,(int)offsetof(FlxObject_obj,debugBoundingBoxColorSolid),HX_("debugBoundingBoxColorSolid",5c,4e,14,21)},
	{::hx::fsInt,(int)offsetof(FlxObject_obj,debugBoundingBoxColorNotSolid),HX_("debugBoundingBoxColorNotSolid",87,a0,85,00)},
	{::hx::fsInt,(int)offsetof(FlxObject_obj,debugBoundingBoxColorPartial),HX_("debugBoundingBoxColorPartial",f2,1f,7b,2f)},
	{::hx::fsBool,(int)offsetof(FlxObject_obj,ignoreDrawDebug),HX_("ignoreDrawDebug",3d,fc,11,6b)},
	{::hx::fsObject /*  ::flixel::path::FlxPath */ ,(int)offsetof(FlxObject_obj,path),HX_("path",a5,e5,51,4a)},
	{::hx::fsObject /*  ::flixel::math::FlxBasePoint */ ,(int)offsetof(FlxObject_obj,_point),HX_("_point",91,fb,76,c2)},
	{::hx::fsObject /*  ::flixel::math::FlxRect */ ,(int)offsetof(FlxObject_obj,_rect),HX_("_rect",03,69,b8,fe)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo FlxObject_obj_sStaticStorageInfo[] = {
	{::hx::fsBool,(void *) &FlxObject_obj::defaultPixelPerfectPosition,HX_("defaultPixelPerfectPosition",51,0a,c2,b0)},
	{::hx::fsFloat,(void *) &FlxObject_obj::SEPARATE_BIAS,HX_("SEPARATE_BIAS",15,78,21,a0)},
	{::hx::fsBool,(void *) &FlxObject_obj::defaultMoves,HX_("defaultMoves",c1,07,c1,c1)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String FlxObject_obj_sMemberFields[] = {
	HX_("x",78,00,00,00),
	HX_("y",79,00,00,00),
	HX_("width",06,b6,62,ca),
	HX_("height",e7,07,4c,02),
	HX_("pixelPerfectRender",dd,59,4f,2f),
	HX_("pixelPerfectPosition",f0,7e,5e,3d),
	HX_("angle",d3,43,e2,22),
	HX_("moves",42,cc,65,0c),
	HX_("immovable",0a,27,70,27),
	HX_("scrollFactor",bc,ec,cf,3b),
	HX_("velocity",1d,02,fe,1e),
	HX_("acceleration",40,00,61,9a),
	HX_("drag",f4,2b,70,42),
	HX_("maxVelocity",e1,0c,c4,94),
	HX_("last",56,0a,ad,47),
	HX_("mass",f4,40,56,48),
	HX_("elasticity",79,23,b4,4d),
	HX_("angularVelocity",1f,1f,fe,58),
	HX_("angularAcceleration",42,c6,00,9a),
	HX_("angularDrag",f6,1f,19,9c),
	HX_("maxAngular",9e,28,f6,c2),
	HX_("health",9c,28,06,fd),
	HX_("touching",83,16,25,00),
	HX_("wasTouching",cc,44,e4,5f),
	HX_("allowCollisions",aa,c9,d9,59),
	HX_("collisionXDrag",ba,de,5f,94),
	HX_("collisionYDrag",3b,73,c6,27),
	HX_("debugBoundingBoxColor",4f,f7,30,61),
	HX_("debugBoundingBoxColorSolid",5c,4e,14,21),
	HX_("debugBoundingBoxColorNotSolid",87,a0,85,00),
	HX_("debugBoundingBoxColorPartial",f2,1f,7b,2f),
	HX_("ignoreDrawDebug",3d,fc,11,6b),
	HX_("path",a5,e5,51,4a),
	HX_("_point",91,fb,76,c2),
	HX_("_rect",03,69,b8,fe),
	HX_("initVars",dc,5a,00,53),
	HX_("initMotionVars",32,e4,28,65),
	HX_("destroy",fa,2c,86,24),
	HX_("update",09,86,05,87),
	HX_("updateMotion",1f,2d,21,cb),
	HX_("draw",04,2c,70,42),
	HX_("overlaps",0c,d3,2a,45),
	HX_("overlapsCallback",f1,14,bf,b4),
	HX_("overlapsAt",1f,e7,ce,03),
	HX_("overlapsAtCallback",04,f4,81,3b),
	HX_("overlapsPoint",a4,c5,bd,35),
	HX_("inWorldBounds",82,46,f2,f1),
	HX_("getScreenPosition",6b,93,88,24),
	HX_("getPosition",5f,63,ee,f0),
	HX_("getMidpoint",7e,d8,fb,50),
	HX_("getHitbox",ce,76,7e,d3),
	HX_("reset",cf,49,c8,e6),
	HX_("isOnScreen",f5,43,b9,a1),
	HX_("isPixelPerfectRender",67,1c,f9,26),
	HX_("isTouching",8d,28,d4,7a),
	HX_("justTouched",12,59,b8,91),
	HX_("hurt",0f,5c,17,45),
	HX_("screenCenter",61,2e,f9,e2),
	HX_("setPosition",6b,6a,5b,fb),
	HX_("setSize",83,e1,d7,11),
	HX_("drawDebug",af,87,2a,9f),
	HX_("drawDebugOnCamera",f3,47,7b,cb),
	HX_("drawDebugBoundingBox",98,f5,9a,0b),
	HX_("getDebugBoundingBoxColor",d9,3a,c5,ff),
	HX_("drawDebugBoundingBoxColor",ab,a4,55,b9),
	HX_("beginDrawDebug",46,70,87,3b),
	HX_("endDrawDebug",54,90,2c,ae),
	HX_("getBoundingBox",11,e8,45,0d),
	HX_("getRotatedBounds",88,12,38,3c),
	HX_("toString",ac,d0,6e,38),
	HX_("set_x",5b,9b,2f,7a),
	HX_("set_y",5c,9b,2f,7a),
	HX_("set_width",69,fe,5c,f1),
	HX_("set_height",24,16,51,f6),
	HX_("get_width",5d,12,0c,0e),
	HX_("get_height",b0,77,d3,f2),
	HX_("get_solid",82,10,6f,c4),
	HX_("set_solid",8e,fc,bf,a7),
	HX_("set_angle",36,8c,dc,49),
	HX_("set_moves",a5,14,60,33),
	HX_("set_immovable",ed,dc,d9,2d),
	HX_("set_pixelPerfectRender",9a,4f,8f,bc),
	HX_("set_allowCollisions",cd,8b,81,21),
	HX_("set_debugBoundingBoxColorSolid",19,c9,0b,4b),
	HX_("set_debugBoundingBoxColorNotSolid",ea,b9,e3,4b),
	HX_("set_debugBoundingBoxColorPartial",ef,83,54,62),
	HX_("set_path",a2,fa,69,78),
	::String(null()) };

static void FlxObject_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxObject_obj::defaultPixelPerfectPosition,"defaultPixelPerfectPosition");
	HX_MARK_MEMBER_NAME(FlxObject_obj::SEPARATE_BIAS,"SEPARATE_BIAS");
	HX_MARK_MEMBER_NAME(FlxObject_obj::defaultMoves,"defaultMoves");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxObject_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxObject_obj::defaultPixelPerfectPosition,"defaultPixelPerfectPosition");
	HX_VISIT_MEMBER_NAME(FlxObject_obj::SEPARATE_BIAS,"SEPARATE_BIAS");
	HX_VISIT_MEMBER_NAME(FlxObject_obj::defaultMoves,"defaultMoves");
};

#endif

::hx::Class FlxObject_obj::__mClass;

static ::String FlxObject_obj_sStaticFields[] = {
	HX_("defaultPixelPerfectPosition",51,0a,c2,b0),
	HX_("SEPARATE_BIAS",15,78,21,a0),
	HX_("defaultMoves",c1,07,c1,c1),
	HX_("allowCollisionDrag",3d,eb,4d,c1),
	HX_("processCheckTilemap",55,01,54,c1),
	HX_("separate",63,1f,1c,07),
	HX_("separateX",95,57,7f,31),
	HX_("separateY",96,57,7f,31),
	HX_("separateXHelper",e3,a6,fb,12),
	HX_("separateYHelper",a4,1d,91,3c),
	HX_("legacySeparateX",0c,ac,0c,2f),
	HX_("legacySeparateY",0d,ac,0c,2f),
	HX_("updateTouchingFlags",fb,01,ac,bd),
	HX_("updateTouchingFlagsX",fd,b9,d5,38),
	HX_("updateTouchingFlagsXHelper",4b,c7,ff,5a),
	HX_("updateTouchingFlagsY",fe,b9,d5,38),
	HX_("updateTouchingFlagsYHelper",0c,3e,95,84),
	HX_("computeOverlapX",88,a5,ab,dc),
	HX_("computeOverlapY",89,a5,ab,dc),
	::String(null())
};

void FlxObject_obj::__register()
{
	FlxObject_obj _hx_dummy;
	FlxObject_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("flixel.FlxObject",1f,50,95,35);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &FlxObject_obj::__GetStatic;
	__mClass->mSetStaticField = &FlxObject_obj::__SetStatic;
	__mClass->mMarkFunc = FlxObject_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(FlxObject_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(FlxObject_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< FlxObject_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxObject_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxObject_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxObject_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void FlxObject_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_80_boot)
HXDLIN(  80)		defaultPixelPerfectPosition = false;
            	}
{
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_87_boot)
HXDLIN(  87)		SEPARATE_BIAS = ((Float)4);
            	}
{
            	HX_STACKFRAME(&_hx_pos_c625bfaa5b4263df_94_boot)
HXDLIN(  94)		defaultMoves = true;
            	}
}

} // end namespace flixel
