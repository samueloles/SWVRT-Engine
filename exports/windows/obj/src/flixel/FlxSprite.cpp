// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimation
#include <flixel/animation/FlxAnimation.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimationController
#include <flixel/animation/FlxAnimationController.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxBaseAnimation
#include <flixel/animation/FlxBaseAnimation.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFrame
#include <flixel/graphics/frames/FlxFrame.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFramesCollection
#include <flixel/graphics/frames/FlxFramesCollection.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxImageFrame
#include <flixel/graphics/frames/FlxImageFrame.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxTileFrames
#include <flixel/graphics/frames/FlxTileFrames.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxGraphicsShader
#include <flixel/graphics/tile/FlxGraphicsShader.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMatrix
#include <flixel/math/FlxMatrix.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRect
#include <flixel/math/FlxRect.h>
#endif
#ifndef INCLUDED_flixel_math__FlxPoint_FlxPoint_Impl_
#include <flixel/math/_FlxPoint/FlxPoint_Impl_.h>
#endif
#ifndef INCLUDED_flixel_system_debug_log_LogStyle
#include <flixel/system/debug/log/LogStyle.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_BitmapFrontEnd
#include <flixel/system/frontEnds/BitmapFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_DebuggerFrontEnd
#include <flixel/system/frontEnds/DebuggerFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_LogFrontEnd
#include <flixel/system/frontEnds/LogFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_util_FlxBitmapDataUtil
#include <flixel/util/FlxBitmapDataUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxColorTransformUtil
#include <flixel/util/FlxColorTransformUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxDestroyUtil
#include <flixel/util/FlxDestroyUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool
#include <flixel/util/FlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_FlxStringUtil
#include <flixel/util/FlxStringUtil.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_flixel_util_LabelValuePair
#include <flixel/util/LabelValuePair.h>
#endif
#ifndef INCLUDED_flixel_util__FlxColor_FlxColor_Impl_
#include <flixel/util/_FlxColor/FlxColor_Impl_.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_GraphicsShader
#include <openfl/display/GraphicsShader.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_cfd221447aa7194b_129_new,"flixel.FlxSprite","new",0x4dfa64d7,"flixel.FlxSprite.new","flixel/FlxSprite.hx",129,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_390_initVars,"flixel.FlxSprite","initVars",0x31793705,"flixel.FlxSprite.initVars","flixel/FlxSprite.hx",390,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_418_destroy,"flixel.FlxSprite","destroy",0x0fb5c8f1,"flixel.FlxSprite.destroy","flixel/FlxSprite.hx",418,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_449_clone,"flixel.FlxSprite","clone",0x3c30f394,"flixel.FlxSprite.clone","flixel/FlxSprite.hx",449,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_460_loadGraphicFromSprite,"flixel.FlxSprite","loadGraphicFromSprite",0xd0637b08,"flixel.FlxSprite.loadGraphicFromSprite","flixel/FlxSprite.hx",460,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_499_loadGraphic,"flixel.FlxSprite","loadGraphic",0x47377c99,"flixel.FlxSprite.loadGraphic","flixel/FlxSprite.hx",499,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_546_loadRotatedGraphic,"flixel.FlxSprite","loadRotatedGraphic",0xceb71e2e,"flixel.FlxSprite.loadRotatedGraphic","flixel/FlxSprite.hx",546,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_611_loadRotatedFrame,"flixel.FlxSprite","loadRotatedFrame",0xe0d52e33,"flixel.FlxSprite.loadRotatedFrame","flixel/FlxSprite.hx",611,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_652_makeGraphic,"flixel.FlxSprite","makeGraphic",0xbaa3e5d1,"flixel.FlxSprite.makeGraphic","flixel/FlxSprite.hx",652,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_666_graphicLoaded,"flixel.FlxSprite","graphicLoaded",0xacabf404,"flixel.FlxSprite.graphicLoaded","flixel/FlxSprite.hx",666,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_672_resetSize,"flixel.FlxSprite","resetSize",0x5d8771e7,"flixel.FlxSprite.resetSize","flixel/FlxSprite.hx",672,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_683_resetFrameSize,"flixel.FlxSprite","resetFrameSize",0xb7baa4a8,"flixel.FlxSprite.resetFrameSize","flixel/FlxSprite.hx",683,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_697_resetSizeFromFrame,"flixel.FlxSprite","resetSizeFromFrame",0xf893db7c,"flixel.FlxSprite.resetSizeFromFrame","flixel/FlxSprite.hx",697,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_710_resetFrame,"flixel.FlxSprite","resetFrame",0x02a6a847,"flixel.FlxSprite.resetFrame","flixel/FlxSprite.hx",710,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_721_setGraphicSize,"flixel.FlxSprite","setGraphicSize",0x516eb7f0,"flixel.FlxSprite.setGraphicSize","flixel/FlxSprite.hx",721,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_740_updateHitbox,"flixel.FlxSprite","updateHitbox",0x9470392a,"flixel.FlxSprite.updateHitbox","flixel/FlxSprite.hx",740,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_752_resetHelpers,"flixel.FlxSprite","resetHelpers",0x6fc22ddf,"flixel.FlxSprite.resetHelpers","flixel/FlxSprite.hx",752,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_774_update,"flixel.FlxSprite","update",0xe75bd5f2,"flixel.FlxSprite.update","flixel/FlxSprite.hx",774,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_784_updateAnimation,"flixel.FlxSprite","updateAnimation",0x7e6eaab2,"flixel.FlxSprite.updateAnimation","flixel/FlxSprite.hx",784,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_790_checkEmptyFrame,"flixel.FlxSprite","checkEmptyFrame",0xe3dea03f,"flixel.FlxSprite.checkEmptyFrame","flixel/FlxSprite.hx",790,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_808_draw,"flixel.FlxSprite","draw",0xe68b7fad,"flixel.FlxSprite.draw","flixel/FlxSprite.hx",808,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_844_checkClipRect,"flixel.FlxSprite","checkClipRect",0xd7505c33,"flixel.FlxSprite.checkClipRect","flixel/FlxSprite.hx",844,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_861_drawSimple,"flixel.FlxSprite","drawSimple",0x0dc977bf,"flixel.FlxSprite.drawSimple","flixel/FlxSprite.hx",861,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_873_drawComplex,"flixel.FlxSprite","drawComplex",0xcf4c0e03,"flixel.FlxSprite.drawComplex","flixel/FlxSprite.hx",873,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_877_drawFrameComplex,"flixel.FlxSprite","drawFrameComplex",0x987140d0,"flixel.FlxSprite.drawFrameComplex","flixel/FlxSprite.hx",877,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_913_stamp,"flixel.FlxSprite","stamp",0x77d9503a,"flixel.FlxSprite.stamp","flixel/FlxSprite.hx",913,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_960_drawFrame,"flixel.FlxSprite","drawFrame",0x99d67540,"flixel.FlxSprite.drawFrame","flixel/FlxSprite.hx",960,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_981_centerOffsets,"flixel.FlxSprite","centerOffsets",0x583e0f62,"flixel.FlxSprite.centerOffsets","flixel/FlxSprite.hx",981,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_997_centerOrigin,"flixel.FlxSprite","centerOrigin",0x4cbae644,"flixel.FlxSprite.centerOrigin","flixel/FlxSprite.hx",997,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1010_replaceColor,"flixel.FlxSprite","replaceColor",0x7b700138,"flixel.FlxSprite.replaceColor","flixel/FlxSprite.hx",1010,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1033_setColorTransform,"flixel.FlxSprite","setColorTransform",0xa09a3582,"flixel.FlxSprite.setColorTransform","flixel/FlxSprite.hx",1033,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1047_updateColorTransform,"flixel.FlxSprite","updateColorTransform",0x79f9051b,"flixel.FlxSprite.updateColorTransform","flixel/FlxSprite.hx",1047,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1061_hasColorTransform,"flixel.FlxSprite","hasColorTransform",0x4e63eb3a,"flixel.FlxSprite.hasColorTransform","flixel/FlxSprite.hx",1061,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1069_hasColorTransformRaw,"flixel.FlxSprite","hasColorTransformRaw",0x0d35e2ce,"flixel.FlxSprite.hasColorTransformRaw","flixel/FlxSprite.hx",1069,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1083_pixelsOverlapPoint,"flixel.FlxSprite","pixelsOverlapPoint",0x4c878b7f,"flixel.FlxSprite.pixelsOverlapPoint","flixel/FlxSprite.hx",1083,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1103_getPixelAt,"flixel.FlxSprite","getPixelAt",0xeaefab8c,"flixel.FlxSprite.getPixelAt","flixel/FlxSprite.hx",1103,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1126_getPixelAtScreen,"flixel.FlxSprite","getPixelAtScreen",0x58308c18,"flixel.FlxSprite.getPixelAtScreen","flixel/FlxSprite.hx",1126,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1149_transformWorldToPixels,"flixel.FlxSprite","transformWorldToPixels",0x1a2b2c57,"flixel.FlxSprite.transformWorldToPixels","flixel/FlxSprite.hx",1149,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1167_transformWorldToPixelsSimple,"flixel.FlxSprite","transformWorldToPixelsSimple",0x4bb2ffe9,"flixel.FlxSprite.transformWorldToPixelsSimple","flixel/FlxSprite.hx",1167,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1193_transformScreenToPixels,"flixel.FlxSprite","transformScreenToPixels",0x8dfcfb17,"flixel.FlxSprite.transformScreenToPixels","flixel/FlxSprite.hx",1193,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1216_calcFrame,"flixel.FlxSprite","calcFrame",0xc4d45b0f,"flixel.FlxSprite.calcFrame","flixel/FlxSprite.hx",1216,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1229_updateFramePixels,"flixel.FlxSprite","updateFramePixels",0x2cd43e68,"flixel.FlxSprite.updateFramePixels","flixel/FlxSprite.hx",1229,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1276_getGraphicMidpoint,"flixel.FlxSprite","getGraphicMidpoint",0xc420be03,"flixel.FlxSprite.getGraphicMidpoint","flixel/FlxSprite.hx",1276,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1292_getGraphicBounds,"flixel.FlxSprite","getGraphicBounds",0xe34e19f0,"flixel.FlxSprite.getGraphicBounds","flixel/FlxSprite.hx",1292,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1319_isOnScreen,"flixel.FlxSprite","isOnScreen",0xb5403c5e,"flixel.FlxSprite.isOnScreen","flixel/FlxSprite.hx",1319,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1331_isSimpleRender,"flixel.FlxSprite","isSimpleRender",0x6aa0d51b,"flixel.FlxSprite.isSimpleRender","flixel/FlxSprite.hx",1331,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1347_isSimpleRenderBlit,"flixel.FlxSprite","isSimpleRenderBlit",0x4bf362f0,"flixel.FlxSprite.isSimpleRenderBlit","flixel/FlxSprite.hx",1347,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1363_getRotatedBounds,"flixel.FlxSprite","getRotatedBounds",0x9196bfb1,"flixel.FlxSprite.getRotatedBounds","flixel/FlxSprite.hx",1363,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1380_getScreenBounds,"flixel.FlxSprite","getScreenBounds",0x49d4cfae,"flixel.FlxSprite.getScreenBounds","flixel/FlxSprite.hx",1380,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1411_setFacingFlip,"flixel.FlxSprite","setFacingFlip",0x6816c060,"flixel.FlxSprite.setFacingFlip","flixel/FlxSprite.hx",1411,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1423_setFrames,"flixel.FlxSprite","setFrames",0xd774ec9f,"flixel.FlxSprite.setFrames","flixel/FlxSprite.hx",1423,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1460_get_pixels,"flixel.FlxSprite","get_pixels",0x90b8575f,"flixel.FlxSprite.get_pixels","flixel/FlxSprite.hx",1460,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1465_set_pixels,"flixel.FlxSprite","set_pixels",0x9435f5d3,"flixel.FlxSprite.set_pixels","flixel/FlxSprite.hx",1465,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1484_set_frame,"flixel.FlxSprite","set_frame",0xf8c58847,"flixel.FlxSprite.set_frame","flixel/FlxSprite.hx",1484,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1515_set_facing,"flixel.FlxSprite","set_facing",0xeb9145c0,"flixel.FlxSprite.set_facing","flixel/FlxSprite.hx",1515,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1528_set_alpha,"flixel.FlxSprite","set_alpha",0x13d8b778,"flixel.FlxSprite.set_alpha","flixel/FlxSprite.hx",1528,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1540_set_color,"flixel.FlxSprite","set_color",0x3c9e817d,"flixel.FlxSprite.set_color","flixel/FlxSprite.hx",1540,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1551_set_angle,"flixel.FlxSprite","set_angle",0x152453ed,"flixel.FlxSprite.set_angle","flixel/FlxSprite.hx",1551,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1565_updateTrig,"flixel.FlxSprite","updateTrig",0x193f7fee,"flixel.FlxSprite.updateTrig","flixel/FlxSprite.hx",1565,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1577_set_blend,"flixel.FlxSprite","set_blend",0xa736f86b,"flixel.FlxSprite.set_blend","flixel/FlxSprite.hx",1577,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1586_set_graphic,"flixel.FlxSprite","set_graphic",0x07012542,"flixel.FlxSprite.set_graphic","flixel/FlxSprite.hx",1586,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1605_set_clipRect,"flixel.FlxSprite","set_clipRect",0x60020c3a,"flixel.FlxSprite.set_clipRect","flixel/FlxSprite.hx",1605,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1623_set_frames,"flixel.FlxSprite","set_frames",0xb411b64c,"flixel.FlxSprite.set_frames","flixel/FlxSprite.hx",1623,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1649_get_numFrames,"flixel.FlxSprite","get_numFrames",0xb5763d9a,"flixel.FlxSprite.get_numFrames","flixel/FlxSprite.hx",1649,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1658_set_flipX,"flixel.FlxSprite","set_flipX",0xf4d45525,"flixel.FlxSprite.set_flipX","flixel/FlxSprite.hx",1658,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1669_set_flipY,"flixel.FlxSprite","set_flipY",0xf4d45526,"flixel.FlxSprite.set_flipY","flixel/FlxSprite.hx",1669,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1681_set_antialiasing,"flixel.FlxSprite","set_antialiasing",0xf8f29e1a,"flixel.FlxSprite.set_antialiasing","flixel/FlxSprite.hx",1681,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1687_set_useFramePixels,"flixel.FlxSprite","set_useFramePixels",0x72e62ad9,"flixel.FlxSprite.set_useFramePixels","flixel/FlxSprite.hx",1687,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1711_checkFlipX,"flixel.FlxSprite","checkFlipX",0x26093f8c,"flixel.FlxSprite.checkFlipX","flixel/FlxSprite.hx",1711,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_1722_checkFlipY,"flixel.FlxSprite","checkFlipY",0x26093f8d,"flixel.FlxSprite.checkFlipY","flixel/FlxSprite.hx",1722,0x0384bffa)
HX_LOCAL_STACK_FRAME(_hx_pos_cfd221447aa7194b_136_boot,"flixel.FlxSprite","boot",0xe536d7db,"flixel.FlxSprite.boot","flixel/FlxSprite.hx",136,0x0384bffa)
namespace flixel{

void FlxSprite_obj::__construct( ::Dynamic __o_X, ::Dynamic __o_Y, ::Dynamic SimpleGraphic){
            		 ::Dynamic X = __o_X;
            		if (::hx::IsNull(__o_X)) X = 0;
            		 ::Dynamic Y = __o_Y;
            		if (::hx::IsNull(__o_Y)) Y = 0;
            	HX_GC_STACKFRAME(&_hx_pos_cfd221447aa7194b_129_new)
HXLINE( 368)		this->_facingFlip =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE( 362)		this->_angleChanged = true;
HXLINE( 360)		this->_cosAngle = ((Float)1);
HXLINE( 357)		this->_sinAngle = ((Float)0);
HXLINE( 308)		this->_facingVerticalMult = 1;
HXLINE( 306)		this->_facingHorizontalMult = 1;
HXLINE( 285)		Float X1 = ::Math_obj::NaN;
HXDLIN( 285)		 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get().StaticCast<  ::flixel::math::FlxRect >();
HXDLIN( 285)		_this->x = X1;
HXDLIN( 285)		_this->y = ( (Float)(0) );
HXDLIN( 285)		_this->width = ( (Float)(0) );
HXDLIN( 285)		_this->height = ( (Float)(0) );
HXDLIN( 285)		 ::flixel::math::FlxRect rect = _this;
HXDLIN( 285)		rect->_inPool = false;
HXDLIN( 285)		this->_lastClipRect = rect;
HXLINE( 278)		this->useColorTransform = false;
HXLINE( 272)		this->colorTransform =  ::openfl::geom::ColorTransform_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null(),null(),null());
HXLINE( 267)		this->color = -1;
HXLINE( 234)		this->flipY = false;
HXLINE( 229)		this->flipX = false;
HXLINE( 224)		this->facing = 16;
HXLINE( 217)		this->alpha = ((Float)1.0);
HXLINE( 208)		this->bakedRotationAngle = ((Float)0);
HXLINE( 188)		this->frameHeight = 0;
HXLINE( 183)		this->frameWidth = 0;
HXLINE( 167)		this->dirty = true;
HXLINE( 161)		this->antialiasing = ::flixel::FlxSprite_obj::defaultAntialiasing;
HXLINE( 156)		this->useFramePixels = true;
HXLINE( 381)		super::__construct(X,Y,null(),null());
HXLINE( 383)		this->set_useFramePixels(::flixel::FlxG_obj::renderBlit);
HXLINE( 384)		if (::hx::IsNotNull( SimpleGraphic )) {
HXLINE( 385)			this->loadGraphic(SimpleGraphic,null(),null(),null(),null(),null());
            		}
            	}

Dynamic FlxSprite_obj::__CreateEmpty() { return new FlxSprite_obj; }

void *FlxSprite_obj::_hx_vtable = 0;

Dynamic FlxSprite_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< FlxSprite_obj > _hx_result = new FlxSprite_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2]);
	return _hx_result;
}

bool FlxSprite_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x7ccf8994) {
		if (inClassId<=(int)0x2c01639b) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x2c01639b;
		} else {
			return inClassId==(int)0x7ccf8994;
		}
	} else {
		return inClassId==(int)0x7dab0655;
	}
}

void FlxSprite_obj::initVars(){
            	HX_GC_STACKFRAME(&_hx_pos_cfd221447aa7194b_390_initVars)
HXLINE( 391)		this->super::initVars();
HXLINE( 393)		this->animation =  ::flixel::animation::FlxAnimationController_obj::__alloc( HX_CTX ,::hx::ObjectPtr<OBJ_>(this));
HXLINE( 395)		this->_flashPoint =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 396)		this->_flashRect =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE( 397)		this->_flashRect2 =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE( 398)		this->_flashPointZero =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 399)		 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN( 399)		point->_inPool = false;
HXDLIN( 399)		this->offset = point;
HXLINE( 400)		 ::flixel::math::FlxBasePoint point1 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN( 400)		point1->_inPool = false;
HXDLIN( 400)		this->origin = point1;
HXLINE( 401)		 ::flixel::math::FlxBasePoint point2 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(1,1);
HXDLIN( 401)		point2->_inPool = false;
HXDLIN( 401)		this->scale = point2;
HXLINE( 402)		 ::flixel::math::FlxBasePoint point3 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN( 402)		point3->_inPool = false;
HXDLIN( 402)		this->_halfSize = point3;
HXLINE( 403)		this->_matrix =  ::flixel::math::FlxMatrix_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
HXLINE( 404)		 ::flixel::math::FlxBasePoint point4 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN( 404)		point4->_inPool = false;
HXDLIN( 404)		this->_scaledOrigin = point4;
            	}


void FlxSprite_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_418_destroy)
HXLINE( 419)		this->super::destroy();
HXLINE( 421)		this->animation = ( ( ::flixel::animation::FlxAnimationController)(::flixel::util::FlxDestroyUtil_obj::destroy(this->animation)) );
HXLINE( 423)		this->offset = ( ( ::flixel::math::FlxBasePoint)(::flixel::util::FlxDestroyUtil_obj::put(this->offset)) );
HXLINE( 424)		this->origin = ( ( ::flixel::math::FlxBasePoint)(::flixel::util::FlxDestroyUtil_obj::put(this->origin)) );
HXLINE( 425)		this->scale = ( ( ::flixel::math::FlxBasePoint)(::flixel::util::FlxDestroyUtil_obj::put(this->scale)) );
HXLINE( 426)		this->_halfSize = ( ( ::flixel::math::FlxBasePoint)(::flixel::util::FlxDestroyUtil_obj::put(this->_halfSize)) );
HXLINE( 427)		this->_scaledOrigin = ( ( ::flixel::math::FlxBasePoint)(::flixel::util::FlxDestroyUtil_obj::put(this->_scaledOrigin)) );
HXLINE( 428)		this->_lastClipRect = ( ( ::flixel::math::FlxRect)(::flixel::util::FlxDestroyUtil_obj::put(this->_lastClipRect)) );
HXLINE( 430)		this->framePixels = ::flixel::util::FlxDestroyUtil_obj::dispose(this->framePixels);
HXLINE( 432)		this->_flashPoint = null();
HXLINE( 433)		this->_flashRect = null();
HXLINE( 434)		this->_flashRect2 = null();
HXLINE( 435)		this->_flashPointZero = null();
HXLINE( 436)		this->_matrix = null();
HXLINE( 437)		this->set_blend(null());
HXLINE( 439)		this->set_frames(null());
HXLINE( 440)		this->set_graphic(null());
HXLINE( 441)		this->_frame = ( ( ::flixel::graphics::frames::FlxFrame)(::flixel::util::FlxDestroyUtil_obj::destroy(this->_frame)) );
HXLINE( 442)		this->_frameGraphic = ( ( ::flixel::graphics::FlxGraphic)(::flixel::util::FlxDestroyUtil_obj::destroy(this->_frameGraphic)) );
HXLINE( 444)		this->shader = null();
            	}


 ::flixel::FlxSprite FlxSprite_obj::clone(){
            	HX_GC_STACKFRAME(&_hx_pos_cfd221447aa7194b_449_clone)
HXDLIN( 449)		return  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null())->loadGraphicFromSprite(::hx::ObjectPtr<OBJ_>(this));
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxSprite_obj,clone,return )

 ::flixel::FlxSprite FlxSprite_obj::loadGraphicFromSprite( ::flixel::FlxSprite Sprite){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_460_loadGraphicFromSprite)
HXLINE( 461)		this->set_frames(Sprite->frames);
HXLINE( 462)		this->bakedRotationAngle = Sprite->bakedRotationAngle;
HXLINE( 463)		if ((this->bakedRotationAngle > 0)) {
HXLINE( 465)			this->set_width(Sprite->get_width());
HXLINE( 466)			this->set_height(Sprite->get_height());
HXLINE( 467)			this->centerOffsets(null());
            		}
HXLINE( 469)		this->set_antialiasing(Sprite->antialiasing);
HXLINE( 470)		this->animation->copyFrom(Sprite->animation);
HXLINE( 471)		this->graphicLoaded();
HXLINE( 472)		this->set_clipRect(Sprite->clipRect);
HXLINE( 473)		return ::hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSprite_obj,loadGraphicFromSprite,return )

 ::flixel::FlxSprite FlxSprite_obj::loadGraphic( ::Dynamic graphic,::hx::Null< bool >  __o_animated,::hx::Null< int >  __o_frameWidth,::hx::Null< int >  __o_frameHeight,::hx::Null< bool >  __o_unique,::String key){
            		bool animated = __o_animated.Default(false);
            		int frameWidth = __o_frameWidth.Default(0);
            		int frameHeight = __o_frameHeight.Default(0);
            		bool unique = __o_unique.Default(false);
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_499_loadGraphic)
HXLINE( 500)		 ::flixel::graphics::FlxGraphic graph = ::flixel::FlxG_obj::bitmap->add(graphic,unique,key);
HXLINE( 501)		if (::hx::IsNull( graph )) {
HXLINE( 502)			return ::hx::ObjectPtr<OBJ_>(this);
            		}
HXLINE( 504)		if ((frameWidth == 0)) {
HXLINE( 506)			if (animated) {
HXLINE( 506)				frameWidth = graph->height;
            			}
            			else {
HXLINE( 506)				frameWidth = graph->width;
            			}
HXLINE( 507)			if ((frameWidth > graph->width)) {
HXLINE( 507)				frameWidth = graph->width;
            			}
            		}
            		else {
HXLINE( 509)			if ((frameWidth > graph->width)) {
HXLINE( 510)				::flixel::FlxG_obj::log->advanced((((HX_("frameWidth:",81,5b,44,2a) + frameWidth) + HX_(" is larger than the graphic's width:",7b,c4,23,c9)) + graph->width),::flixel::_hx_system::debug::log::LogStyle_obj::WARNING,true,::hx::SourceInfo(HX_("flixel/FlxSprite.hx",fa,bf,84,03),510,HX_("flixel.FlxSprite",65,ad,eb,e3),HX_("loadGraphic",22,19,a5,44)));
            			}
            		}
HXLINE( 512)		if ((frameHeight == 0)) {
HXLINE( 514)			if (animated) {
HXLINE( 514)				frameHeight = frameWidth;
            			}
            			else {
HXLINE( 514)				frameHeight = graph->height;
            			}
HXLINE( 515)			if ((frameHeight > graph->height)) {
HXLINE( 515)				frameHeight = graph->height;
            			}
            		}
            		else {
HXLINE( 517)			if ((frameHeight > graph->height)) {
HXLINE( 518)				::flixel::FlxG_obj::log->advanced((((HX_("frameHeight:",c6,a1,c5,a0) + frameHeight) + HX_(" is larger than the graphic's height:",8c,13,62,05)) + graph->height),::flixel::_hx_system::debug::log::LogStyle_obj::WARNING,true,::hx::SourceInfo(HX_("flixel/FlxSprite.hx",fa,bf,84,03),518,HX_("flixel.FlxSprite",65,ad,eb,e3),HX_("loadGraphic",22,19,a5,44)));
            			}
            		}
HXLINE( 520)		if (animated) {
HXLINE( 521)			 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(frameWidth,frameHeight);
HXDLIN( 521)			point->_inPool = false;
HXDLIN( 521)			this->set_frames(::flixel::graphics::frames::FlxTileFrames_obj::fromGraphic(graph,point,null(),null()));
            		}
            		else {
HXLINE( 523)			this->set_frames(graph->get_imageFrame());
            		}
HXLINE( 525)		return ::hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC6(FlxSprite_obj,loadGraphic,return )

 ::flixel::FlxSprite FlxSprite_obj::loadRotatedGraphic( ::Dynamic Graphic,::hx::Null< int >  __o_Rotations,::hx::Null< int >  __o_Frame,::hx::Null< bool >  __o_AntiAliasing,::hx::Null< bool >  __o_AutoBuffer,::String Key){
            		int Rotations = __o_Rotations.Default(16);
            		int Frame = __o_Frame.Default(-1);
            		bool AntiAliasing = __o_AntiAliasing.Default(false);
            		bool AutoBuffer = __o_AutoBuffer.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_cfd221447aa7194b_546_loadRotatedGraphic)
HXLINE( 547)		 ::flixel::graphics::FlxGraphic brushGraphic = ::flixel::FlxG_obj::bitmap->add(Graphic,false,Key);
HXLINE( 548)		if (::hx::IsNull( brushGraphic )) {
HXLINE( 549)			return ::hx::ObjectPtr<OBJ_>(this);
            		}
HXLINE( 551)		 ::openfl::display::BitmapData brush = brushGraphic->bitmap;
HXLINE( 552)		::String key = brushGraphic->key;
HXLINE( 554)		if ((Frame >= 0)) {
HXLINE( 557)			int brushSize = brush->height;
HXLINE( 558)			int framesNum = ::Std_obj::_hx_int((( (Float)(brush->width) ) / ( (Float)(brushSize) )));
HXLINE( 559)			bool Frame1;
HXDLIN( 559)			if ((framesNum <= Frame)) {
HXLINE( 559)				Frame1 = (framesNum == 0);
            			}
            			else {
HXLINE( 559)				Frame1 = true;
            			}
HXDLIN( 559)			if (!(Frame1)) {
HXLINE( 559)				Frame = ::hx::Mod(Frame,framesNum);
            			}
HXLINE( 560)			key = (key + (HX_(":",3a,00,00,00) + Frame));
HXLINE( 562)			 ::openfl::display::BitmapData full = brush;
HXLINE( 563)			brush =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,brushSize,brushSize,true,0);
HXLINE( 564)			this->_flashRect->setTo(( (Float)((Frame * brushSize)) ),( (Float)(0) ),( (Float)(brushSize) ),( (Float)(brushSize) ));
HXLINE( 565)			brush->copyPixels(full,this->_flashRect,this->_flashPointZero,null(),null(),null());
            		}
HXLINE( 568)		key = (key + (((HX_(":",3a,00,00,00) + Rotations) + HX_(":",3a,00,00,00)) + ::Std_obj::string(AutoBuffer)));
HXLINE( 571)		 ::flixel::graphics::FlxGraphic tempGraph = ( ( ::flixel::graphics::FlxGraphic)(::flixel::FlxG_obj::bitmap->_cache->get(key)) );
HXLINE( 572)		if (::hx::IsNull( tempGraph )) {
HXLINE( 574)			 ::openfl::display::BitmapData bitmap = ::flixel::util::FlxBitmapDataUtil_obj::generateRotations(brush,Rotations,AntiAliasing,AutoBuffer);
HXLINE( 575)			tempGraph = ::flixel::graphics::FlxGraphic_obj::fromBitmapData(bitmap,false,key,null());
            		}
HXLINE( 579)		::String _hx_tmp = ((((((((HX_("",00,00,00,00) + this->ID) + HX_(".loadRotatedGraphic(",55,ac,33,29)) + brushGraphic->trackingInfo) + HX_(", ",74,26,00,00)) + Rotations) + HX_(", ",74,26,00,00)) + Frame) + HX_(", ",74,26,00,00));
HXDLIN( 579)		::String _hx_tmp1 = ((_hx_tmp + ::Std_obj::string(AntiAliasing)) + HX_(", ",74,26,00,00));
HXDLIN( 579)		tempGraph->trackingInfo = ((_hx_tmp1 + ::Std_obj::string(AutoBuffer)) + HX_(")",29,00,00,00));
HXLINE( 582)		int max;
HXDLIN( 582)		if ((brush->height > brush->width)) {
HXLINE( 582)			max = brush->height;
            		}
            		else {
HXLINE( 582)			max = brush->width;
            		}
HXLINE( 583)		if (AutoBuffer) {
HXLINE( 583)			max = ::Std_obj::_hx_int((( (Float)(max) ) * ((Float)1.5)));
            		}
HXLINE( 585)		 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(max,max);
HXDLIN( 585)		point->_inPool = false;
HXDLIN( 585)		this->set_frames(::flixel::graphics::frames::FlxTileFrames_obj::fromGraphic(tempGraph,point,null(),null()));
HXLINE( 587)		if (AutoBuffer) {
HXLINE( 589)			this->set_width(( (Float)(brush->width) ));
HXLINE( 590)			this->set_height(( (Float)(brush->height) ));
HXLINE( 591)			this->centerOffsets(null());
            		}
HXLINE( 594)		this->bakedRotationAngle = (( (Float)(360) ) / ( (Float)(Rotations) ));
HXLINE( 595)		this->animation->createPrerotated(null());
HXLINE( 596)		return ::hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC6(FlxSprite_obj,loadRotatedGraphic,return )

 ::flixel::FlxSprite FlxSprite_obj::loadRotatedFrame( ::flixel::graphics::frames::FlxFrame frame,::hx::Null< int >  __o_rotations,::hx::Null< bool >  __o_antiAliasing,::hx::Null< bool >  __o_autoBuffer){
            		int rotations = __o_rotations.Default(16);
            		bool antiAliasing = __o_antiAliasing.Default(false);
            		bool autoBuffer = __o_autoBuffer.Default(false);
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_611_loadRotatedFrame)
HXLINE( 612)		::String key = frame->parent->key;
HXLINE( 613)		if (::hx::IsNotNull( frame->name )) {
HXLINE( 614)			key = (key + (HX_(":",3a,00,00,00) + frame->name));
            		}
            		else {
HXLINE( 616)			 ::flixel::math::FlxRect _this = frame->frame;
HXDLIN( 616)			 ::Dynamic value = _this->x;
HXDLIN( 616)			 ::flixel::util::LabelValuePair _this1 = ::flixel::util::LabelValuePair_obj::_pool->get().StaticCast<  ::flixel::util::LabelValuePair >();
HXDLIN( 616)			_this1->label = HX_("x",78,00,00,00);
HXDLIN( 616)			_this1->value = value;
HXDLIN( 616)			 ::Dynamic value1 = _this->y;
HXDLIN( 616)			 ::flixel::util::LabelValuePair _this2 = ::flixel::util::LabelValuePair_obj::_pool->get().StaticCast<  ::flixel::util::LabelValuePair >();
HXDLIN( 616)			_this2->label = HX_("y",79,00,00,00);
HXDLIN( 616)			_this2->value = value1;
HXDLIN( 616)			 ::Dynamic value2 = _this->width;
HXDLIN( 616)			 ::flixel::util::LabelValuePair _this3 = ::flixel::util::LabelValuePair_obj::_pool->get().StaticCast<  ::flixel::util::LabelValuePair >();
HXDLIN( 616)			_this3->label = HX_("w",77,00,00,00);
HXDLIN( 616)			_this3->value = value2;
HXDLIN( 616)			 ::Dynamic value3 = _this->height;
HXDLIN( 616)			 ::flixel::util::LabelValuePair _this4 = ::flixel::util::LabelValuePair_obj::_pool->get().StaticCast<  ::flixel::util::LabelValuePair >();
HXDLIN( 616)			_this4->label = HX_("h",68,00,00,00);
HXDLIN( 616)			_this4->value = value3;
HXDLIN( 616)			key = (key + (HX_(":",3a,00,00,00) + ::flixel::util::FlxStringUtil_obj::getDebugString(::Array_obj< ::Dynamic>::__new(4)->init(0,_this1)->init(1,_this2)->init(2,_this3)->init(3,_this4))));
            		}
HXLINE( 618)		 ::flixel::graphics::FlxGraphic graphic = ( ( ::flixel::graphics::FlxGraphic)(::flixel::FlxG_obj::bitmap->_cache->get(key)) );
HXLINE( 619)		if (::hx::IsNull( graphic )) {
HXLINE( 620)			graphic = ::flixel::graphics::FlxGraphic_obj::fromBitmapData(frame->paint(null(),null(),null(),null()),false,key,null());
            		}
HXLINE( 623)		::String _hx_tmp = ((((((HX_("",00,00,00,00) + this->ID) + HX_(".loadRotatedFrame(",f0,53,2f,ca)) + key) + HX_(", ",74,26,00,00)) + rotations) + HX_(", ",74,26,00,00));
HXDLIN( 623)		::String _hx_tmp1 = ((_hx_tmp + ::Std_obj::string(antiAliasing)) + HX_(", ",74,26,00,00));
HXDLIN( 623)		graphic->trackingInfo = ((_hx_tmp1 + ::Std_obj::string(autoBuffer)) + HX_(")",29,00,00,00));
HXLINE( 626)		return this->loadRotatedGraphic(graphic,rotations,-1,antiAliasing,autoBuffer,null());
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxSprite_obj,loadRotatedFrame,return )

 ::flixel::FlxSprite FlxSprite_obj::makeGraphic(int width,int height,::hx::Null< int >  __o_color,::hx::Null< bool >  __o_unique,::String key){
            		int color = __o_color.Default(-1);
            		bool unique = __o_unique.Default(false);
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_652_makeGraphic)
HXLINE( 653)		 ::flixel::graphics::FlxGraphic graph = ::flixel::FlxG_obj::bitmap->create(width,height,color,unique,key);
HXLINE( 654)		this->set_frames(graph->get_imageFrame());
HXLINE( 657)		::String _hx_tmp = ((((((HX_("",00,00,00,00) + this->ID) + HX_(".makeGraphic(",bc,19,d7,df)) + width) + HX_(", ",74,26,00,00)) + height) + HX_(", ",74,26,00,00));
HXDLIN( 657)		::String _hx_tmp1 = HX_("0x",48,2a,00,00);
HXDLIN( 657)		::String _hx_tmp2 = ::StringTools_obj::hex(((color >> 24) & 255),2);
HXDLIN( 657)		::String _hx_tmp3 = ((_hx_tmp1 + _hx_tmp2) + ::StringTools_obj::hex(((color >> 16) & 255),2));
HXDLIN( 657)		::String _hx_tmp4 = (_hx_tmp3 + ::StringTools_obj::hex(((color >> 8) & 255),2));
HXDLIN( 657)		::String _hx_tmp5 = ((_hx_tmp + (_hx_tmp4 + ::StringTools_obj::hex((color & 255),2))) + HX_(", ",74,26,00,00));
HXDLIN( 657)		graph->trackingInfo = ((((_hx_tmp5 + ::Std_obj::string(unique)) + HX_(", ",74,26,00,00)) + key) + HX_(")",29,00,00,00));
HXLINE( 660)		return ::hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC5(FlxSprite_obj,makeGraphic,return )

void FlxSprite_obj::graphicLoaded(){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_666_graphicLoaded)
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxSprite_obj,graphicLoaded,(void))

void FlxSprite_obj::resetSize(){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_672_resetSize)
HXLINE( 673)		this->_flashRect->x = ( (Float)(0) );
HXLINE( 674)		this->_flashRect->y = ( (Float)(0) );
HXLINE( 675)		this->_flashRect->width = ( (Float)(this->frameWidth) );
HXLINE( 676)		this->_flashRect->height = ( (Float)(this->frameHeight) );
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxSprite_obj,resetSize,(void))

void FlxSprite_obj::resetFrameSize(){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_683_resetFrameSize)
HXLINE( 684)		if (::hx::IsNotNull( this->frame )) {
HXLINE( 686)			this->frameWidth = ::Std_obj::_hx_int(this->frame->sourceSize->x);
HXLINE( 687)			this->frameHeight = ::Std_obj::_hx_int(this->frame->sourceSize->y);
            		}
HXLINE( 689)		{
HXLINE( 689)			 ::flixel::math::FlxBasePoint this1 = this->_halfSize;
HXDLIN( 689)			Float y = (((Float)0.5) * ( (Float)(this->frameHeight) ));
HXDLIN( 689)			this1->set_x((((Float)0.5) * ( (Float)(this->frameWidth) )));
HXDLIN( 689)			this1->set_y(y);
            		}
HXLINE( 690)		{
HXLINE( 690)			this->_flashRect->x = ( (Float)(0) );
HXDLIN( 690)			this->_flashRect->y = ( (Float)(0) );
HXDLIN( 690)			this->_flashRect->width = ( (Float)(this->frameWidth) );
HXDLIN( 690)			this->_flashRect->height = ( (Float)(this->frameHeight) );
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxSprite_obj,resetFrameSize,(void))

void FlxSprite_obj::resetSizeFromFrame(){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_697_resetSizeFromFrame)
HXLINE( 698)		this->set_width(( (Float)(this->frameWidth) ));
HXLINE( 699)		this->set_height(( (Float)(this->frameHeight) ));
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxSprite_obj,resetSizeFromFrame,(void))

void FlxSprite_obj::resetFrame(){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_710_resetFrame)
HXDLIN( 710)		this->set_frame(this->frame);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxSprite_obj,resetFrame,(void))

void FlxSprite_obj::setGraphicSize(::hx::Null< Float >  __o_width,::hx::Null< Float >  __o_height){
            		Float width = __o_width.Default(((Float)0.0));
            		Float height = __o_height.Default(((Float)0.0));
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_721_setGraphicSize)
HXLINE( 722)		bool _hx_tmp;
HXDLIN( 722)		if ((width <= 0)) {
HXLINE( 722)			_hx_tmp = (height <= 0);
            		}
            		else {
HXLINE( 722)			_hx_tmp = false;
            		}
HXDLIN( 722)		if (_hx_tmp) {
HXLINE( 723)			return;
            		}
HXLINE( 725)		Float newScaleX = (width / ( (Float)(this->frameWidth) ));
HXLINE( 726)		Float newScaleY = (height / ( (Float)(this->frameHeight) ));
HXLINE( 727)		{
HXLINE( 727)			 ::flixel::math::FlxBasePoint this1 = this->scale;
HXDLIN( 727)			this1->set_x(newScaleX);
HXDLIN( 727)			this1->set_y(newScaleY);
            		}
HXLINE( 729)		if ((width <= 0)) {
HXLINE( 730)			this->scale->set_x(newScaleY);
            		}
            		else {
HXLINE( 731)			if ((height <= 0)) {
HXLINE( 732)				this->scale->set_y(newScaleX);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxSprite_obj,setGraphicSize,(void))

void FlxSprite_obj::updateHitbox(){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_740_updateHitbox)
HXLINE( 741)		this->set_width((::Math_obj::abs(this->scale->x) * ( (Float)(this->frameWidth) )));
HXLINE( 742)		this->set_height((::Math_obj::abs(this->scale->y) * ( (Float)(this->frameHeight) )));
HXLINE( 743)		{
HXLINE( 743)			 ::flixel::math::FlxBasePoint this1 = this->offset;
HXDLIN( 743)			Float x = this->get_width();
HXDLIN( 743)			Float x1 = (((Float)-0.5) * (x - ( (Float)(this->frameWidth) )));
HXDLIN( 743)			Float y = this->get_height();
HXDLIN( 743)			Float y1 = (((Float)-0.5) * (y - ( (Float)(this->frameHeight) )));
HXDLIN( 743)			this1->set_x(x1);
HXDLIN( 743)			this1->set_y(y1);
            		}
HXLINE( 744)		{
HXLINE( 744)			 ::flixel::math::FlxBasePoint this2 = this->origin;
HXDLIN( 744)			Float y2 = (( (Float)(this->frameHeight) ) * ((Float)0.5));
HXDLIN( 744)			this2->set_x((( (Float)(this->frameWidth) ) * ((Float)0.5)));
HXDLIN( 744)			this2->set_y(y2);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxSprite_obj,updateHitbox,(void))

void FlxSprite_obj::resetHelpers(){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_752_resetHelpers)
HXLINE( 753)		{
HXLINE( 753)			if (::hx::IsNotNull( this->frame )) {
HXLINE( 753)				this->frameWidth = ::Std_obj::_hx_int(this->frame->sourceSize->x);
HXDLIN( 753)				this->frameHeight = ::Std_obj::_hx_int(this->frame->sourceSize->y);
            			}
HXDLIN( 753)			{
HXLINE( 753)				 ::flixel::math::FlxBasePoint this1 = this->_halfSize;
HXDLIN( 753)				Float y = (((Float)0.5) * ( (Float)(this->frameHeight) ));
HXDLIN( 753)				this1->set_x((((Float)0.5) * ( (Float)(this->frameWidth) )));
HXDLIN( 753)				this1->set_y(y);
            			}
HXDLIN( 753)			{
HXLINE( 753)				this->_flashRect->x = ( (Float)(0) );
HXDLIN( 753)				this->_flashRect->y = ( (Float)(0) );
HXDLIN( 753)				this->_flashRect->width = ( (Float)(this->frameWidth) );
HXDLIN( 753)				this->_flashRect->height = ( (Float)(this->frameHeight) );
            			}
            		}
HXLINE( 754)		{
HXLINE( 754)			this->set_width(( (Float)(this->frameWidth) ));
HXDLIN( 754)			this->set_height(( (Float)(this->frameHeight) ));
            		}
HXLINE( 755)		this->_flashRect2->x = ( (Float)(0) );
HXLINE( 756)		this->_flashRect2->y = ( (Float)(0) );
HXLINE( 758)		if (::hx::IsNotNull( this->graphic )) {
HXLINE( 760)			this->_flashRect2->width = ( (Float)(this->graphic->width) );
HXLINE( 761)			this->_flashRect2->height = ( (Float)(this->graphic->height) );
            		}
HXLINE( 764)		{
HXLINE( 764)			 ::flixel::math::FlxBasePoint this2 = this->origin;
HXDLIN( 764)			Float y1 = (( (Float)(this->frameHeight) ) * ((Float)0.5));
HXDLIN( 764)			this2->set_x((( (Float)(this->frameWidth) ) * ((Float)0.5)));
HXDLIN( 764)			this2->set_y(y1);
            		}
HXLINE( 766)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 768)			this->dirty = true;
HXLINE( 769)			this->updateFramePixels();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxSprite_obj,resetHelpers,(void))

void FlxSprite_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_774_update)
HXLINE( 775)		this->super::update(elapsed);
HXLINE( 776)		this->updateAnimation(elapsed);
            	}


void FlxSprite_obj::updateAnimation(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_784_updateAnimation)
HXDLIN( 784)		this->animation->update(elapsed);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSprite_obj,updateAnimation,(void))

void FlxSprite_obj::checkEmptyFrame(){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_790_checkEmptyFrame)
HXDLIN( 790)		if (::hx::IsNull( this->_frame )) {
HXLINE( 791)			this->loadGraphic(HX_("flixel/images/logo/default.png",1c,39,3e,0e),null(),null(),null(),null(),null());
            		}
            		else {
HXLINE( 792)			bool _hx_tmp;
HXDLIN( 792)			if (::hx::IsNotNull( this->graphic )) {
HXLINE( 792)				_hx_tmp = ::hx::IsNull( this->graphic->shader );
            			}
            			else {
HXLINE( 792)				_hx_tmp = false;
            			}
HXDLIN( 792)			if (_hx_tmp) {
HXLINE( 795)				Float width = this->get_width();
HXLINE( 796)				Float height = this->get_height();
HXLINE( 797)				::flixel::FlxG_obj::log->advanced(HX_("Cannot render a destroyed graphic, the placeholder image will be used instead",38,ee,6c,03),::flixel::_hx_system::debug::log::LogStyle_obj::ERROR,true,::hx::SourceInfo(HX_("flixel/FlxSprite.hx",fa,bf,84,03),797,HX_("flixel.FlxSprite",65,ad,eb,e3),HX_("checkEmptyFrame",48,b5,2f,00)));
HXLINE( 798)				this->loadGraphic(HX_("flixel/images/logo/default.png",1c,39,3e,0e),null(),null(),null(),null(),null());
HXLINE( 799)				this->set_width(width);
HXLINE( 800)				this->set_height(height);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxSprite_obj,checkEmptyFrame,(void))

void FlxSprite_obj::draw(){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_808_draw)
HXLINE( 809)		this->checkClipRect();
HXLINE( 811)		this->checkEmptyFrame();
HXLINE( 813)		bool _hx_tmp;
HXDLIN( 813)		if ((this->alpha != 0)) {
HXLINE( 813)			_hx_tmp = (this->_frame->type == 2);
            		}
            		else {
HXLINE( 813)			_hx_tmp = true;
            		}
HXDLIN( 813)		if (_hx_tmp) {
HXLINE( 814)			return;
            		}
HXLINE( 816)		if (this->dirty) {
HXLINE( 817)			this->calcFrame(this->useFramePixels);
            		}
HXLINE( 819)		{
HXLINE( 819)			int _g = 0;
HXDLIN( 819)			::Array< ::Dynamic> _g1 = this->getCamerasLegacy();
HXDLIN( 819)			while((_g < _g1->length)){
HXLINE( 819)				 ::flixel::FlxCamera camera = _g1->__get(_g).StaticCast<  ::flixel::FlxCamera >();
HXDLIN( 819)				_g = (_g + 1);
HXLINE( 821)				bool _hx_tmp1;
HXDLIN( 821)				bool _hx_tmp2;
HXDLIN( 821)				if (camera->visible) {
HXLINE( 821)					_hx_tmp2 = !(camera->exists);
            				}
            				else {
HXLINE( 821)					_hx_tmp2 = true;
            				}
HXDLIN( 821)				if (!(_hx_tmp2)) {
HXLINE( 821)					_hx_tmp1 = !(this->isOnScreen(camera));
            				}
            				else {
HXLINE( 821)					_hx_tmp1 = true;
            				}
HXDLIN( 821)				if (_hx_tmp1) {
HXLINE( 822)					continue;
            				}
HXLINE( 824)				if (this->isSimpleRender(camera)) {
HXLINE( 825)					this->drawSimple(camera);
            				}
            				else {
HXLINE( 827)					this->drawComplex(camera);
            				}
HXLINE( 830)				::flixel::FlxBasic_obj::visibleCount++;
            			}
            		}
HXLINE( 835)		if (::flixel::FlxG_obj::debugger->drawDebug) {
HXLINE( 836)			this->drawDebug();
            		}
            	}


void FlxSprite_obj::checkClipRect(){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_844_checkClipRect)
HXLINE( 845)		bool _hx_tmp;
HXDLIN( 845)		bool _hx_tmp1;
HXDLIN( 845)		if (::hx::IsNotNull( this->frames )) {
HXLINE( 846)			if (::hx::IsNull( this->clipRect )) {
HXLINE( 845)				_hx_tmp1 = ::Math_obj::isNaN(this->_lastClipRect->x);
            			}
            			else {
HXLINE( 845)				_hx_tmp1 = false;
            			}
            		}
            		else {
HXLINE( 845)			_hx_tmp1 = true;
            		}
HXDLIN( 845)		if (!(_hx_tmp1)) {
HXLINE( 847)			if (::hx::IsNotNull( this->clipRect )) {
HXLINE( 847)				 ::flixel::math::FlxRect _this = this->clipRect;
HXDLIN( 847)				 ::flixel::math::FlxRect rect = this->_lastClipRect;
HXDLIN( 847)				bool result;
HXDLIN( 847)				bool result1;
HXDLIN( 847)				bool result2;
HXDLIN( 847)				if ((::Math_obj::abs((_this->x - rect->x)) <= ((Float)0.0000001))) {
HXLINE( 847)					result2 = (::Math_obj::abs((_this->y - rect->y)) <= ((Float)0.0000001));
            				}
            				else {
HXLINE( 847)					result2 = false;
            				}
HXDLIN( 847)				if (result2) {
HXLINE( 847)					result1 = (::Math_obj::abs((_this->width - rect->width)) <= ((Float)0.0000001));
            				}
            				else {
HXLINE( 847)					result1 = false;
            				}
HXDLIN( 847)				if (result1) {
HXLINE( 847)					result = (::Math_obj::abs((_this->height - rect->height)) <= ((Float)0.0000001));
            				}
            				else {
HXLINE( 847)					result = false;
            				}
HXDLIN( 847)				if (rect->_weak) {
HXLINE( 847)					if (!(rect->_inPool)) {
HXLINE( 847)						rect->_inPool = true;
HXDLIN( 847)						rect->_weak = false;
HXDLIN( 847)						::flixel::math::FlxRect_obj::_pool->putUnsafe(rect);
            					}
            				}
HXLINE( 845)				_hx_tmp = result;
            			}
            			else {
HXLINE( 845)				_hx_tmp = false;
            			}
            		}
            		else {
HXLINE( 845)			_hx_tmp = true;
            		}
HXDLIN( 845)		if (_hx_tmp) {
HXLINE( 848)			return;
            		}
HXLINE( 851)		this->set_frame(this->frames->frames->__get(this->animation->frameIndex).StaticCast<  ::flixel::graphics::frames::FlxFrame >());
HXLINE( 853)		if (::hx::IsNull( this->clipRect )) {
HXLINE( 854)			 ::flixel::math::FlxRect _this1 = this->_lastClipRect;
HXDLIN( 854)			_this1->x = ::Math_obj::NaN;
HXDLIN( 854)			_this1->y = ((Float)0.0);
HXDLIN( 854)			_this1->width = ((Float)0.0);
HXDLIN( 854)			_this1->height = ((Float)0.0);
            		}
            		else {
HXLINE( 856)			 ::flixel::math::FlxRect _this2 = this->_lastClipRect;
HXDLIN( 856)			 ::flixel::math::FlxRect Rect = this->clipRect;
HXDLIN( 856)			_this2->x = Rect->x;
HXDLIN( 856)			_this2->y = Rect->y;
HXDLIN( 856)			_this2->width = Rect->width;
HXDLIN( 856)			_this2->height = Rect->height;
HXDLIN( 856)			if (Rect->_weak) {
HXLINE( 856)				if (!(Rect->_inPool)) {
HXLINE( 856)					Rect->_inPool = true;
HXDLIN( 856)					Rect->_weak = false;
HXDLIN( 856)					::flixel::math::FlxRect_obj::_pool->putUnsafe(Rect);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxSprite_obj,checkClipRect,(void))

void FlxSprite_obj::drawSimple( ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_861_drawSimple)
HXLINE( 862)		{
HXLINE( 862)			 ::flixel::math::FlxBasePoint this1 = this->getScreenPosition(this->_point,camera);
HXDLIN( 862)			 ::flixel::math::FlxBasePoint point = this->offset;
HXDLIN( 862)			{
HXLINE( 862)				Float y = point->y;
HXDLIN( 862)				this1->set_x((this1->x - point->x));
HXDLIN( 862)				this1->set_y((this1->y - y));
            			}
HXDLIN( 862)			{
HXLINE( 862)				 ::flixel::math::FlxBasePoint _this = point;
HXDLIN( 862)				if (_this->_weak) {
HXLINE( 862)					_this->put();
            				}
            			}
            		}
HXLINE( 863)		if (this->isPixelPerfectRender(camera)) {
HXLINE( 864)			 ::flixel::math::FlxBasePoint this2 = this->_point;
HXDLIN( 864)			this2->set_x(( (Float)(::Math_obj::floor(this2->x)) ));
HXDLIN( 864)			this2->set_y(( (Float)(::Math_obj::floor(this2->y)) ));
            		}
HXLINE( 866)		{
HXLINE( 866)			 ::flixel::math::FlxBasePoint this3 = this->_point;
HXDLIN( 866)			 ::openfl::geom::Point p = this->_flashPoint;
HXDLIN( 866)			p->x = this3->x;
HXDLIN( 866)			p->y = this3->y;
            		}
HXLINE( 867)		camera->copyPixels(this->_frame,this->framePixels,this->_flashRect,this->_flashPoint,this->colorTransform,this->blend,this->antialiasing,null());
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSprite_obj,drawSimple,(void))

void FlxSprite_obj::drawComplex( ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_873_drawComplex)
HXDLIN( 873)		this->drawFrameComplex(this->_frame,camera);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSprite_obj,drawComplex,(void))

void FlxSprite_obj::drawFrameComplex( ::flixel::graphics::frames::FlxFrame frame, ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_877_drawFrameComplex)
HXLINE( 878)		 ::flixel::math::FlxMatrix matrix = this->_matrix;
HXLINE( 879)		bool doFlipX = (this->flipX != this->_frame->flipX);
HXDLIN( 879)		bool _hx_tmp;
HXDLIN( 879)		if (::hx::IsNotNull( this->animation->_curAnim )) {
HXLINE( 879)			_hx_tmp = (doFlipX != this->animation->_curAnim->flipX);
            		}
            		else {
HXLINE( 879)			_hx_tmp = doFlipX;
            		}
HXDLIN( 879)		bool doFlipY = (this->flipY != this->_frame->flipY);
HXDLIN( 879)		bool _hx_tmp1;
HXDLIN( 879)		if (::hx::IsNotNull( this->animation->_curAnim )) {
HXLINE( 879)			_hx_tmp1 = (doFlipY != this->animation->_curAnim->flipY);
            		}
            		else {
HXLINE( 879)			_hx_tmp1 = doFlipY;
            		}
HXDLIN( 879)		frame->prepareMatrix(matrix,0,_hx_tmp,_hx_tmp1);
HXLINE( 880)		matrix->translate(-(this->origin->x),-(this->origin->y));
HXLINE( 881)		matrix->scale(this->scale->x,this->scale->y);
HXLINE( 883)		if ((this->bakedRotationAngle <= 0)) {
HXLINE( 885)			if (this->_angleChanged) {
HXLINE( 885)				Float radians = (this->angle * (::Math_obj::PI / ( (Float)(180) )));
HXDLIN( 885)				this->_sinAngle = ::Math_obj::sin(radians);
HXDLIN( 885)				this->_cosAngle = ::Math_obj::cos(radians);
HXDLIN( 885)				this->_angleChanged = false;
            			}
HXLINE( 887)			if ((this->angle != 0)) {
HXLINE( 888)				Float cos = this->_cosAngle;
HXDLIN( 888)				Float sin = this->_sinAngle;
HXDLIN( 888)				Float a1 = ((matrix->a * cos) - (matrix->b * sin));
HXDLIN( 888)				matrix->b = ((matrix->a * sin) + (matrix->b * cos));
HXDLIN( 888)				matrix->a = a1;
HXDLIN( 888)				Float c1 = ((matrix->c * cos) - (matrix->d * sin));
HXDLIN( 888)				matrix->d = ((matrix->c * sin) + (matrix->d * cos));
HXDLIN( 888)				matrix->c = c1;
HXDLIN( 888)				Float tx1 = ((matrix->tx * cos) - (matrix->ty * sin));
HXDLIN( 888)				matrix->ty = ((matrix->tx * sin) + (matrix->ty * cos));
HXDLIN( 888)				matrix->tx = tx1;
            			}
            		}
HXLINE( 891)		{
HXLINE( 891)			 ::flixel::math::FlxBasePoint this1 = this->getScreenPosition(this->_point,camera);
HXDLIN( 891)			 ::flixel::math::FlxBasePoint point = this->offset;
HXDLIN( 891)			{
HXLINE( 891)				Float y = point->y;
HXDLIN( 891)				this1->set_x((this1->x - point->x));
HXDLIN( 891)				this1->set_y((this1->y - y));
            			}
HXDLIN( 891)			{
HXLINE( 891)				 ::flixel::math::FlxBasePoint _this = point;
HXDLIN( 891)				if (_this->_weak) {
HXLINE( 891)					_this->put();
            				}
            			}
            		}
HXLINE( 892)		{
HXLINE( 892)			 ::flixel::math::FlxBasePoint this2 = this->_point;
HXDLIN( 892)			Float y1 = this->origin->y;
HXDLIN( 892)			this2->set_x((this2->x + this->origin->x));
HXDLIN( 892)			this2->set_y((this2->y + y1));
            		}
HXLINE( 893)		matrix->translate(this->_point->x,this->_point->y);
HXLINE( 895)		if (this->isPixelPerfectRender(camera)) {
HXLINE( 897)			matrix->tx = ( (Float)(::Math_obj::floor(matrix->tx)) );
HXLINE( 898)			matrix->ty = ( (Float)(::Math_obj::floor(matrix->ty)) );
            		}
HXLINE( 901)		camera->drawPixels(frame,this->framePixels,matrix,this->colorTransform,this->blend,this->antialiasing,this->shader);
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxSprite_obj,drawFrameComplex,(void))

void FlxSprite_obj::stamp( ::flixel::FlxSprite Brush,::hx::Null< int >  __o_X,::hx::Null< int >  __o_Y){
            		int X = __o_X.Default(0);
            		int Y = __o_Y.Default(0);
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_913_stamp)
HXLINE( 914)		Brush->drawFrame(null());
HXLINE( 916)		bool _hx_tmp;
HXDLIN( 916)		if (::hx::IsNotNull( this->graphic )) {
HXLINE( 916)			_hx_tmp = ::hx::IsNull( Brush->graphic );
            		}
            		else {
HXLINE( 916)			_hx_tmp = true;
            		}
HXDLIN( 916)		if (_hx_tmp) {
HXLINE( 917)			HX_STACK_DO_THROW(HX_("Cannot stamp to or from a FlxSprite with no graphics.",72,0b,d4,aa));
            		}
HXLINE( 919)		 ::openfl::display::BitmapData bitmapData = Brush->framePixels;
HXLINE( 921)		if (this->isSimpleRenderBlit(null())) {
HXLINE( 923)			this->_flashPoint->x = (X + this->frame->frame->x);
HXLINE( 924)			this->_flashPoint->y = (Y + this->frame->frame->y);
HXLINE( 925)			this->_flashRect2->width = ( (Float)(bitmapData->width) );
HXLINE( 926)			this->_flashRect2->height = ( (Float)(bitmapData->height) );
HXLINE( 927)			this->graphic->bitmap->copyPixels(bitmapData,this->_flashRect2,this->_flashPoint,null(),null(),true);
HXLINE( 928)			this->_flashRect2->width = ( (Float)(this->graphic->bitmap->width) );
HXLINE( 929)			this->_flashRect2->height = ( (Float)(this->graphic->bitmap->height) );
            		}
            		else {
HXLINE( 933)			this->_matrix->identity();
HXLINE( 934)			this->_matrix->translate(-(Brush->origin->x),-(Brush->origin->y));
HXLINE( 935)			this->_matrix->scale(Brush->scale->x,Brush->scale->y);
HXLINE( 936)			if ((Brush->angle != 0)) {
HXLINE( 938)				this->_matrix->rotate((Brush->angle * (::Math_obj::PI / ( (Float)(180) ))));
            			}
HXLINE( 940)			this->_matrix->translate(((X + this->frame->frame->x) + Brush->origin->x),((Y + this->frame->frame->y) + Brush->origin->y));
HXLINE( 941)			 ::Dynamic brushBlend = Brush->blend;
HXLINE( 942)			this->graphic->bitmap->draw(bitmapData,this->_matrix,null(),brushBlend,null(),Brush->antialiasing);
            		}
HXLINE( 945)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 947)			this->dirty = true;
HXLINE( 948)			this->calcFrame(null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxSprite_obj,stamp,(void))

void FlxSprite_obj::drawFrame(::hx::Null< bool >  __o_Force){
            		bool Force = __o_Force.Default(false);
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_960_drawFrame)
HXDLIN( 960)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 962)			bool _hx_tmp;
HXDLIN( 962)			if (!(Force)) {
HXLINE( 962)				_hx_tmp = this->dirty;
            			}
            			else {
HXLINE( 962)				_hx_tmp = true;
            			}
HXDLIN( 962)			if (_hx_tmp) {
HXLINE( 964)				this->dirty = true;
HXLINE( 965)				this->calcFrame(null());
            			}
            		}
            		else {
HXLINE( 970)			this->dirty = true;
HXLINE( 971)			this->calcFrame(true);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSprite_obj,drawFrame,(void))

void FlxSprite_obj::centerOffsets(::hx::Null< bool >  __o_AdjustPosition){
            		bool AdjustPosition = __o_AdjustPosition.Default(false);
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_981_centerOffsets)
HXLINE( 982)		{
HXLINE( 982)			 ::flixel::math::FlxBasePoint this1 = this->offset;
HXDLIN( 982)			int x = this->frameWidth;
HXDLIN( 982)			this1->set_x(((( (Float)(x) ) - this->get_width()) * ((Float)0.5)));
            		}
HXLINE( 983)		{
HXLINE( 983)			 ::flixel::math::FlxBasePoint this2 = this->offset;
HXDLIN( 983)			int y = this->frameHeight;
HXDLIN( 983)			this2->set_y(((( (Float)(y) ) - this->get_height()) * ((Float)0.5)));
            		}
HXLINE( 984)		if (AdjustPosition) {
HXLINE( 986)			this->set_x((this->x + this->offset->x));
HXLINE( 987)			this->set_y((this->y + this->offset->y));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSprite_obj,centerOffsets,(void))

void FlxSprite_obj::centerOrigin(){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_997_centerOrigin)
HXDLIN( 997)		 ::flixel::math::FlxBasePoint this1 = this->origin;
HXDLIN( 997)		Float y = (( (Float)(this->frameHeight) ) * ((Float)0.5));
HXDLIN( 997)		this1->set_x((( (Float)(this->frameWidth) ) * ((Float)0.5)));
HXDLIN( 997)		this1->set_y(y);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxSprite_obj,centerOrigin,(void))

::Array< ::Dynamic> FlxSprite_obj::replaceColor(int Color,int NewColor,::hx::Null< bool >  __o_FetchPositions){
            		bool FetchPositions = __o_FetchPositions.Default(false);
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1010_replaceColor)
HXLINE(1011)		::Array< ::Dynamic> positions = ::flixel::util::FlxBitmapDataUtil_obj::replaceColor(this->graphic->bitmap,Color,NewColor,FetchPositions,null());
HXLINE(1012)		if (::hx::IsNotNull( positions )) {
HXLINE(1013)			this->dirty = true;
            		}
HXLINE(1014)		return positions;
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxSprite_obj,replaceColor,return )

void FlxSprite_obj::setColorTransform(::hx::Null< Float >  __o_redMultiplier,::hx::Null< Float >  __o_greenMultiplier,::hx::Null< Float >  __o_blueMultiplier,::hx::Null< Float >  __o_alphaMultiplier,::hx::Null< Float >  __o_redOffset,::hx::Null< Float >  __o_greenOffset,::hx::Null< Float >  __o_blueOffset,::hx::Null< Float >  __o_alphaOffset){
            		Float redMultiplier = __o_redMultiplier.Default(((Float)1.0));
            		Float greenMultiplier = __o_greenMultiplier.Default(((Float)1.0));
            		Float blueMultiplier = __o_blueMultiplier.Default(((Float)1.0));
            		Float alphaMultiplier = __o_alphaMultiplier.Default(((Float)1.0));
            		Float redOffset = __o_redOffset.Default(((Float)0.0));
            		Float greenOffset = __o_greenOffset.Default(((Float)0.0));
            		Float blueOffset = __o_blueOffset.Default(((Float)0.0));
            		Float alphaOffset = __o_alphaOffset.Default(((Float)0.0));
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1033_setColorTransform)
HXLINE(1034)		Float lowerBound;
HXDLIN(1034)		if ((alphaMultiplier < 0)) {
HXLINE(1034)			lowerBound = ( (Float)(0) );
            		}
            		else {
HXLINE(1034)			lowerBound = alphaMultiplier;
            		}
HXDLIN(1034)		if ((lowerBound > 1)) {
HXLINE(1034)			alphaMultiplier = ( (Float)(1) );
            		}
            		else {
HXLINE(1034)			alphaMultiplier = lowerBound;
            		}
HXLINE(1035)		int color = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN(1035)		{
HXLINE(1035)			int Value = ::Math_obj::round((redMultiplier * ( (Float)(255) )));
HXDLIN(1035)			color = (color & -16711681);
HXDLIN(1035)			int color1;
HXDLIN(1035)			if ((Value > 255)) {
HXLINE(1035)				color1 = 255;
            			}
            			else {
HXLINE(1035)				if ((Value < 0)) {
HXLINE(1035)					color1 = 0;
            				}
            				else {
HXLINE(1035)					color1 = Value;
            				}
            			}
HXDLIN(1035)			color = (color | (color1 << 16));
            		}
HXDLIN(1035)		{
HXLINE(1035)			int Value1 = ::Math_obj::round((greenMultiplier * ( (Float)(255) )));
HXDLIN(1035)			color = (color & -65281);
HXDLIN(1035)			int color2;
HXDLIN(1035)			if ((Value1 > 255)) {
HXLINE(1035)				color2 = 255;
            			}
            			else {
HXLINE(1035)				if ((Value1 < 0)) {
HXLINE(1035)					color2 = 0;
            				}
            				else {
HXLINE(1035)					color2 = Value1;
            				}
            			}
HXDLIN(1035)			color = (color | (color2 << 8));
            		}
HXDLIN(1035)		{
HXLINE(1035)			int Value2 = ::Math_obj::round((blueMultiplier * ( (Float)(255) )));
HXDLIN(1035)			color = (color & -256);
HXDLIN(1035)			int color3;
HXDLIN(1035)			if ((Value2 > 255)) {
HXLINE(1035)				color3 = 255;
            			}
            			else {
HXLINE(1035)				if ((Value2 < 0)) {
HXLINE(1035)					color3 = 0;
            				}
            				else {
HXLINE(1035)					color3 = Value2;
            				}
            			}
HXDLIN(1035)			color = (color | color3);
            		}
HXDLIN(1035)		{
HXLINE(1035)			int Value3 = ::Math_obj::round(((Float)255.));
HXDLIN(1035)			color = (color & 16777215);
HXDLIN(1035)			int color4;
HXDLIN(1035)			if ((Value3 > 255)) {
HXLINE(1035)				color4 = 255;
            			}
            			else {
HXLINE(1035)				if ((Value3 < 0)) {
HXLINE(1035)					color4 = 0;
            				}
            				else {
HXLINE(1035)					color4 = Value3;
            				}
            			}
HXDLIN(1035)			color = (color | (color4 << 24));
            		}
HXDLIN(1035)		this->color = color;
HXLINE(1036)		this->alpha = alphaMultiplier;
HXLINE(1038)		{
HXLINE(1038)			 ::openfl::geom::ColorTransform transform = this->colorTransform;
HXDLIN(1038)			transform->redMultiplier = redMultiplier;
HXDLIN(1038)			transform->greenMultiplier = greenMultiplier;
HXDLIN(1038)			transform->blueMultiplier = blueMultiplier;
HXDLIN(1038)			transform->alphaMultiplier = alphaMultiplier;
            		}
HXLINE(1039)		{
HXLINE(1039)			 ::openfl::geom::ColorTransform transform1 = this->colorTransform;
HXDLIN(1039)			transform1->redOffset = redOffset;
HXDLIN(1039)			transform1->greenOffset = greenOffset;
HXDLIN(1039)			transform1->blueOffset = blueOffset;
HXDLIN(1039)			transform1->alphaOffset = alphaOffset;
            		}
HXLINE(1040)		this->useColorTransform = this->hasColorTransformRaw();
HXLINE(1042)		this->dirty = true;
            	}


HX_DEFINE_DYNAMIC_FUNC8(FlxSprite_obj,setColorTransform,(void))

void FlxSprite_obj::updateColorTransform(){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1047_updateColorTransform)
HXLINE(1048)		{
HXLINE(1048)			 ::openfl::geom::ColorTransform transform = this->colorTransform;
HXDLIN(1048)			transform->redMultiplier = (( (Float)(((this->color >> 16) & 255)) ) / ( (Float)(255) ));
HXDLIN(1048)			transform->greenMultiplier = (( (Float)(((this->color >> 8) & 255)) ) / ( (Float)(255) ));
HXDLIN(1048)			transform->blueMultiplier = (( (Float)((this->color & 255)) ) / ( (Float)(255) ));
HXDLIN(1048)			transform->alphaMultiplier = this->alpha;
            		}
HXLINE(1049)		this->useColorTransform = this->hasColorTransformRaw();
HXLINE(1051)		this->dirty = true;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxSprite_obj,updateColorTransform,(void))

bool FlxSprite_obj::hasColorTransform(){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1061_hasColorTransform)
HXDLIN(1061)		if (!(this->useColorTransform)) {
HXDLIN(1061)			return this->hasColorTransformRaw();
            		}
            		else {
HXDLIN(1061)			return true;
            		}
HXDLIN(1061)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxSprite_obj,hasColorTransform,return )

bool FlxSprite_obj::hasColorTransformRaw(){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1069_hasColorTransformRaw)
HXDLIN(1069)		bool _hx_tmp;
HXDLIN(1069)		if ((this->alpha == 1)) {
HXDLIN(1069)			_hx_tmp = ((this->color & 16777215) != 16777215);
            		}
            		else {
HXDLIN(1069)			_hx_tmp = true;
            		}
HXDLIN(1069)		if (!(_hx_tmp)) {
HXDLIN(1069)			return ::flixel::util::FlxColorTransformUtil_obj::hasRGBAOffsets(this->colorTransform);
            		}
            		else {
HXDLIN(1069)			return true;
            		}
HXDLIN(1069)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxSprite_obj,hasColorTransformRaw,return )

bool FlxSprite_obj::pixelsOverlapPoint( ::flixel::math::FlxBasePoint worldPoint,::hx::Null< int >  __o_alphaTolerance, ::flixel::FlxCamera camera){
            		int alphaTolerance = __o_alphaTolerance.Default(255);
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1083_pixelsOverlapPoint)
HXLINE(1084)		 ::Dynamic pixelColor = this->getPixelAt(worldPoint,camera);
HXLINE(1086)		if (::hx::IsNotNull( pixelColor )) {
HXLINE(1087)			return ((( (Float)(((( (int)(pixelColor) ) >> 24) & 255)) ) * this->alpha) >= alphaTolerance);
            		}
HXLINE(1090)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxSprite_obj,pixelsOverlapPoint,return )

 ::Dynamic FlxSprite_obj::getPixelAt( ::flixel::math::FlxBasePoint worldPoint, ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1103_getPixelAt)
HXLINE(1104)		this->transformWorldToPixels(worldPoint,camera,this->_point);
HXLINE(1107)		bool _hx_tmp;
HXDLIN(1107)		bool _hx_tmp1;
HXDLIN(1107)		bool _hx_tmp2;
HXDLIN(1107)		if ((this->_point->x >= 0)) {
HXLINE(1107)			_hx_tmp2 = (this->_point->x <= this->frameWidth);
            		}
            		else {
HXLINE(1107)			_hx_tmp2 = false;
            		}
HXDLIN(1107)		if (_hx_tmp2) {
HXLINE(1107)			_hx_tmp1 = (this->_point->y >= 0);
            		}
            		else {
HXLINE(1107)			_hx_tmp1 = false;
            		}
HXDLIN(1107)		if (_hx_tmp1) {
HXLINE(1107)			_hx_tmp = (this->_point->y <= this->frameHeight);
            		}
            		else {
HXLINE(1107)			_hx_tmp = false;
            		}
HXDLIN(1107)		if (_hx_tmp) {
HXLINE(1109)			 ::openfl::display::BitmapData frameData = this->updateFramePixels();
HXLINE(1110)			int _hx_tmp3 = ::Std_obj::_hx_int(this->_point->x);
HXDLIN(1110)			return frameData->getPixel32(_hx_tmp3,::Std_obj::_hx_int(this->_point->y));
            		}
HXLINE(1113)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxSprite_obj,getPixelAt,return )

 ::Dynamic FlxSprite_obj::getPixelAtScreen( ::flixel::math::FlxBasePoint screenPoint, ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1126_getPixelAtScreen)
HXLINE(1127)		this->transformScreenToPixels(screenPoint,camera,this->_point);
HXLINE(1130)		bool _hx_tmp;
HXDLIN(1130)		bool _hx_tmp1;
HXDLIN(1130)		bool _hx_tmp2;
HXDLIN(1130)		if ((this->_point->x >= 0)) {
HXLINE(1130)			_hx_tmp2 = (this->_point->x <= this->frameWidth);
            		}
            		else {
HXLINE(1130)			_hx_tmp2 = false;
            		}
HXDLIN(1130)		if (_hx_tmp2) {
HXLINE(1130)			_hx_tmp1 = (this->_point->y >= 0);
            		}
            		else {
HXLINE(1130)			_hx_tmp1 = false;
            		}
HXDLIN(1130)		if (_hx_tmp1) {
HXLINE(1130)			_hx_tmp = (this->_point->y <= this->frameHeight);
            		}
            		else {
HXLINE(1130)			_hx_tmp = false;
            		}
HXDLIN(1130)		if (_hx_tmp) {
HXLINE(1132)			 ::openfl::display::BitmapData frameData = this->updateFramePixels();
HXLINE(1133)			int _hx_tmp3 = ::Std_obj::_hx_int(this->_point->x);
HXDLIN(1133)			return frameData->getPixel32(_hx_tmp3,::Std_obj::_hx_int(this->_point->y));
            		}
HXLINE(1136)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxSprite_obj,getPixelAtScreen,return )

 ::flixel::math::FlxBasePoint FlxSprite_obj::transformWorldToPixels( ::flixel::math::FlxBasePoint worldPoint, ::flixel::FlxCamera camera, ::flixel::math::FlxBasePoint result){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1149_transformWorldToPixels)
HXLINE(1150)		if (::hx::IsNull( camera )) {
HXLINE(1151)			camera = this->getDefaultCamera();
            		}
HXLINE(1153)		Float x = (worldPoint->x - camera->scroll->x);
HXDLIN(1153)		Float y = (worldPoint->y - camera->scroll->y);
HXDLIN(1153)		 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(x,y);
HXDLIN(1153)		point->_inPool = false;
HXDLIN(1153)		 ::flixel::math::FlxBasePoint point1 = point;
HXDLIN(1153)		point1->_weak = true;
HXDLIN(1153)		 ::flixel::math::FlxBasePoint screenPoint = point1;
HXLINE(1154)		{
HXLINE(1154)			 ::flixel::math::FlxBasePoint _this = worldPoint;
HXDLIN(1154)			if (_this->_weak) {
HXLINE(1154)				_this->put();
            			}
            		}
HXLINE(1155)		return this->transformScreenToPixels(screenPoint,camera,result);
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxSprite_obj,transformWorldToPixels,return )

 ::flixel::math::FlxBasePoint FlxSprite_obj::transformWorldToPixelsSimple( ::flixel::math::FlxBasePoint worldPoint, ::flixel::math::FlxBasePoint result){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1167_transformWorldToPixelsSimple)
HXLINE(1168)		result = this->getPosition(result);
HXLINE(1170)		{
HXLINE(1170)			Float y = worldPoint->y;
HXDLIN(1170)			result->set_x((result->x - worldPoint->x));
HXDLIN(1170)			result->set_y((result->y - y));
            		}
HXLINE(1171)		{
HXLINE(1171)			result->set_x((result->x * ( (Float)(-1) )));
HXDLIN(1171)			result->set_y((result->y * ( (Float)(-1) )));
            		}
HXLINE(1172)		{
HXLINE(1172)			 ::flixel::math::FlxBasePoint point = this->offset;
HXDLIN(1172)			{
HXLINE(1172)				Float y1 = point->y;
HXDLIN(1172)				result->set_x((result->x + point->x));
HXDLIN(1172)				result->set_y((result->y + y1));
            			}
HXDLIN(1172)			{
HXLINE(1172)				 ::flixel::math::FlxBasePoint _this = point;
HXDLIN(1172)				if (_this->_weak) {
HXLINE(1172)					_this->put();
            				}
            			}
            		}
HXLINE(1173)		{
HXLINE(1173)			 ::flixel::math::FlxBasePoint point1 = this->origin;
HXDLIN(1173)			{
HXLINE(1173)				Float y2 = point1->y;
HXDLIN(1173)				result->set_x((result->x - point1->x));
HXDLIN(1173)				result->set_y((result->y - y2));
            			}
HXDLIN(1173)			{
HXLINE(1173)				 ::flixel::math::FlxBasePoint _this1 = point1;
HXDLIN(1173)				if (_this1->_weak) {
HXLINE(1173)					_this1->put();
            				}
            			}
            		}
HXLINE(1174)		{
HXLINE(1174)			Float y3 = (( (Float)(1) ) / this->scale->y);
HXDLIN(1174)			result->set_x((result->x * (( (Float)(1) ) / this->scale->x)));
HXDLIN(1174)			result->set_y((result->y * y3));
            		}
HXLINE(1175)		{
HXLINE(1175)			Float degs = ::flixel::math::_FlxPoint::FlxPoint_Impl__obj::get_radians(result);
HXDLIN(1175)			Float degs1 = ((degs * (( (Float)(180) ) / ::Math_obj::PI)) - this->angle);
HXDLIN(1175)			{
HXLINE(1175)				Float rads = (degs1 * (::Math_obj::PI / ( (Float)(180) )));
HXDLIN(1175)				Float len = ::Math_obj::sqrt(((result->x * result->x) + (result->y * result->y)));
HXDLIN(1175)				result->set_x((len * ::Math_obj::cos(rads)));
HXDLIN(1175)				result->set_y((len * ::Math_obj::sin(rads)));
            			}
            		}
HXLINE(1176)		{
HXLINE(1176)			 ::flixel::math::FlxBasePoint point2 = this->origin;
HXDLIN(1176)			{
HXLINE(1176)				Float y4 = point2->y;
HXDLIN(1176)				result->set_x((result->x + point2->x));
HXDLIN(1176)				result->set_y((result->y + y4));
            			}
HXDLIN(1176)			{
HXLINE(1176)				 ::flixel::math::FlxBasePoint _this2 = point2;
HXDLIN(1176)				if (_this2->_weak) {
HXLINE(1176)					_this2->put();
            				}
            			}
            		}
HXLINE(1178)		{
HXLINE(1178)			 ::flixel::math::FlxBasePoint _this3 = worldPoint;
HXDLIN(1178)			if (_this3->_weak) {
HXLINE(1178)				_this3->put();
            			}
            		}
HXLINE(1180)		return result;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxSprite_obj,transformWorldToPixelsSimple,return )

 ::flixel::math::FlxBasePoint FlxSprite_obj::transformScreenToPixels( ::flixel::math::FlxBasePoint screenPoint, ::flixel::FlxCamera camera, ::flixel::math::FlxBasePoint result){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1193_transformScreenToPixels)
HXLINE(1194)		result = this->getScreenPosition(result,camera);
HXLINE(1196)		{
HXLINE(1196)			Float y = screenPoint->y;
HXDLIN(1196)			result->set_x((result->x - screenPoint->x));
HXDLIN(1196)			result->set_y((result->y - y));
            		}
HXLINE(1197)		{
HXLINE(1197)			result->set_x((result->x * ( (Float)(-1) )));
HXDLIN(1197)			result->set_y((result->y * ( (Float)(-1) )));
            		}
HXLINE(1198)		{
HXLINE(1198)			 ::flixel::math::FlxBasePoint point = this->offset;
HXDLIN(1198)			{
HXLINE(1198)				Float y1 = point->y;
HXDLIN(1198)				result->set_x((result->x + point->x));
HXDLIN(1198)				result->set_y((result->y + y1));
            			}
HXDLIN(1198)			{
HXLINE(1198)				 ::flixel::math::FlxBasePoint _this = point;
HXDLIN(1198)				if (_this->_weak) {
HXLINE(1198)					_this->put();
            				}
            			}
            		}
HXLINE(1199)		{
HXLINE(1199)			 ::flixel::math::FlxBasePoint point1 = this->origin;
HXDLIN(1199)			{
HXLINE(1199)				Float y2 = point1->y;
HXDLIN(1199)				result->set_x((result->x - point1->x));
HXDLIN(1199)				result->set_y((result->y - y2));
            			}
HXDLIN(1199)			{
HXLINE(1199)				 ::flixel::math::FlxBasePoint _this1 = point1;
HXDLIN(1199)				if (_this1->_weak) {
HXLINE(1199)					_this1->put();
            				}
            			}
            		}
HXLINE(1200)		{
HXLINE(1200)			Float y3 = (( (Float)(1) ) / this->scale->y);
HXDLIN(1200)			result->set_x((result->x * (( (Float)(1) ) / this->scale->x)));
HXDLIN(1200)			result->set_y((result->y * y3));
            		}
HXLINE(1201)		{
HXLINE(1201)			Float degs = ::flixel::math::_FlxPoint::FlxPoint_Impl__obj::get_radians(result);
HXDLIN(1201)			Float degs1 = ((degs * (( (Float)(180) ) / ::Math_obj::PI)) - this->angle);
HXDLIN(1201)			{
HXLINE(1201)				Float rads = (degs1 * (::Math_obj::PI / ( (Float)(180) )));
HXDLIN(1201)				Float len = ::Math_obj::sqrt(((result->x * result->x) + (result->y * result->y)));
HXDLIN(1201)				result->set_x((len * ::Math_obj::cos(rads)));
HXDLIN(1201)				result->set_y((len * ::Math_obj::sin(rads)));
            			}
            		}
HXLINE(1202)		{
HXLINE(1202)			 ::flixel::math::FlxBasePoint point2 = this->origin;
HXDLIN(1202)			{
HXLINE(1202)				Float y4 = point2->y;
HXDLIN(1202)				result->set_x((result->x + point2->x));
HXDLIN(1202)				result->set_y((result->y + y4));
            			}
HXDLIN(1202)			{
HXLINE(1202)				 ::flixel::math::FlxBasePoint _this2 = point2;
HXDLIN(1202)				if (_this2->_weak) {
HXLINE(1202)					_this2->put();
            				}
            			}
            		}
HXLINE(1204)		{
HXLINE(1204)			 ::flixel::math::FlxBasePoint _this3 = screenPoint;
HXDLIN(1204)			if (_this3->_weak) {
HXLINE(1204)				_this3->put();
            			}
            		}
HXLINE(1206)		return result;
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxSprite_obj,transformScreenToPixels,return )

void FlxSprite_obj::calcFrame(::hx::Null< bool >  __o_force){
            		bool force = __o_force.Default(false);
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1216_calcFrame)
HXLINE(1217)		this->checkEmptyFrame();
HXLINE(1219)		bool _hx_tmp;
HXDLIN(1219)		if (::flixel::FlxG_obj::renderTile) {
HXLINE(1219)			_hx_tmp = !(force);
            		}
            		else {
HXLINE(1219)			_hx_tmp = false;
            		}
HXDLIN(1219)		if (_hx_tmp) {
HXLINE(1220)			return;
            		}
HXLINE(1222)		this->updateFramePixels();
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSprite_obj,calcFrame,(void))

 ::openfl::display::BitmapData FlxSprite_obj::updateFramePixels(){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1229_updateFramePixels)
HXLINE(1230)		bool _hx_tmp;
HXDLIN(1230)		if (::hx::IsNotNull( this->_frame )) {
HXLINE(1230)			_hx_tmp = !(this->dirty);
            		}
            		else {
HXLINE(1230)			_hx_tmp = true;
            		}
HXDLIN(1230)		if (_hx_tmp) {
HXLINE(1231)			return this->framePixels;
            		}
HXLINE(1235)		bool _hx_tmp1;
HXDLIN(1235)		if (::flixel::FlxG_obj::renderTile) {
HXLINE(1235)			_hx_tmp1 = ::hx::IsNotNull( this->_frameGraphic );
            		}
            		else {
HXLINE(1235)			_hx_tmp1 = false;
            		}
HXDLIN(1235)		if (_hx_tmp1) {
HXLINE(1237)			this->dirty = false;
HXLINE(1238)			return this->framePixels;
            		}
HXLINE(1241)		bool doFlipX = (this->flipX != this->_frame->flipX);
HXDLIN(1241)		bool doFlipX1;
HXDLIN(1241)		if (::hx::IsNotNull( this->animation->_curAnim )) {
HXLINE(1241)			doFlipX1 = (doFlipX != this->animation->_curAnim->flipX);
            		}
            		else {
HXLINE(1241)			doFlipX1 = doFlipX;
            		}
HXLINE(1242)		bool doFlipY = (this->flipY != this->_frame->flipY);
HXDLIN(1242)		bool doFlipY1;
HXDLIN(1242)		if (::hx::IsNotNull( this->animation->_curAnim )) {
HXLINE(1242)			doFlipY1 = (doFlipY != this->animation->_curAnim->flipY);
            		}
            		else {
HXLINE(1242)			doFlipY1 = doFlipY;
            		}
HXLINE(1244)		bool _hx_tmp2;
HXDLIN(1244)		bool _hx_tmp3;
HXDLIN(1244)		if (!(doFlipX1)) {
HXLINE(1244)			_hx_tmp3 = !(doFlipY1);
            		}
            		else {
HXLINE(1244)			_hx_tmp3 = false;
            		}
HXDLIN(1244)		if (_hx_tmp3) {
HXLINE(1244)			_hx_tmp2 = (this->_frame->type == 0);
            		}
            		else {
HXLINE(1244)			_hx_tmp2 = false;
            		}
HXDLIN(1244)		if (_hx_tmp2) {
HXLINE(1246)			this->framePixels = this->_frame->paint(this->framePixels,this->_flashPointZero,false,true);
            		}
            		else {
HXLINE(1250)			this->framePixels = this->_frame->paintRotatedAndFlipped(this->framePixels,this->_flashPointZero,0,doFlipX1,doFlipY1,false,true);
            		}
HXLINE(1253)		bool _hx_tmp4;
HXDLIN(1253)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE(1253)			_hx_tmp4 = this->hasColorTransform();
            		}
            		else {
HXLINE(1253)			_hx_tmp4 = false;
            		}
HXDLIN(1253)		if (_hx_tmp4) {
HXLINE(1255)			this->framePixels->colorTransform(this->_flashRect,this->colorTransform);
            		}
HXLINE(1258)		bool _hx_tmp5;
HXDLIN(1258)		if (::flixel::FlxG_obj::renderTile) {
HXLINE(1258)			_hx_tmp5 = this->useFramePixels;
            		}
            		else {
HXLINE(1258)			_hx_tmp5 = false;
            		}
HXDLIN(1258)		if (_hx_tmp5) {
HXLINE(1261)			this->_frameGraphic = ( ( ::flixel::graphics::FlxGraphic)(::flixel::util::FlxDestroyUtil_obj::destroy(this->_frameGraphic)) );
HXLINE(1262)			this->_frameGraphic = ::flixel::graphics::FlxGraphic_obj::fromBitmapData(this->framePixels,false,null(),false);
HXLINE(1263)			this->_frame = this->_frameGraphic->get_imageFrame()->get_frame()->copyTo(this->_frame);
            		}
HXLINE(1266)		this->dirty = false;
HXLINE(1267)		return this->framePixels;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxSprite_obj,updateFramePixels,return )

 ::flixel::math::FlxBasePoint FlxSprite_obj::getGraphicMidpoint( ::flixel::math::FlxBasePoint point){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1276_getGraphicMidpoint)
HXLINE(1277)		 ::flixel::math::FlxRect rect = this->getGraphicBounds(null());
HXLINE(1278)		point = rect->getMidpoint(point);
HXLINE(1279)		if (!(rect->_inPool)) {
HXLINE(1279)			rect->_inPool = true;
HXDLIN(1279)			rect->_weak = false;
HXDLIN(1279)			::flixel::math::FlxRect_obj::_pool->putUnsafe(rect);
            		}
HXLINE(1280)		return point;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSprite_obj,getGraphicMidpoint,return )

 ::flixel::math::FlxRect FlxSprite_obj::getGraphicBounds( ::flixel::math::FlxRect rect){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1292_getGraphicBounds)
HXLINE(1293)		if (::hx::IsNull( rect )) {
HXLINE(1294)			 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get().StaticCast<  ::flixel::math::FlxRect >();
HXDLIN(1294)			_this->x = ( (Float)(0) );
HXDLIN(1294)			_this->y = ( (Float)(0) );
HXDLIN(1294)			_this->width = ( (Float)(0) );
HXDLIN(1294)			_this->height = ( (Float)(0) );
HXDLIN(1294)			 ::flixel::math::FlxRect rect1 = _this;
HXDLIN(1294)			rect1->_inPool = false;
HXDLIN(1294)			rect = rect1;
            		}
HXLINE(1296)		{
HXLINE(1296)			rect->x = this->x;
HXDLIN(1296)			rect->y = this->y;
HXDLIN(1296)			rect->width = ((Float)0.0);
HXDLIN(1296)			rect->height = ((Float)0.0);
            		}
HXLINE(1297)		if (this->pixelPerfectPosition) {
HXLINE(1298)			rect->x = ( (Float)(::Math_obj::floor(rect->x)) );
HXDLIN(1298)			rect->y = ( (Float)(::Math_obj::floor(rect->y)) );
HXDLIN(1298)			rect->width = ( (Float)(::Math_obj::floor(rect->width)) );
HXDLIN(1298)			rect->height = ( (Float)(::Math_obj::floor(rect->height)) );
            		}
HXLINE(1300)		{
HXLINE(1300)			 ::flixel::math::FlxBasePoint this1 = this->_scaledOrigin;
HXDLIN(1300)			Float y = (this->origin->y * this->scale->y);
HXDLIN(1300)			this1->set_x((this->origin->x * this->scale->x));
HXDLIN(1300)			this1->set_y(y);
            		}
HXLINE(1301)		 ::flixel::math::FlxRect rect2 = rect;
HXDLIN(1301)		rect2->x = (rect2->x + ((this->origin->x - this->offset->x) - this->_scaledOrigin->x));
HXLINE(1302)		 ::flixel::math::FlxRect rect3 = rect;
HXDLIN(1302)		rect3->y = (rect3->y + ((this->origin->y - this->offset->y) - this->_scaledOrigin->y));
HXLINE(1303)		{
HXLINE(1303)			rect->width = (( (Float)(this->frameWidth) ) * this->scale->x);
HXDLIN(1303)			rect->height = (( (Float)(this->frameHeight) ) * this->scale->y);
            		}
HXLINE(1305)		if ((::hx::Mod(this->angle,360) != 0)) {
HXLINE(1306)			rect->getRotatedBounds(this->angle,this->_scaledOrigin,rect);
            		}
HXLINE(1308)		return rect;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSprite_obj,getGraphicBounds,return )

bool FlxSprite_obj::isOnScreen( ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1319_isOnScreen)
HXLINE(1320)		if (::hx::IsNull( camera )) {
HXLINE(1321)			camera = this->getDefaultCamera();
            		}
HXLINE(1323)		 ::flixel::math::FlxRect rect = this->getScreenBounds(this->_rect,camera);
HXDLIN(1323)		bool contained;
HXDLIN(1323)		bool contained1;
HXDLIN(1323)		bool contained2;
HXDLIN(1323)		if (((rect->x + rect->width) > camera->viewMarginX)) {
HXLINE(1323)			contained2 = (rect->x < (( (Float)(camera->width) ) - camera->viewMarginX));
            		}
            		else {
HXLINE(1323)			contained2 = false;
            		}
HXDLIN(1323)		if (contained2) {
HXLINE(1323)			contained1 = ((rect->y + rect->height) > camera->viewMarginY);
            		}
            		else {
HXLINE(1323)			contained1 = false;
            		}
HXDLIN(1323)		if (contained1) {
HXLINE(1323)			contained = (rect->y < (( (Float)(camera->height) ) - camera->viewMarginY));
            		}
            		else {
HXLINE(1323)			contained = false;
            		}
HXDLIN(1323)		if (rect->_weak) {
HXLINE(1323)			if (!(rect->_inPool)) {
HXLINE(1323)				rect->_inPool = true;
HXDLIN(1323)				rect->_weak = false;
HXDLIN(1323)				::flixel::math::FlxRect_obj::_pool->putUnsafe(rect);
            			}
            		}
HXDLIN(1323)		return contained;
            	}


bool FlxSprite_obj::isSimpleRender( ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1331_isSimpleRender)
HXLINE(1332)		if (::flixel::FlxG_obj::renderTile) {
HXLINE(1333)			return false;
            		}
HXLINE(1335)		return this->isSimpleRenderBlit(camera);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSprite_obj,isSimpleRender,return )

bool FlxSprite_obj::isSimpleRenderBlit( ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1347_isSimpleRenderBlit)
HXLINE(1348)		bool result;
HXDLIN(1348)		bool result1;
HXDLIN(1348)		bool result2;
HXDLIN(1348)		bool result3;
HXDLIN(1348)		if ((this->angle != 0)) {
HXLINE(1348)			result3 = (this->bakedRotationAngle > 0);
            		}
            		else {
HXLINE(1348)			result3 = true;
            		}
HXDLIN(1348)		if (result3) {
HXLINE(1348)			result2 = (this->scale->x == 1);
            		}
            		else {
HXLINE(1348)			result2 = false;
            		}
HXDLIN(1348)		if (result2) {
HXLINE(1348)			result1 = (this->scale->y == 1);
            		}
            		else {
HXLINE(1348)			result1 = false;
            		}
HXDLIN(1348)		if (result1) {
HXLINE(1348)			result = ::hx::IsNull( this->blend );
            		}
            		else {
HXLINE(1348)			result = false;
            		}
HXLINE(1349)		if (result) {
HXLINE(1349)			if (::hx::IsNotNull( camera )) {
HXLINE(1349)				result = this->isPixelPerfectRender(camera);
            			}
            			else {
HXLINE(1349)				result = ( (bool)(this->pixelPerfectRender) );
            			}
            		}
            		else {
HXLINE(1349)			result = false;
            		}
HXLINE(1350)		return result;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSprite_obj,isSimpleRenderBlit,return )

 ::flixel::math::FlxRect FlxSprite_obj::getRotatedBounds( ::flixel::math::FlxRect newRect){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1363_getRotatedBounds)
HXLINE(1364)		if (::hx::IsNull( newRect )) {
HXLINE(1365)			 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get().StaticCast<  ::flixel::math::FlxRect >();
HXDLIN(1365)			_this->x = ( (Float)(0) );
HXDLIN(1365)			_this->y = ( (Float)(0) );
HXDLIN(1365)			_this->width = ( (Float)(0) );
HXDLIN(1365)			_this->height = ( (Float)(0) );
HXDLIN(1365)			 ::flixel::math::FlxRect rect = _this;
HXDLIN(1365)			rect->_inPool = false;
HXDLIN(1365)			newRect = rect;
            		}
HXLINE(1367)		{
HXLINE(1367)			Float x = this->x;
HXDLIN(1367)			Float y = this->y;
HXDLIN(1367)			Float width = this->get_width();
HXDLIN(1367)			Float height = this->get_height();
HXDLIN(1367)			newRect->x = x;
HXDLIN(1367)			newRect->y = y;
HXDLIN(1367)			newRect->width = width;
HXDLIN(1367)			newRect->height = height;
            		}
HXLINE(1368)		return newRect->getRotatedBounds(this->angle,this->origin,newRect);
            	}


 ::flixel::math::FlxRect FlxSprite_obj::getScreenBounds( ::flixel::math::FlxRect newRect, ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1380_getScreenBounds)
HXLINE(1381)		if (::hx::IsNull( newRect )) {
HXLINE(1382)			 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get().StaticCast<  ::flixel::math::FlxRect >();
HXDLIN(1382)			_this->x = ( (Float)(0) );
HXDLIN(1382)			_this->y = ( (Float)(0) );
HXDLIN(1382)			_this->width = ( (Float)(0) );
HXDLIN(1382)			_this->height = ( (Float)(0) );
HXDLIN(1382)			 ::flixel::math::FlxRect rect = _this;
HXDLIN(1382)			rect->_inPool = false;
HXDLIN(1382)			newRect = rect;
            		}
HXLINE(1384)		if (::hx::IsNull( camera )) {
HXLINE(1385)			camera = this->getDefaultCamera();
            		}
HXLINE(1387)		{
HXLINE(1387)			newRect->x = this->x;
HXDLIN(1387)			newRect->y = this->y;
            		}
HXLINE(1388)		if (this->pixelPerfectPosition) {
HXLINE(1389)			newRect->x = ( (Float)(::Math_obj::floor(newRect->x)) );
HXDLIN(1389)			newRect->y = ( (Float)(::Math_obj::floor(newRect->y)) );
HXDLIN(1389)			newRect->width = ( (Float)(::Math_obj::floor(newRect->width)) );
HXDLIN(1389)			newRect->height = ( (Float)(::Math_obj::floor(newRect->height)) );
            		}
HXLINE(1390)		{
HXLINE(1390)			 ::flixel::math::FlxBasePoint this1 = this->_scaledOrigin;
HXDLIN(1390)			Float y = (this->origin->y * this->scale->y);
HXDLIN(1390)			this1->set_x((this->origin->x * this->scale->x));
HXDLIN(1390)			this1->set_y(y);
            		}
HXLINE(1391)		 ::flixel::math::FlxRect newRect1 = newRect;
HXDLIN(1391)		Float newRect2 = newRect1->x;
HXDLIN(1391)		Float _hx_tmp = (( (Float)(-(::Std_obj::_hx_int((camera->scroll->x * this->scrollFactor->x)))) ) - this->offset->x);
HXDLIN(1391)		newRect1->x = (newRect2 + ((_hx_tmp + this->origin->x) - this->_scaledOrigin->x));
HXLINE(1392)		 ::flixel::math::FlxRect newRect3 = newRect;
HXDLIN(1392)		Float newRect4 = newRect3->y;
HXDLIN(1392)		Float _hx_tmp1 = (( (Float)(-(::Std_obj::_hx_int((camera->scroll->y * this->scrollFactor->y)))) ) - this->offset->y);
HXDLIN(1392)		newRect3->y = (newRect4 + ((_hx_tmp1 + this->origin->y) - this->_scaledOrigin->y));
HXLINE(1393)		if (this->isPixelPerfectRender(camera)) {
HXLINE(1394)			newRect->x = ( (Float)(::Math_obj::floor(newRect->x)) );
HXDLIN(1394)			newRect->y = ( (Float)(::Math_obj::floor(newRect->y)) );
HXDLIN(1394)			newRect->width = ( (Float)(::Math_obj::floor(newRect->width)) );
HXDLIN(1394)			newRect->height = ( (Float)(::Math_obj::floor(newRect->height)) );
            		}
HXLINE(1395)		{
HXLINE(1395)			Float Height = (( (Float)(this->frameHeight) ) * ::Math_obj::abs(this->scale->y));
HXDLIN(1395)			newRect->width = (( (Float)(this->frameWidth) ) * ::Math_obj::abs(this->scale->x));
HXDLIN(1395)			newRect->height = Height;
            		}
HXLINE(1396)		return newRect->getRotatedBounds(this->angle,this->_scaledOrigin,newRect);
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxSprite_obj,getScreenBounds,return )

void FlxSprite_obj::setFacingFlip(int Direction,bool FlipX,bool FlipY){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1411_setFacingFlip)
HXDLIN(1411)		this->_facingFlip->set(Direction, ::Dynamic(::hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("x",78,00,00,00),FlipX)
            			->setFixed(1,HX_("y",79,00,00,00),FlipY)));
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxSprite_obj,setFacingFlip,(void))

 ::flixel::FlxSprite FlxSprite_obj::setFrames( ::flixel::graphics::frames::FlxFramesCollection Frames,::hx::Null< bool >  __o_saveAnimations){
            		bool saveAnimations = __o_saveAnimations.Default(true);
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1423_setFrames)
HXLINE(1424)		if (saveAnimations) {
HXLINE(1426)			 ::haxe::ds::StringMap animations = this->animation->_animations;
HXLINE(1427)			bool reverse = false;
HXLINE(1428)			int index = 0;
HXLINE(1429)			int frameIndex = this->animation->frameIndex;
HXLINE(1430)			::String currName = null();
HXLINE(1432)			if (::hx::IsNotNull( this->animation->_curAnim )) {
HXLINE(1434)				reverse = this->animation->_curAnim->reversed;
HXLINE(1435)				index = this->animation->_curAnim->curFrame;
HXLINE(1436)				currName = this->animation->_curAnim->name;
            			}
HXLINE(1439)			this->animation->_animations = null();
HXLINE(1440)			this->set_frames(Frames);
HXLINE(1441)			this->set_frame(this->frames->frames->__get(frameIndex).StaticCast<  ::flixel::graphics::frames::FlxFrame >());
HXLINE(1442)			this->animation->_animations = animations;
HXLINE(1444)			if (::hx::IsNotNull( currName )) {
HXLINE(1446)				this->animation->play(currName,false,reverse,index);
            			}
            		}
            		else {
HXLINE(1451)			this->set_frames(Frames);
            		}
HXLINE(1454)		return ::hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxSprite_obj,setFrames,return )

 ::openfl::display::BitmapData FlxSprite_obj::get_pixels(){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1460_get_pixels)
HXDLIN(1460)		if (::hx::IsNull( this->graphic )) {
HXDLIN(1460)			return null();
            		}
            		else {
HXDLIN(1460)			return this->graphic->bitmap;
            		}
HXDLIN(1460)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxSprite_obj,get_pixels,return )

 ::openfl::display::BitmapData FlxSprite_obj::set_pixels( ::openfl::display::BitmapData Pixels){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1465_set_pixels)
HXLINE(1466)		::String key = ::flixel::FlxG_obj::bitmap->findKeyForBitmap(Pixels);
HXLINE(1468)		if (::hx::IsNull( key )) {
HXLINE(1470)			key = ::flixel::FlxG_obj::bitmap->getUniqueKey(null());
HXLINE(1471)			this->set_graphic(::flixel::FlxG_obj::bitmap->add(Pixels,false,key));
            		}
            		else {
HXLINE(1475)			this->set_graphic(( ( ::flixel::graphics::FlxGraphic)(::flixel::FlxG_obj::bitmap->_cache->get(key)) ));
            		}
HXLINE(1478)		this->set_frames(this->graphic->get_imageFrame());
HXLINE(1479)		return Pixels;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSprite_obj,set_pixels,return )

 ::flixel::graphics::frames::FlxFrame FlxSprite_obj::set_frame( ::flixel::graphics::frames::FlxFrame Value){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1484_set_frame)
HXLINE(1485)		this->frame = Value;
HXLINE(1486)		if (::hx::IsNotNull( this->frame )) {
HXLINE(1488)			{
HXLINE(1488)				if (::hx::IsNotNull( this->frame )) {
HXLINE(1488)					this->frameWidth = ::Std_obj::_hx_int(this->frame->sourceSize->x);
HXDLIN(1488)					this->frameHeight = ::Std_obj::_hx_int(this->frame->sourceSize->y);
            				}
HXDLIN(1488)				{
HXLINE(1488)					 ::flixel::math::FlxBasePoint this1 = this->_halfSize;
HXDLIN(1488)					Float y = (((Float)0.5) * ( (Float)(this->frameHeight) ));
HXDLIN(1488)					this1->set_x((((Float)0.5) * ( (Float)(this->frameWidth) )));
HXDLIN(1488)					this1->set_y(y);
            				}
HXDLIN(1488)				{
HXLINE(1488)					this->_flashRect->x = ( (Float)(0) );
HXDLIN(1488)					this->_flashRect->y = ( (Float)(0) );
HXDLIN(1488)					this->_flashRect->width = ( (Float)(this->frameWidth) );
HXDLIN(1488)					this->_flashRect->height = ( (Float)(this->frameHeight) );
            				}
            			}
HXLINE(1489)			this->dirty = true;
            		}
            		else {
HXLINE(1491)			bool _hx_tmp;
HXDLIN(1491)			bool _hx_tmp1;
HXDLIN(1491)			if (::hx::IsNotNull( this->frames )) {
HXLINE(1491)				_hx_tmp1 = ::hx::IsNotNull( this->frames->frames );
            			}
            			else {
HXLINE(1491)				_hx_tmp1 = false;
            			}
HXDLIN(1491)			if (_hx_tmp1) {
HXLINE(1491)				_hx_tmp = (this->get_numFrames() > 0);
            			}
            			else {
HXLINE(1491)				_hx_tmp = false;
            			}
HXDLIN(1491)			if (_hx_tmp) {
HXLINE(1493)				this->frame = this->frames->frames->__get(0).StaticCast<  ::flixel::graphics::frames::FlxFrame >();
HXLINE(1494)				this->dirty = true;
            			}
            			else {
HXLINE(1498)				return null();
            			}
            		}
HXLINE(1501)		if (::flixel::FlxG_obj::renderTile) {
HXLINE(1503)			this->_frameGraphic = ( ( ::flixel::graphics::FlxGraphic)(::flixel::util::FlxDestroyUtil_obj::destroy(this->_frameGraphic)) );
            		}
HXLINE(1506)		this->_frame = this->frame->copyTo(this->_frame);
HXLINE(1507)		if (::hx::IsNotNull( this->clipRect )) {
HXLINE(1508)			this->_frame->clip(this->clipRect);
            		}
HXLINE(1510)		return this->frame;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSprite_obj,set_frame,return )

int FlxSprite_obj::set_facing(int Direction){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1515_set_facing)
HXLINE(1516)		 ::Dynamic flip = this->_facingFlip->get(Direction);
HXLINE(1517)		if (::hx::IsNotNull( flip )) {
HXLINE(1519)			this->set_flipX(( (bool)(flip->__Field(HX_("x",78,00,00,00),::hx::paccDynamic)) ));
HXLINE(1520)			this->set_flipY(( (bool)(flip->__Field(HX_("y",79,00,00,00),::hx::paccDynamic)) ));
            		}
HXLINE(1523)		return (this->facing = Direction);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSprite_obj,set_facing,return )

Float FlxSprite_obj::set_alpha(Float value){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1528_set_alpha)
HXLINE(1529)		Float lowerBound;
HXDLIN(1529)		if ((value < 0)) {
HXLINE(1529)			lowerBound = ( (Float)(0) );
            		}
            		else {
HXLINE(1529)			lowerBound = value;
            		}
HXDLIN(1529)		if ((lowerBound > 1)) {
HXLINE(1529)			value = ( (Float)(1) );
            		}
            		else {
HXLINE(1529)			value = lowerBound;
            		}
HXLINE(1530)		if ((this->alpha == value)) {
HXLINE(1531)			return value;
            		}
HXLINE(1533)		this->alpha = value;
HXLINE(1534)		this->updateColorTransform();
HXLINE(1535)		return this->alpha;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSprite_obj,set_alpha,return )

int FlxSprite_obj::set_color(int value){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1540_set_color)
HXLINE(1541)		if ((this->color == value)) {
HXLINE(1542)			return value;
            		}
HXLINE(1544)		this->color = value;
HXLINE(1545)		this->updateColorTransform();
HXLINE(1546)		return this->color;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSprite_obj,set_color,return )

Float FlxSprite_obj::set_angle(Float Value){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1551_set_angle)
HXLINE(1552)		bool newAngle = (this->angle != Value);
HXLINE(1553)		Float ret = this->super::set_angle(Value);
HXLINE(1554)		if (newAngle) {
HXLINE(1556)			this->_angleChanged = true;
HXLINE(1557)			this->animation->update(( (Float)(0) ));
            		}
HXLINE(1559)		return ret;
            	}


void FlxSprite_obj::updateTrig(){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1565_updateTrig)
HXDLIN(1565)		if (this->_angleChanged) {
HXLINE(1567)			Float radians = (this->angle * (::Math_obj::PI / ( (Float)(180) )));
HXLINE(1568)			this->_sinAngle = ::Math_obj::sin(radians);
HXLINE(1569)			this->_cosAngle = ::Math_obj::cos(radians);
HXLINE(1570)			this->_angleChanged = false;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxSprite_obj,updateTrig,(void))

 ::Dynamic FlxSprite_obj::set_blend( ::Dynamic Value){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1577_set_blend)
HXDLIN(1577)		return (this->blend = Value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSprite_obj,set_blend,return )

 ::flixel::graphics::FlxGraphic FlxSprite_obj::set_graphic( ::flixel::graphics::FlxGraphic value){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1586_set_graphic)
HXLINE(1587)		if (::hx::IsInstanceNotEq( this->graphic,value )) {
HXLINE(1590)			if (::hx::IsNotNull( value )) {
HXLINE(1591)				value->incrementUseCount();
            			}
HXLINE(1594)			if (::hx::IsNotNull( this->graphic )) {
HXLINE(1595)				this->graphic->decrementUseCount();
            			}
HXLINE(1597)			this->graphic = value;
            		}
HXLINE(1600)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSprite_obj,set_graphic,return )

 ::flixel::math::FlxRect FlxSprite_obj::set_clipRect( ::flixel::math::FlxRect rect){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1605_set_clipRect)
HXLINE(1606)		if (::hx::IsNotNull( rect )) {
HXLINE(1607)			rect->x = ( (Float)(::Math_obj::round(rect->x)) );
HXDLIN(1607)			rect->y = ( (Float)(::Math_obj::round(rect->y)) );
HXDLIN(1607)			rect->width = ( (Float)(::Math_obj::round(rect->width)) );
HXDLIN(1607)			rect->height = ( (Float)(::Math_obj::round(rect->height)) );
HXDLIN(1607)			this->clipRect = rect;
            		}
            		else {
HXLINE(1609)			this->clipRect = null();
            		}
HXLINE(1611)		return rect;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSprite_obj,set_clipRect,return )

 ::flixel::graphics::frames::FlxFramesCollection FlxSprite_obj::set_frames( ::flixel::graphics::frames::FlxFramesCollection Frames){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1623_set_frames)
HXLINE(1624)		if (::hx::IsNotNull( this->animation )) {
HXLINE(1626)			this->animation->destroyAnimations();
            		}
HXLINE(1629)		if (::hx::IsNotNull( Frames )) {
HXLINE(1631)			this->set_graphic(Frames->parent);
HXLINE(1632)			this->frames = Frames;
HXLINE(1633)			this->set_frame(this->frames->frames->__get(0).StaticCast<  ::flixel::graphics::frames::FlxFrame >());
HXLINE(1634)			this->resetHelpers();
HXLINE(1635)			this->bakedRotationAngle = ( (Float)(0) );
HXLINE(1636)			this->animation->set_frameIndex(0);
HXLINE(1637)			this->graphicLoaded();
            		}
            		else {
HXLINE(1641)			this->frames = null();
HXLINE(1642)			this->set_frame(null());
HXLINE(1643)			this->set_graphic(null());
            		}
HXLINE(1646)		return Frames;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSprite_obj,set_frames,return )

int FlxSprite_obj::get_numFrames(){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1649_get_numFrames)
HXLINE(1650)		if (::hx::IsNotNull( this->frames )) {
HXLINE(1651)			return this->frames->frames->length;
            		}
HXLINE(1653)		return 0;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxSprite_obj,get_numFrames,return )

bool FlxSprite_obj::set_flipX(bool Value){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1658_set_flipX)
HXLINE(1659)		if (::flixel::FlxG_obj::renderTile) {
HXLINE(1661)			int _hx_tmp;
HXDLIN(1661)			if (Value) {
HXLINE(1661)				_hx_tmp = -1;
            			}
            			else {
HXLINE(1661)				_hx_tmp = 1;
            			}
HXDLIN(1661)			this->_facingHorizontalMult = _hx_tmp;
            		}
HXLINE(1663)		bool _hx_tmp1;
HXDLIN(1663)		if ((this->flipX == Value)) {
HXLINE(1663)			_hx_tmp1 = this->dirty;
            		}
            		else {
HXLINE(1663)			_hx_tmp1 = true;
            		}
HXDLIN(1663)		this->dirty = _hx_tmp1;
HXLINE(1664)		return (this->flipX = Value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSprite_obj,set_flipX,return )

bool FlxSprite_obj::set_flipY(bool Value){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1669_set_flipY)
HXLINE(1670)		if (::flixel::FlxG_obj::renderTile) {
HXLINE(1672)			int _hx_tmp;
HXDLIN(1672)			if (Value) {
HXLINE(1672)				_hx_tmp = -1;
            			}
            			else {
HXLINE(1672)				_hx_tmp = 1;
            			}
HXDLIN(1672)			this->_facingVerticalMult = _hx_tmp;
            		}
HXLINE(1674)		bool _hx_tmp1;
HXDLIN(1674)		if ((this->flipY == Value)) {
HXLINE(1674)			_hx_tmp1 = this->dirty;
            		}
            		else {
HXLINE(1674)			_hx_tmp1 = true;
            		}
HXDLIN(1674)		this->dirty = _hx_tmp1;
HXLINE(1675)		return (this->flipY = Value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSprite_obj,set_flipY,return )

bool FlxSprite_obj::set_antialiasing(bool value){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1681_set_antialiasing)
HXDLIN(1681)		return (this->antialiasing = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSprite_obj,set_antialiasing,return )

bool FlxSprite_obj::set_useFramePixels(bool value){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1687_set_useFramePixels)
HXDLIN(1687)		if (::flixel::FlxG_obj::renderTile) {
HXLINE(1689)			if ((value != this->useFramePixels)) {
HXLINE(1691)				this->useFramePixels = value;
HXLINE(1692)				this->set_frame(this->frame);
HXLINE(1694)				if (value) {
HXLINE(1696)					this->updateFramePixels();
            				}
            			}
HXLINE(1700)			return value;
            		}
            		else {
HXLINE(1704)			this->useFramePixels = true;
HXLINE(1705)			return true;
            		}
HXLINE(1687)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxSprite_obj,set_useFramePixels,return )

bool FlxSprite_obj::checkFlipX(){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1711_checkFlipX)
HXLINE(1712)		bool doFlipX = (this->flipX != this->_frame->flipX);
HXLINE(1713)		if (::hx::IsNotNull( this->animation->_curAnim )) {
HXLINE(1715)			return (doFlipX != this->animation->_curAnim->flipX);
            		}
HXLINE(1717)		return doFlipX;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxSprite_obj,checkFlipX,return )

bool FlxSprite_obj::checkFlipY(){
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_1722_checkFlipY)
HXLINE(1723)		bool doFlipY = (this->flipY != this->_frame->flipY);
HXLINE(1724)		if (::hx::IsNotNull( this->animation->_curAnim )) {
HXLINE(1726)			return (doFlipY != this->animation->_curAnim->flipY);
            		}
HXLINE(1728)		return doFlipY;
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxSprite_obj,checkFlipY,return )

bool FlxSprite_obj::defaultAntialiasing;


::hx::ObjectPtr< FlxSprite_obj > FlxSprite_obj::__new( ::Dynamic __o_X, ::Dynamic __o_Y, ::Dynamic SimpleGraphic) {
	::hx::ObjectPtr< FlxSprite_obj > __this = new FlxSprite_obj();
	__this->__construct(__o_X,__o_Y,SimpleGraphic);
	return __this;
}

::hx::ObjectPtr< FlxSprite_obj > FlxSprite_obj::__alloc(::hx::Ctx *_hx_ctx, ::Dynamic __o_X, ::Dynamic __o_Y, ::Dynamic SimpleGraphic) {
	FlxSprite_obj *__this = (FlxSprite_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(FlxSprite_obj), true, "flixel.FlxSprite"));
	*(void **)__this = FlxSprite_obj::_hx_vtable;
	__this->__construct(__o_X,__o_Y,SimpleGraphic);
	return __this;
}

FlxSprite_obj::FlxSprite_obj()
{
}

void FlxSprite_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(FlxSprite);
	HX_MARK_MEMBER_NAME(animation,"animation");
	HX_MARK_MEMBER_NAME(framePixels,"framePixels");
	HX_MARK_MEMBER_NAME(useFramePixels,"useFramePixels");
	HX_MARK_MEMBER_NAME(antialiasing,"antialiasing");
	HX_MARK_MEMBER_NAME(dirty,"dirty");
	HX_MARK_MEMBER_NAME(frame,"frame");
	HX_MARK_MEMBER_NAME(frameWidth,"frameWidth");
	HX_MARK_MEMBER_NAME(frameHeight,"frameHeight");
	HX_MARK_MEMBER_NAME(frames,"frames");
	HX_MARK_MEMBER_NAME(graphic,"graphic");
	HX_MARK_MEMBER_NAME(bakedRotationAngle,"bakedRotationAngle");
	HX_MARK_MEMBER_NAME(alpha,"alpha");
	HX_MARK_MEMBER_NAME(facing,"facing");
	HX_MARK_MEMBER_NAME(flipX,"flipX");
	HX_MARK_MEMBER_NAME(flipY,"flipY");
	HX_MARK_MEMBER_NAME(origin,"origin");
	HX_MARK_MEMBER_NAME(offset,"offset");
	HX_MARK_MEMBER_NAME(scale,"scale");
	HX_MARK_MEMBER_NAME(blend,"blend");
	HX_MARK_MEMBER_NAME(color,"color");
	HX_MARK_MEMBER_NAME(colorTransform,"colorTransform");
	HX_MARK_MEMBER_NAME(useColorTransform,"useColorTransform");
	HX_MARK_MEMBER_NAME(clipRect,"clipRect");
	HX_MARK_MEMBER_NAME(_lastClipRect,"_lastClipRect");
	HX_MARK_MEMBER_NAME(shader,"shader");
	HX_MARK_MEMBER_NAME(_frame,"_frame");
	HX_MARK_MEMBER_NAME(_frameGraphic,"_frameGraphic");
	HX_MARK_MEMBER_NAME(_facingHorizontalMult,"_facingHorizontalMult");
	HX_MARK_MEMBER_NAME(_facingVerticalMult,"_facingVerticalMult");
	HX_MARK_MEMBER_NAME(_flashPoint,"_flashPoint");
	HX_MARK_MEMBER_NAME(_flashRect,"_flashRect");
	HX_MARK_MEMBER_NAME(_flashRect2,"_flashRect2");
	HX_MARK_MEMBER_NAME(_flashPointZero,"_flashPointZero");
	HX_MARK_MEMBER_NAME(_matrix,"_matrix");
	HX_MARK_MEMBER_NAME(_halfSize,"_halfSize");
	HX_MARK_MEMBER_NAME(_scaledOrigin,"_scaledOrigin");
	HX_MARK_MEMBER_NAME(_sinAngle,"_sinAngle");
	HX_MARK_MEMBER_NAME(_cosAngle,"_cosAngle");
	HX_MARK_MEMBER_NAME(_angleChanged,"_angleChanged");
	HX_MARK_MEMBER_NAME(_facingFlip,"_facingFlip");
	 ::flixel::FlxObject_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void FlxSprite_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(animation,"animation");
	HX_VISIT_MEMBER_NAME(framePixels,"framePixels");
	HX_VISIT_MEMBER_NAME(useFramePixels,"useFramePixels");
	HX_VISIT_MEMBER_NAME(antialiasing,"antialiasing");
	HX_VISIT_MEMBER_NAME(dirty,"dirty");
	HX_VISIT_MEMBER_NAME(frame,"frame");
	HX_VISIT_MEMBER_NAME(frameWidth,"frameWidth");
	HX_VISIT_MEMBER_NAME(frameHeight,"frameHeight");
	HX_VISIT_MEMBER_NAME(frames,"frames");
	HX_VISIT_MEMBER_NAME(graphic,"graphic");
	HX_VISIT_MEMBER_NAME(bakedRotationAngle,"bakedRotationAngle");
	HX_VISIT_MEMBER_NAME(alpha,"alpha");
	HX_VISIT_MEMBER_NAME(facing,"facing");
	HX_VISIT_MEMBER_NAME(flipX,"flipX");
	HX_VISIT_MEMBER_NAME(flipY,"flipY");
	HX_VISIT_MEMBER_NAME(origin,"origin");
	HX_VISIT_MEMBER_NAME(offset,"offset");
	HX_VISIT_MEMBER_NAME(scale,"scale");
	HX_VISIT_MEMBER_NAME(blend,"blend");
	HX_VISIT_MEMBER_NAME(color,"color");
	HX_VISIT_MEMBER_NAME(colorTransform,"colorTransform");
	HX_VISIT_MEMBER_NAME(useColorTransform,"useColorTransform");
	HX_VISIT_MEMBER_NAME(clipRect,"clipRect");
	HX_VISIT_MEMBER_NAME(_lastClipRect,"_lastClipRect");
	HX_VISIT_MEMBER_NAME(shader,"shader");
	HX_VISIT_MEMBER_NAME(_frame,"_frame");
	HX_VISIT_MEMBER_NAME(_frameGraphic,"_frameGraphic");
	HX_VISIT_MEMBER_NAME(_facingHorizontalMult,"_facingHorizontalMult");
	HX_VISIT_MEMBER_NAME(_facingVerticalMult,"_facingVerticalMult");
	HX_VISIT_MEMBER_NAME(_flashPoint,"_flashPoint");
	HX_VISIT_MEMBER_NAME(_flashRect,"_flashRect");
	HX_VISIT_MEMBER_NAME(_flashRect2,"_flashRect2");
	HX_VISIT_MEMBER_NAME(_flashPointZero,"_flashPointZero");
	HX_VISIT_MEMBER_NAME(_matrix,"_matrix");
	HX_VISIT_MEMBER_NAME(_halfSize,"_halfSize");
	HX_VISIT_MEMBER_NAME(_scaledOrigin,"_scaledOrigin");
	HX_VISIT_MEMBER_NAME(_sinAngle,"_sinAngle");
	HX_VISIT_MEMBER_NAME(_cosAngle,"_cosAngle");
	HX_VISIT_MEMBER_NAME(_angleChanged,"_angleChanged");
	HX_VISIT_MEMBER_NAME(_facingFlip,"_facingFlip");
	 ::flixel::FlxObject_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val FlxSprite_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"draw") ) { return ::hx::Val( draw_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"dirty") ) { return ::hx::Val( dirty ); }
		if (HX_FIELD_EQ(inName,"frame") ) { return ::hx::Val( frame ); }
		if (HX_FIELD_EQ(inName,"alpha") ) { return ::hx::Val( alpha ); }
		if (HX_FIELD_EQ(inName,"flipX") ) { return ::hx::Val( flipX ); }
		if (HX_FIELD_EQ(inName,"flipY") ) { return ::hx::Val( flipY ); }
		if (HX_FIELD_EQ(inName,"scale") ) { return ::hx::Val( scale ); }
		if (HX_FIELD_EQ(inName,"blend") ) { return ::hx::Val( blend ); }
		if (HX_FIELD_EQ(inName,"color") ) { return ::hx::Val( color ); }
		if (HX_FIELD_EQ(inName,"clone") ) { return ::hx::Val( clone_dyn() ); }
		if (HX_FIELD_EQ(inName,"stamp") ) { return ::hx::Val( stamp_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"pixels") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_pixels() ); }
		if (HX_FIELD_EQ(inName,"frames") ) { return ::hx::Val( frames ); }
		if (HX_FIELD_EQ(inName,"facing") ) { return ::hx::Val( facing ); }
		if (HX_FIELD_EQ(inName,"origin") ) { return ::hx::Val( origin ); }
		if (HX_FIELD_EQ(inName,"offset") ) { return ::hx::Val( offset ); }
		if (HX_FIELD_EQ(inName,"shader") ) { return ::hx::Val( shader ); }
		if (HX_FIELD_EQ(inName,"_frame") ) { return ::hx::Val( _frame ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"graphic") ) { return ::hx::Val( graphic ); }
		if (HX_FIELD_EQ(inName,"_matrix") ) { return ::hx::Val( _matrix ); }
		if (HX_FIELD_EQ(inName,"destroy") ) { return ::hx::Val( destroy_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"clipRect") ) { return ::hx::Val( clipRect ); }
		if (HX_FIELD_EQ(inName,"initVars") ) { return ::hx::Val( initVars_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"animation") ) { return ::hx::Val( animation ); }
		if (HX_FIELD_EQ(inName,"numFrames") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_numFrames() ); }
		if (HX_FIELD_EQ(inName,"_halfSize") ) { return ::hx::Val( _halfSize ); }
		if (HX_FIELD_EQ(inName,"_sinAngle") ) { return ::hx::Val( _sinAngle ); }
		if (HX_FIELD_EQ(inName,"_cosAngle") ) { return ::hx::Val( _cosAngle ); }
		if (HX_FIELD_EQ(inName,"resetSize") ) { return ::hx::Val( resetSize_dyn() ); }
		if (HX_FIELD_EQ(inName,"drawFrame") ) { return ::hx::Val( drawFrame_dyn() ); }
		if (HX_FIELD_EQ(inName,"calcFrame") ) { return ::hx::Val( calcFrame_dyn() ); }
		if (HX_FIELD_EQ(inName,"setFrames") ) { return ::hx::Val( setFrames_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_frame") ) { return ::hx::Val( set_frame_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_alpha") ) { return ::hx::Val( set_alpha_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_color") ) { return ::hx::Val( set_color_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_angle") ) { return ::hx::Val( set_angle_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_blend") ) { return ::hx::Val( set_blend_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_flipX") ) { return ::hx::Val( set_flipX_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_flipY") ) { return ::hx::Val( set_flipY_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"frameWidth") ) { return ::hx::Val( frameWidth ); }
		if (HX_FIELD_EQ(inName,"_flashRect") ) { return ::hx::Val( _flashRect ); }
		if (HX_FIELD_EQ(inName,"resetFrame") ) { return ::hx::Val( resetFrame_dyn() ); }
		if (HX_FIELD_EQ(inName,"drawSimple") ) { return ::hx::Val( drawSimple_dyn() ); }
		if (HX_FIELD_EQ(inName,"getPixelAt") ) { return ::hx::Val( getPixelAt_dyn() ); }
		if (HX_FIELD_EQ(inName,"isOnScreen") ) { return ::hx::Val( isOnScreen_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_pixels") ) { return ::hx::Val( get_pixels_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_pixels") ) { return ::hx::Val( set_pixels_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_facing") ) { return ::hx::Val( set_facing_dyn() ); }
		if (HX_FIELD_EQ(inName,"updateTrig") ) { return ::hx::Val( updateTrig_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_frames") ) { return ::hx::Val( set_frames_dyn() ); }
		if (HX_FIELD_EQ(inName,"checkFlipX") ) { return ::hx::Val( checkFlipX_dyn() ); }
		if (HX_FIELD_EQ(inName,"checkFlipY") ) { return ::hx::Val( checkFlipY_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"framePixels") ) { return ::hx::Val( framePixels ); }
		if (HX_FIELD_EQ(inName,"frameHeight") ) { return ::hx::Val( frameHeight ); }
		if (HX_FIELD_EQ(inName,"_flashPoint") ) { return ::hx::Val( _flashPoint ); }
		if (HX_FIELD_EQ(inName,"_flashRect2") ) { return ::hx::Val( _flashRect2 ); }
		if (HX_FIELD_EQ(inName,"_facingFlip") ) { return ::hx::Val( _facingFlip ); }
		if (HX_FIELD_EQ(inName,"loadGraphic") ) { return ::hx::Val( loadGraphic_dyn() ); }
		if (HX_FIELD_EQ(inName,"makeGraphic") ) { return ::hx::Val( makeGraphic_dyn() ); }
		if (HX_FIELD_EQ(inName,"drawComplex") ) { return ::hx::Val( drawComplex_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_graphic") ) { return ::hx::Val( set_graphic_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"antialiasing") ) { return ::hx::Val( antialiasing ); }
		if (HX_FIELD_EQ(inName,"updateHitbox") ) { return ::hx::Val( updateHitbox_dyn() ); }
		if (HX_FIELD_EQ(inName,"resetHelpers") ) { return ::hx::Val( resetHelpers_dyn() ); }
		if (HX_FIELD_EQ(inName,"centerOrigin") ) { return ::hx::Val( centerOrigin_dyn() ); }
		if (HX_FIELD_EQ(inName,"replaceColor") ) { return ::hx::Val( replaceColor_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_clipRect") ) { return ::hx::Val( set_clipRect_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"_lastClipRect") ) { return ::hx::Val( _lastClipRect ); }
		if (HX_FIELD_EQ(inName,"_frameGraphic") ) { return ::hx::Val( _frameGraphic ); }
		if (HX_FIELD_EQ(inName,"_scaledOrigin") ) { return ::hx::Val( _scaledOrigin ); }
		if (HX_FIELD_EQ(inName,"_angleChanged") ) { return ::hx::Val( _angleChanged ); }
		if (HX_FIELD_EQ(inName,"graphicLoaded") ) { return ::hx::Val( graphicLoaded_dyn() ); }
		if (HX_FIELD_EQ(inName,"checkClipRect") ) { return ::hx::Val( checkClipRect_dyn() ); }
		if (HX_FIELD_EQ(inName,"centerOffsets") ) { return ::hx::Val( centerOffsets_dyn() ); }
		if (HX_FIELD_EQ(inName,"setFacingFlip") ) { return ::hx::Val( setFacingFlip_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_numFrames") ) { return ::hx::Val( get_numFrames_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"useFramePixels") ) { return ::hx::Val( useFramePixels ); }
		if (HX_FIELD_EQ(inName,"colorTransform") ) { return ::hx::Val( colorTransform ); }
		if (HX_FIELD_EQ(inName,"resetFrameSize") ) { return ::hx::Val( resetFrameSize_dyn() ); }
		if (HX_FIELD_EQ(inName,"setGraphicSize") ) { return ::hx::Val( setGraphicSize_dyn() ); }
		if (HX_FIELD_EQ(inName,"isSimpleRender") ) { return ::hx::Val( isSimpleRender_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"_flashPointZero") ) { return ::hx::Val( _flashPointZero ); }
		if (HX_FIELD_EQ(inName,"updateAnimation") ) { return ::hx::Val( updateAnimation_dyn() ); }
		if (HX_FIELD_EQ(inName,"checkEmptyFrame") ) { return ::hx::Val( checkEmptyFrame_dyn() ); }
		if (HX_FIELD_EQ(inName,"getScreenBounds") ) { return ::hx::Val( getScreenBounds_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"loadRotatedFrame") ) { return ::hx::Val( loadRotatedFrame_dyn() ); }
		if (HX_FIELD_EQ(inName,"drawFrameComplex") ) { return ::hx::Val( drawFrameComplex_dyn() ); }
		if (HX_FIELD_EQ(inName,"getPixelAtScreen") ) { return ::hx::Val( getPixelAtScreen_dyn() ); }
		if (HX_FIELD_EQ(inName,"getGraphicBounds") ) { return ::hx::Val( getGraphicBounds_dyn() ); }
		if (HX_FIELD_EQ(inName,"getRotatedBounds") ) { return ::hx::Val( getRotatedBounds_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_antialiasing") ) { return ::hx::Val( set_antialiasing_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"useColorTransform") ) { return ::hx::Val( useColorTransform ); }
		if (HX_FIELD_EQ(inName,"setColorTransform") ) { return ::hx::Val( setColorTransform_dyn() ); }
		if (HX_FIELD_EQ(inName,"hasColorTransform") ) { return ::hx::Val( hasColorTransform_dyn() ); }
		if (HX_FIELD_EQ(inName,"updateFramePixels") ) { return ::hx::Val( updateFramePixels_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"bakedRotationAngle") ) { return ::hx::Val( bakedRotationAngle ); }
		if (HX_FIELD_EQ(inName,"loadRotatedGraphic") ) { return ::hx::Val( loadRotatedGraphic_dyn() ); }
		if (HX_FIELD_EQ(inName,"resetSizeFromFrame") ) { return ::hx::Val( resetSizeFromFrame_dyn() ); }
		if (HX_FIELD_EQ(inName,"pixelsOverlapPoint") ) { return ::hx::Val( pixelsOverlapPoint_dyn() ); }
		if (HX_FIELD_EQ(inName,"getGraphicMidpoint") ) { return ::hx::Val( getGraphicMidpoint_dyn() ); }
		if (HX_FIELD_EQ(inName,"isSimpleRenderBlit") ) { return ::hx::Val( isSimpleRenderBlit_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_useFramePixels") ) { return ::hx::Val( set_useFramePixels_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"_facingVerticalMult") ) { return ::hx::Val( _facingVerticalMult ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"updateColorTransform") ) { return ::hx::Val( updateColorTransform_dyn() ); }
		if (HX_FIELD_EQ(inName,"hasColorTransformRaw") ) { return ::hx::Val( hasColorTransformRaw_dyn() ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"_facingHorizontalMult") ) { return ::hx::Val( _facingHorizontalMult ); }
		if (HX_FIELD_EQ(inName,"loadGraphicFromSprite") ) { return ::hx::Val( loadGraphicFromSprite_dyn() ); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"transformWorldToPixels") ) { return ::hx::Val( transformWorldToPixels_dyn() ); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"transformScreenToPixels") ) { return ::hx::Val( transformScreenToPixels_dyn() ); }
		break;
	case 28:
		if (HX_FIELD_EQ(inName,"transformWorldToPixelsSimple") ) { return ::hx::Val( transformWorldToPixelsSimple_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool FlxSprite_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 19:
		if (HX_FIELD_EQ(inName,"defaultAntialiasing") ) { outValue = ( defaultAntialiasing ); return true; }
	}
	return false;
}

::hx::Val FlxSprite_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"dirty") ) { dirty=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"frame") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_frame(inValue.Cast<  ::flixel::graphics::frames::FlxFrame >()) );frame=inValue.Cast<  ::flixel::graphics::frames::FlxFrame >(); return inValue; }
		if (HX_FIELD_EQ(inName,"alpha") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_alpha(inValue.Cast< Float >()) );alpha=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"flipX") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_flipX(inValue.Cast< bool >()) );flipX=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"flipY") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_flipY(inValue.Cast< bool >()) );flipY=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"scale") ) { scale=inValue.Cast<  ::flixel::math::FlxBasePoint >(); return inValue; }
		if (HX_FIELD_EQ(inName,"blend") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_blend(inValue.Cast<  ::Dynamic >()) );blend=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"color") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_color(inValue.Cast< int >()) );color=inValue.Cast< int >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"pixels") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_pixels(inValue.Cast<  ::openfl::display::BitmapData >()) ); }
		if (HX_FIELD_EQ(inName,"frames") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_frames(inValue.Cast<  ::flixel::graphics::frames::FlxFramesCollection >()) );frames=inValue.Cast<  ::flixel::graphics::frames::FlxFramesCollection >(); return inValue; }
		if (HX_FIELD_EQ(inName,"facing") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_facing(inValue.Cast< int >()) );facing=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"origin") ) { origin=inValue.Cast<  ::flixel::math::FlxBasePoint >(); return inValue; }
		if (HX_FIELD_EQ(inName,"offset") ) { offset=inValue.Cast<  ::flixel::math::FlxBasePoint >(); return inValue; }
		if (HX_FIELD_EQ(inName,"shader") ) { shader=inValue.Cast<  ::flixel::graphics::tile::FlxGraphicsShader >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_frame") ) { _frame=inValue.Cast<  ::flixel::graphics::frames::FlxFrame >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"graphic") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_graphic(inValue.Cast<  ::flixel::graphics::FlxGraphic >()) );graphic=inValue.Cast<  ::flixel::graphics::FlxGraphic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_matrix") ) { _matrix=inValue.Cast<  ::flixel::math::FlxMatrix >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"clipRect") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_clipRect(inValue.Cast<  ::flixel::math::FlxRect >()) );clipRect=inValue.Cast<  ::flixel::math::FlxRect >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"animation") ) { animation=inValue.Cast<  ::flixel::animation::FlxAnimationController >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_halfSize") ) { _halfSize=inValue.Cast<  ::flixel::math::FlxBasePoint >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_sinAngle") ) { _sinAngle=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_cosAngle") ) { _cosAngle=inValue.Cast< Float >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"frameWidth") ) { frameWidth=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_flashRect") ) { _flashRect=inValue.Cast<  ::openfl::geom::Rectangle >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"framePixels") ) { framePixels=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
		if (HX_FIELD_EQ(inName,"frameHeight") ) { frameHeight=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_flashPoint") ) { _flashPoint=inValue.Cast<  ::openfl::geom::Point >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_flashRect2") ) { _flashRect2=inValue.Cast<  ::openfl::geom::Rectangle >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_facingFlip") ) { _facingFlip=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"antialiasing") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_antialiasing(inValue.Cast< bool >()) );antialiasing=inValue.Cast< bool >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"_lastClipRect") ) { _lastClipRect=inValue.Cast<  ::flixel::math::FlxRect >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_frameGraphic") ) { _frameGraphic=inValue.Cast<  ::flixel::graphics::FlxGraphic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_scaledOrigin") ) { _scaledOrigin=inValue.Cast<  ::flixel::math::FlxBasePoint >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_angleChanged") ) { _angleChanged=inValue.Cast< bool >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"useFramePixels") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_useFramePixels(inValue.Cast< bool >()) );useFramePixels=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"colorTransform") ) { colorTransform=inValue.Cast<  ::openfl::geom::ColorTransform >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"_flashPointZero") ) { _flashPointZero=inValue.Cast<  ::openfl::geom::Point >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"useColorTransform") ) { useColorTransform=inValue.Cast< bool >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"bakedRotationAngle") ) { bakedRotationAngle=inValue.Cast< Float >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"_facingVerticalMult") ) { _facingVerticalMult=inValue.Cast< int >(); return inValue; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"_facingHorizontalMult") ) { _facingHorizontalMult=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool FlxSprite_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 19:
		if (HX_FIELD_EQ(inName,"defaultAntialiasing") ) { defaultAntialiasing=ioValue.Cast< bool >(); return true; }
	}
	return false;
}

void FlxSprite_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("animation",04,ef,34,4b));
	outFields->push(HX_("framePixels",3a,bb,f1,6a));
	outFields->push(HX_("useFramePixels",33,0e,5a,8e));
	outFields->push(HX_("antialiasing",f4,16,b3,48));
	outFields->push(HX_("dirty",12,50,d0,d9));
	outFields->push(HX_("pixels",2d,ef,a9,8c));
	outFields->push(HX_("frame",2d,78,83,06));
	outFields->push(HX_("frameWidth",99,ea,88,ad));
	outFields->push(HX_("frameHeight",f4,d3,93,e0));
	outFields->push(HX_("numFrames",8c,fa,86,5d));
	outFields->push(HX_("frames",a6,af,85,ac));
	outFields->push(HX_("graphic",a8,5a,07,74));
	outFields->push(HX_("bakedRotationAngle",8a,d1,9c,9b));
	outFields->push(HX_("alpha",5e,a7,96,21));
	outFields->push(HX_("facing",1a,3f,05,e4));
	outFields->push(HX_("flipX",0b,45,92,02));
	outFields->push(HX_("flipY",0c,45,92,02));
	outFields->push(HX_("origin",e6,19,01,4b));
	outFields->push(HX_("offset",93,97,3f,60));
	outFields->push(HX_("scale",8a,ce,ce,78));
	outFields->push(HX_("blend",51,e8,f4,b4));
	outFields->push(HX_("color",63,71,5c,4a));
	outFields->push(HX_("colorTransform",89,d7,3f,ad));
	outFields->push(HX_("useColorTransform",30,e6,ec,72));
	outFields->push(HX_("clipRect",14,90,6a,58));
	outFields->push(HX_("_lastClipRect",69,2f,6b,9c));
	outFields->push(HX_("shader",25,bf,20,1d));
	outFields->push(HX_("_frame",6e,bf,6a,02));
	outFields->push(HX_("_frameGraphic",da,ac,00,f7));
	outFields->push(HX_("_facingHorizontalMult",8d,29,a1,51));
	outFields->push(HX_("_facingVerticalMult",df,11,0c,86));
	outFields->push(HX_("_flashPoint",9f,1d,2a,b7));
	outFields->push(HX_("_flashRect",b5,c2,f3,5d));
	outFields->push(HX_("_flashRect2",dd,9b,56,d7));
	outFields->push(HX_("_flashPointZero",67,14,7d,fb));
	outFields->push(HX_("_matrix",e0,47,3f,2a));
	outFields->push(HX_("_halfSize",73,43,4d,66));
	outFields->push(HX_("_scaledOrigin",ff,fa,5e,6a));
	outFields->push(HX_("_sinAngle",fa,54,de,b8));
	outFields->push(HX_("_cosAngle",6b,c9,00,1f));
	outFields->push(HX_("_angleChanged",40,98,5c,b2));
	outFields->push(HX_("_facingFlip",06,e0,9c,02));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo FlxSprite_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::flixel::animation::FlxAnimationController */ ,(int)offsetof(FlxSprite_obj,animation),HX_("animation",04,ef,34,4b)},
	{::hx::fsObject /*  ::openfl::display::BitmapData */ ,(int)offsetof(FlxSprite_obj,framePixels),HX_("framePixels",3a,bb,f1,6a)},
	{::hx::fsBool,(int)offsetof(FlxSprite_obj,useFramePixels),HX_("useFramePixels",33,0e,5a,8e)},
	{::hx::fsBool,(int)offsetof(FlxSprite_obj,antialiasing),HX_("antialiasing",f4,16,b3,48)},
	{::hx::fsBool,(int)offsetof(FlxSprite_obj,dirty),HX_("dirty",12,50,d0,d9)},
	{::hx::fsObject /*  ::flixel::graphics::frames::FlxFrame */ ,(int)offsetof(FlxSprite_obj,frame),HX_("frame",2d,78,83,06)},
	{::hx::fsInt,(int)offsetof(FlxSprite_obj,frameWidth),HX_("frameWidth",99,ea,88,ad)},
	{::hx::fsInt,(int)offsetof(FlxSprite_obj,frameHeight),HX_("frameHeight",f4,d3,93,e0)},
	{::hx::fsObject /*  ::flixel::graphics::frames::FlxFramesCollection */ ,(int)offsetof(FlxSprite_obj,frames),HX_("frames",a6,af,85,ac)},
	{::hx::fsObject /*  ::flixel::graphics::FlxGraphic */ ,(int)offsetof(FlxSprite_obj,graphic),HX_("graphic",a8,5a,07,74)},
	{::hx::fsFloat,(int)offsetof(FlxSprite_obj,bakedRotationAngle),HX_("bakedRotationAngle",8a,d1,9c,9b)},
	{::hx::fsFloat,(int)offsetof(FlxSprite_obj,alpha),HX_("alpha",5e,a7,96,21)},
	{::hx::fsInt,(int)offsetof(FlxSprite_obj,facing),HX_("facing",1a,3f,05,e4)},
	{::hx::fsBool,(int)offsetof(FlxSprite_obj,flipX),HX_("flipX",0b,45,92,02)},
	{::hx::fsBool,(int)offsetof(FlxSprite_obj,flipY),HX_("flipY",0c,45,92,02)},
	{::hx::fsObject /*  ::flixel::math::FlxBasePoint */ ,(int)offsetof(FlxSprite_obj,origin),HX_("origin",e6,19,01,4b)},
	{::hx::fsObject /*  ::flixel::math::FlxBasePoint */ ,(int)offsetof(FlxSprite_obj,offset),HX_("offset",93,97,3f,60)},
	{::hx::fsObject /*  ::flixel::math::FlxBasePoint */ ,(int)offsetof(FlxSprite_obj,scale),HX_("scale",8a,ce,ce,78)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(FlxSprite_obj,blend),HX_("blend",51,e8,f4,b4)},
	{::hx::fsInt,(int)offsetof(FlxSprite_obj,color),HX_("color",63,71,5c,4a)},
	{::hx::fsObject /*  ::openfl::geom::ColorTransform */ ,(int)offsetof(FlxSprite_obj,colorTransform),HX_("colorTransform",89,d7,3f,ad)},
	{::hx::fsBool,(int)offsetof(FlxSprite_obj,useColorTransform),HX_("useColorTransform",30,e6,ec,72)},
	{::hx::fsObject /*  ::flixel::math::FlxRect */ ,(int)offsetof(FlxSprite_obj,clipRect),HX_("clipRect",14,90,6a,58)},
	{::hx::fsObject /*  ::flixel::math::FlxRect */ ,(int)offsetof(FlxSprite_obj,_lastClipRect),HX_("_lastClipRect",69,2f,6b,9c)},
	{::hx::fsObject /*  ::flixel::graphics::tile::FlxGraphicsShader */ ,(int)offsetof(FlxSprite_obj,shader),HX_("shader",25,bf,20,1d)},
	{::hx::fsObject /*  ::flixel::graphics::frames::FlxFrame */ ,(int)offsetof(FlxSprite_obj,_frame),HX_("_frame",6e,bf,6a,02)},
	{::hx::fsObject /*  ::flixel::graphics::FlxGraphic */ ,(int)offsetof(FlxSprite_obj,_frameGraphic),HX_("_frameGraphic",da,ac,00,f7)},
	{::hx::fsInt,(int)offsetof(FlxSprite_obj,_facingHorizontalMult),HX_("_facingHorizontalMult",8d,29,a1,51)},
	{::hx::fsInt,(int)offsetof(FlxSprite_obj,_facingVerticalMult),HX_("_facingVerticalMult",df,11,0c,86)},
	{::hx::fsObject /*  ::openfl::geom::Point */ ,(int)offsetof(FlxSprite_obj,_flashPoint),HX_("_flashPoint",9f,1d,2a,b7)},
	{::hx::fsObject /*  ::openfl::geom::Rectangle */ ,(int)offsetof(FlxSprite_obj,_flashRect),HX_("_flashRect",b5,c2,f3,5d)},
	{::hx::fsObject /*  ::openfl::geom::Rectangle */ ,(int)offsetof(FlxSprite_obj,_flashRect2),HX_("_flashRect2",dd,9b,56,d7)},
	{::hx::fsObject /*  ::openfl::geom::Point */ ,(int)offsetof(FlxSprite_obj,_flashPointZero),HX_("_flashPointZero",67,14,7d,fb)},
	{::hx::fsObject /*  ::flixel::math::FlxMatrix */ ,(int)offsetof(FlxSprite_obj,_matrix),HX_("_matrix",e0,47,3f,2a)},
	{::hx::fsObject /*  ::flixel::math::FlxBasePoint */ ,(int)offsetof(FlxSprite_obj,_halfSize),HX_("_halfSize",73,43,4d,66)},
	{::hx::fsObject /*  ::flixel::math::FlxBasePoint */ ,(int)offsetof(FlxSprite_obj,_scaledOrigin),HX_("_scaledOrigin",ff,fa,5e,6a)},
	{::hx::fsFloat,(int)offsetof(FlxSprite_obj,_sinAngle),HX_("_sinAngle",fa,54,de,b8)},
	{::hx::fsFloat,(int)offsetof(FlxSprite_obj,_cosAngle),HX_("_cosAngle",6b,c9,00,1f)},
	{::hx::fsBool,(int)offsetof(FlxSprite_obj,_angleChanged),HX_("_angleChanged",40,98,5c,b2)},
	{::hx::fsObject /*  ::haxe::ds::IntMap */ ,(int)offsetof(FlxSprite_obj,_facingFlip),HX_("_facingFlip",06,e0,9c,02)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo FlxSprite_obj_sStaticStorageInfo[] = {
	{::hx::fsBool,(void *) &FlxSprite_obj::defaultAntialiasing,HX_("defaultAntialiasing",55,d9,0b,c5)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String FlxSprite_obj_sMemberFields[] = {
	HX_("animation",04,ef,34,4b),
	HX_("framePixels",3a,bb,f1,6a),
	HX_("useFramePixels",33,0e,5a,8e),
	HX_("antialiasing",f4,16,b3,48),
	HX_("dirty",12,50,d0,d9),
	HX_("frame",2d,78,83,06),
	HX_("frameWidth",99,ea,88,ad),
	HX_("frameHeight",f4,d3,93,e0),
	HX_("frames",a6,af,85,ac),
	HX_("graphic",a8,5a,07,74),
	HX_("bakedRotationAngle",8a,d1,9c,9b),
	HX_("alpha",5e,a7,96,21),
	HX_("facing",1a,3f,05,e4),
	HX_("flipX",0b,45,92,02),
	HX_("flipY",0c,45,92,02),
	HX_("origin",e6,19,01,4b),
	HX_("offset",93,97,3f,60),
	HX_("scale",8a,ce,ce,78),
	HX_("blend",51,e8,f4,b4),
	HX_("color",63,71,5c,4a),
	HX_("colorTransform",89,d7,3f,ad),
	HX_("useColorTransform",30,e6,ec,72),
	HX_("clipRect",14,90,6a,58),
	HX_("_lastClipRect",69,2f,6b,9c),
	HX_("shader",25,bf,20,1d),
	HX_("_frame",6e,bf,6a,02),
	HX_("_frameGraphic",da,ac,00,f7),
	HX_("_facingHorizontalMult",8d,29,a1,51),
	HX_("_facingVerticalMult",df,11,0c,86),
	HX_("_flashPoint",9f,1d,2a,b7),
	HX_("_flashRect",b5,c2,f3,5d),
	HX_("_flashRect2",dd,9b,56,d7),
	HX_("_flashPointZero",67,14,7d,fb),
	HX_("_matrix",e0,47,3f,2a),
	HX_("_halfSize",73,43,4d,66),
	HX_("_scaledOrigin",ff,fa,5e,6a),
	HX_("_sinAngle",fa,54,de,b8),
	HX_("_cosAngle",6b,c9,00,1f),
	HX_("_angleChanged",40,98,5c,b2),
	HX_("_facingFlip",06,e0,9c,02),
	HX_("initVars",dc,5a,00,53),
	HX_("destroy",fa,2c,86,24),
	HX_("clone",5d,13,63,48),
	HX_("loadGraphicFromSprite",d1,7c,73,38),
	HX_("loadGraphic",22,19,a5,44),
	HX_("loadRotatedGraphic",c5,14,74,62),
	HX_("loadRotatedFrame",0a,81,76,8b),
	HX_("makeGraphic",5a,82,11,b8),
	HX_("graphicLoaded",cd,84,20,16),
	HX_("resetSize",30,aa,3f,92),
	HX_("resetFrameSize",bf,c3,44,94),
	HX_("resetSizeFromFrame",13,d2,50,8c),
	HX_("resetFrame",de,af,1f,ef),
	HX_("setGraphicSize",07,d7,f8,2d),
	HX_("updateHitbox",81,94,eb,56),
	HX_("resetHelpers",36,89,3d,32),
	HX_("update",09,86,05,87),
	HX_("updateAnimation",bb,bf,bf,9a),
	HX_("checkEmptyFrame",48,b5,2f,00),
	HX_("draw",04,2c,70,42),
	HX_("checkClipRect",fc,ec,c4,40),
	HX_("drawSimple",56,7f,42,fa),
	HX_("drawComplex",8c,aa,b9,cc),
	HX_("drawFrameComplex",a7,93,12,43),
	HX_("stamp",03,70,0b,84),
	HX_("drawFrame",89,ad,8e,ce),
	HX_("centerOffsets",2b,a0,b2,c1),
	HX_("centerOrigin",9b,41,36,0f),
	HX_("replaceColor",8f,5c,eb,3d),
	HX_("setColorTransform",cb,5e,21,43),
	HX_("updateColorTransform",72,0f,d2,2f),
	HX_("hasColorTransform",83,14,eb,f0),
	HX_("hasColorTransformRaw",25,ed,0e,c3),
	HX_("pixelsOverlapPoint",16,82,44,e0),
	HX_("getPixelAt",23,b3,68,d7),
	HX_("getPixelAtScreen",ef,de,d1,02),
	HX_("transformWorldToPixels",6e,ba,1c,c0),
	HX_("transformWorldToPixelsSimple",40,b9,b0,20),
	HX_("transformScreenToPixels",20,c1,67,1b),
	HX_("calcFrame",58,93,8c,f9),
	HX_("updateFramePixels",b1,67,5b,cf),
	HX_("getGraphicMidpoint",9a,b4,dd,57),
	HX_("getGraphicBounds",c7,6c,ef,8d),
	HX_("isOnScreen",f5,43,b9,a1),
	HX_("isSimpleRender",32,f4,2a,47),
	HX_("isSimpleRenderBlit",87,59,b0,df),
	HX_("getRotatedBounds",88,12,38,3c),
	HX_("getScreenBounds",b7,e4,25,66),
	HX_("setFacingFlip",29,51,8b,d1),
	HX_("setFrames",e8,24,2d,0c),
	HX_("get_pixels",f6,5e,31,7d),
	HX_("set_pixels",6a,fd,ae,80),
	HX_("set_frame",90,c0,7d,2d),
	HX_("set_facing",57,4d,0a,d8),
	HX_("set_alpha",c1,ef,90,48),
	HX_("set_color",c6,b9,56,71),
	HX_("set_angle",36,8c,dc,49),
	HX_("updateTrig",85,87,b8,05),
	HX_("set_blend",b4,30,ef,db),
	HX_("set_graphic",cb,c1,6e,04),
	HX_("set_clipRect",91,67,7d,22),
	HX_("set_frames",e3,bd,8a,a0),
	HX_("get_numFrames",63,ce,ea,1e),
	HX_("set_flipX",6e,8d,8c,29),
	HX_("set_flipY",6f,8d,8c,29),
	HX_("set_antialiasing",f1,f0,93,a3),
	HX_("set_useFramePixels",70,21,a3,06),
	HX_("checkFlipX",23,47,82,12),
	HX_("checkFlipY",24,47,82,12),
	::String(null()) };

static void FlxSprite_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxSprite_obj::defaultAntialiasing,"defaultAntialiasing");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxSprite_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxSprite_obj::defaultAntialiasing,"defaultAntialiasing");
};

#endif

::hx::Class FlxSprite_obj::__mClass;

static ::String FlxSprite_obj_sStaticFields[] = {
	HX_("defaultAntialiasing",55,d9,0b,c5),
	::String(null())
};

void FlxSprite_obj::__register()
{
	FlxSprite_obj _hx_dummy;
	FlxSprite_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("flixel.FlxSprite",65,ad,eb,e3);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &FlxSprite_obj::__GetStatic;
	__mClass->mSetStaticField = &FlxSprite_obj::__SetStatic;
	__mClass->mMarkFunc = FlxSprite_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(FlxSprite_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(FlxSprite_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< FlxSprite_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxSprite_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxSprite_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxSprite_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void FlxSprite_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_cfd221447aa7194b_136_boot)
HXDLIN( 136)		defaultAntialiasing = false;
            	}
}

} // end namespace flixel
