// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFrame
#include <flixel/graphics/frames/FlxFrame.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFramesCollection
#include <flixel/graphics/frames/FlxFramesCollection.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxImageFrame
#include <flixel/graphics/frames/FlxImageFrame.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxTileFrames
#include <flixel/graphics/frames/FlxTileFrames.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxDrawBaseItem
#include <flixel/graphics/tile/FlxDrawBaseItem.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxDrawQuadsItem
#include <flixel/graphics/tile/FlxDrawQuadsItem.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxGraphicsShader
#include <flixel/graphics/tile/FlxGraphicsShader.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxCallbackPoint
#include <flixel/math/FlxCallbackPoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMatrix
#include <flixel/math/FlxMatrix.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRect
#include <flixel/math/FlxRect.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_BitmapFrontEnd
#include <flixel/system/frontEnds/BitmapFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_CameraFrontEnd
#include <flixel/system/frontEnds/CameraFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_DebuggerFrontEnd
#include <flixel/system/frontEnds/DebuggerFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_SignalFrontEnd
#include <flixel/system/frontEnds/SignalFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxBaseTilemap
#include <flixel/tile/FlxBaseTilemap.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxTile
#include <flixel/tile/FlxTile.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxTilemapAutoTiling
#include <flixel/tile/FlxTilemapAutoTiling.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxTilemapBuffer
#include <flixel/tile/FlxTilemapBuffer.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxTypedTilemap
#include <flixel/tile/FlxTypedTilemap.h>
#endif
#ifndef INCLUDED_flixel_util_FlxColorTransformUtil
#include <flixel/util/FlxColorTransformUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxDestroyUtil
#include <flixel/util/FlxDestroyUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool
#include <flixel/util/FlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_FlxSpriteUtil
#include <flixel/util/FlxSpriteUtil.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxSignal
#include <flixel/util/IFlxSignal.h>
#endif
#ifndef INCLUDED_flixel_util__FlxSignal_FlxBaseSignal
#include <flixel/util/_FlxSignal/FlxBaseSignal.h>
#endif
#ifndef INCLUDED_flixel_util__FlxSignal_FlxSignal0
#include <flixel/util/_FlxSignal/FlxSignal0.h>
#endif
#ifndef INCLUDED_flixel_util__FlxSignal_FlxSignal1
#include <flixel/util/_FlxSignal/FlxSignal1.h>
#endif
#ifndef INCLUDED_flixel_util__FlxSignal_FlxSignal2
#include <flixel/util/_FlxSignal/FlxSignal2.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_Graphics
#include <openfl/display/Graphics.h>
#endif
#ifndef INCLUDED_openfl_display_GraphicsShader
#include <openfl/display/GraphicsShader.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_146_new,"flixel.tile.FlxTypedTilemap","new",0x792e675a,"flixel.tile.FlxTypedTilemap.new","flixel/tile/FlxTilemap.hx",146,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_317_destroy,"flixel.tile.FlxTypedTilemap","destroy",0x1f90c8f4,"flixel.tile.FlxTypedTilemap.destroy","flixel/tile/FlxTilemap.hx",317,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_364_initTileObjects,"flixel.tile.FlxTypedTilemap","initTileObjects",0x6da3e410,"flixel.tile.FlxTypedTilemap.initTileObjects","flixel/tile/FlxTilemap.hx",364,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_388_createTile,"flixel.tile.FlxTypedTilemap","createTile",0x80122890,"flixel.tile.FlxTypedTilemap.createTile","flixel/tile/FlxTilemap.hx",388,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_392_set_frames,"flixel.tile.FlxTypedTilemap","set_frames",0xc1125a29,"flixel.tile.FlxTypedTilemap.set_frames","flixel/tile/FlxTilemap.hx",392,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_409_onGameResized,"flixel.tile.FlxTypedTilemap","onGameResized",0xa47ac2b9,"flixel.tile.FlxTypedTilemap.onGameResized","flixel/tile/FlxTilemap.hx",409,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_414_onCameraChanged,"flixel.tile.FlxTypedTilemap","onCameraChanged",0x9bac6e2a,"flixel.tile.FlxTypedTilemap.onCameraChanged","flixel/tile/FlxTilemap.hx",414,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_418_loadMapHelper,"flixel.tile.FlxTypedTilemap","loadMapHelper",0x62fa7d9e,"flixel.tile.FlxTypedTilemap.loadMapHelper","flixel/tile/FlxTilemap.hx",418,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_426_cacheGraphics,"flixel.tile.FlxTypedTilemap","cacheGraphics",0xf5fc34a7,"flixel.tile.FlxTypedTilemap.cacheGraphics","flixel/tile/FlxTilemap.hx",426,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_476_padTileFrames,"flixel.tile.FlxTypedTilemap","padTileFrames",0xc5d5b421,"flixel.tile.FlxTypedTilemap.padTileFrames","flixel/tile/FlxTilemap.hx",476,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_487_updateDebugTileBoundingBoxSolid,"flixel.tile.FlxTypedTilemap","updateDebugTileBoundingBoxSolid",0x53377b96,"flixel.tile.FlxTypedTilemap.updateDebugTileBoundingBoxSolid","flixel/tile/FlxTilemap.hx",487,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_492_updateDebugTileBoundingBoxNotSolid,"flixel.tile.FlxTypedTilemap","updateDebugTileBoundingBoxNotSolid",0x6b32f38d,"flixel.tile.FlxTypedTilemap.updateDebugTileBoundingBoxNotSolid","flixel/tile/FlxTilemap.hx",492,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_497_updateDebugTileBoundingBoxPartial,"flixel.tile.FlxTypedTilemap","updateDebugTileBoundingBoxPartial",0x92af8fac,"flixel.tile.FlxTypedTilemap.updateDebugTileBoundingBoxPartial","flixel/tile/FlxTilemap.hx",497,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_501_updateDebugTile,"flixel.tile.FlxTypedTilemap","updateDebugTile",0xbf3165d2,"flixel.tile.FlxTypedTilemap.updateDebugTile","flixel/tile/FlxTilemap.hx",501,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_525_computeDimensions,"flixel.tile.FlxTypedTilemap","computeDimensions",0x639abd1e,"flixel.tile.FlxTypedTilemap.computeDimensions","flixel/tile/FlxTilemap.hx",525,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_534_updateMap,"flixel.tile.FlxTypedTilemap","updateMap",0x4ac4f68d,"flixel.tile.FlxTypedTilemap.updateMap","flixel/tile/FlxTilemap.hx",534,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_547_drawDebugOnCamera,"flixel.tile.FlxTypedTilemap","drawDebugOnCamera",0x3b2a606d,"flixel.tile.FlxTypedTilemap.drawDebugOnCamera","flixel/tile/FlxTilemap.hx",547,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_629_isOnScreen,"flixel.tile.FlxTypedTilemap","isOnScreen",0xc240e03b,"flixel.tile.FlxTypedTilemap.isOnScreen","flixel/tile/FlxTilemap.hx",629,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_644_draw,"flixel.tile.FlxTypedTilemap","draw",0x88d9afca,"flixel.tile.FlxTypedTilemap.draw","flixel/tile/FlxTilemap.hx",644,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_696_refreshBuffers,"flixel.tile.FlxTypedTilemap","refreshBuffers",0x6737ea1e,"flixel.tile.FlxTypedTilemap.refreshBuffers","flixel/tile/FlxTilemap.hx",696,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_718_setDirty,"flixel.tile.FlxTypedTilemap","setDirty",0x964297d6,"flixel.tile.FlxTypedTilemap.setDirty","flixel/tile/FlxTilemap.hx",718,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_729_isOverlappingTile,"flixel.tile.FlxTypedTilemap","isOverlappingTile",0x3b7568f7,"flixel.tile.FlxTypedTilemap.isOverlappingTile","flixel/tile/FlxTilemap.hx",729,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_735_forEachOverlappingTile,"flixel.tile.FlxTypedTilemap","forEachOverlappingTile",0x86d9e803,"flixel.tile.FlxTypedTilemap.forEachOverlappingTile","flixel/tile/FlxTilemap.hx",735,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_733_forEachOverlappingTile,"flixel.tile.FlxTypedTilemap","forEachOverlappingTile",0x86d9e803,"flixel.tile.FlxTypedTilemap.forEachOverlappingTile","flixel/tile/FlxTilemap.hx",733,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_747_forEachOverlappingTileHelper,"flixel.tile.FlxTypedTilemap","forEachOverlappingTileHelper",0xd8db3dd1,"flixel.tile.FlxTypedTilemap.forEachOverlappingTileHelper","flixel/tile/FlxTilemap.hx",747,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_796_objectOverlapsTiles,"flixel.tile.FlxTypedTilemap","objectOverlapsTiles",0xb10fff94,"flixel.tile.FlxTypedTilemap.objectOverlapsTiles","flixel/tile/FlxTilemap.hx",796,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_792_objectOverlapsTiles,"flixel.tile.FlxTypedTilemap","objectOverlapsTiles",0xb10fff94,"flixel.tile.FlxTypedTilemap.objectOverlapsTiles","flixel/tile/FlxTilemap.hx",792,0x448feb74)
static const bool _hx_array_data_54257268_37[] = {
	0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_825_getColumnAt,"flixel.tile.FlxTypedTilemap","getColumnAt",0x77324d19,"flixel.tile.FlxTypedTilemap.getColumnAt","flixel/tile/FlxTilemap.hx",825,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_835_getRowAt,"flixel.tile.FlxTypedTilemap","getRowAt",0xfb7c43fd,"flixel.tile.FlxTypedTilemap.getRowAt","flixel/tile/FlxTilemap.hx",835,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_846_getColumnPos,"flixel.tile.FlxTypedTilemap","getColumnPos",0xd4dc86ae,"flixel.tile.FlxTypedTilemap.getColumnPos","flixel/tile/FlxTilemap.hx",846,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_851_getRowPos,"flixel.tile.FlxTypedTilemap","getRowPos",0x114a974a,"flixel.tile.FlxTypedTilemap.getRowPos","flixel/tile/FlxTilemap.hx",851,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_864_getTileCoords,"flixel.tile.FlxTypedTilemap","getTileCoords",0x82f4a99c,"flixel.tile.FlxTypedTilemap.getTileCoords","flixel/tile/FlxTilemap.hx",864,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_877_follow,"flixel.tile.FlxTypedTilemap","follow",0xd03d12b7,"flixel.tile.FlxTypedTilemap.follow","flixel/tile/FlxTilemap.hx",877,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_903_ray,"flixel.tile.FlxTypedTilemap","ray",0x79316ce4,"flixel.tile.FlxTypedTilemap.ray","flixel/tile/FlxTilemap.hx",903,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1019_checkColumn,"flixel.tile.FlxTypedTilemap","checkColumn",0xfebe42b8,"flixel.tile.FlxTypedTilemap.checkColumn","flixel/tile/FlxTilemap.hx",1019,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1065_rayStep,"flixel.tile.FlxTypedTilemap","rayStep",0x2ae8c250,"flixel.tile.FlxTypedTilemap.rayStep","flixel/tile/FlxTilemap.hx",1065,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1173_tileToSprite,"flixel.tile.FlxTypedTilemap","tileToSprite",0xca02a2f4,"flixel.tile.FlxTypedTilemap.tileToSprite","flixel/tile/FlxTilemap.hx",1173,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1206_updateBuffers,"flixel.tile.FlxTypedTilemap","updateBuffers",0x7665dbe4,"flixel.tile.FlxTypedTilemap.updateBuffers","flixel/tile/FlxTilemap.hx",1206,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1219_drawTilemap,"flixel.tile.FlxTypedTilemap","drawTilemap",0xe4f85584,"flixel.tile.FlxTypedTilemap.drawTilemap","flixel/tile/FlxTilemap.hx",1219,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1361_makeDebugTile,"flixel.tile.FlxTypedTilemap","makeDebugTile",0x22583acd,"flixel.tile.FlxTypedTilemap.makeDebugTile","flixel/tile/FlxTilemap.hx",1361,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1372_drawDebugTile,"flixel.tile.FlxTypedTilemap","drawDebugTile",0x88d655f7,"flixel.tile.FlxTypedTilemap.drawDebugTile","flixel/tile/FlxTilemap.hx",1372,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1389_onDrawDebugChanged,"flixel.tile.FlxTypedTilemap","onDrawDebugChanged",0xe978328a,"flixel.tile.FlxTypedTilemap.onDrawDebugChanged","flixel/tile/FlxTilemap.hx",1389,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1399_updateTile,"flixel.tile.FlxTypedTilemap","updateTile",0x2639521d,"flixel.tile.FlxTypedTilemap.updateTile","flixel/tile/FlxTilemap.hx",1399,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1408_createBuffer,"flixel.tile.FlxTypedTilemap","createBuffer",0xf9c5b6e2,"flixel.tile.FlxTypedTilemap.createBuffer","flixel/tile/FlxTilemap.hx",1408,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1416_set_antialiasing,"flixel.tile.FlxTypedTilemap","set_antialiasing",0xd69705b7,"flixel.tile.FlxTypedTilemap.set_antialiasing","flixel/tile/FlxTilemap.hx",1416,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1428_set_graphic,"flixel.tile.FlxTypedTilemap","set_graphic",0x5a8fe2c5,"flixel.tile.FlxTypedTilemap.set_graphic","flixel/tile/FlxTilemap.hx",1428,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1446_set_pixelPerfectRender,"flixel.tile.FlxTypedTilemap","set_pixelPerfectRender",0x6ab33ce0,"flixel.tile.FlxTypedTilemap.set_pixelPerfectRender","flixel/tile/FlxTilemap.hx",1446,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1455_set_alpha,"flixel.tile.FlxTypedTilemap","set_alpha",0x1075fe3b,"flixel.tile.FlxTypedTilemap.set_alpha","flixel/tile/FlxTilemap.hx",1455,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1462_set_color,"flixel.tile.FlxTypedTilemap","set_color",0x393bc840,"flixel.tile.FlxTypedTilemap.set_color","flixel/tile/FlxTilemap.hx",1462,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1472_updateColorTransform,"flixel.tile.FlxTypedTilemap","updateColorTransform",0xa545ff38,"flixel.tile.FlxTypedTilemap.updateColorTransform","flixel/tile/FlxTilemap.hx",1472,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1485_set_blend,"flixel.tile.FlxTypedTilemap","set_blend",0xa3d43f2e,"flixel.tile.FlxTypedTilemap.set_blend","flixel/tile/FlxTilemap.hx",1485,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1491_setScaleXYCallback,"flixel.tile.FlxTypedTilemap","setScaleXYCallback",0xd9bc4fb4,"flixel.tile.FlxTypedTilemap.setScaleXYCallback","flixel/tile/FlxTilemap.hx",1491,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1497_setScaleXCallback,"flixel.tile.FlxTypedTilemap","setScaleXCallback",0x73511e2f,"flixel.tile.FlxTypedTilemap.setScaleXCallback","flixel/tile/FlxTilemap.hx",1497,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1511_setScaleYCallback,"flixel.tile.FlxTypedTilemap","setScaleYCallback",0x46428730,"flixel.tile.FlxTypedTilemap.setScaleYCallback","flixel/tile/FlxTilemap.hx",1511,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1531_defaultTileToSprite,"flixel.tile.FlxTypedTilemap","defaultTileToSprite",0x4b815689,"flixel.tile.FlxTypedTilemap.defaultTileToSprite","flixel/tile/FlxTilemap.hx",1531,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1542_set_allowCollisions,"flixel.tile.FlxTypedTilemap","set_allowCollisions",0x2d8336c7,"flixel.tile.FlxTypedTilemap.set_allowCollisions","flixel/tile/FlxTilemap.hx",1542,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1552_get_scaledWidth,"flixel.tile.FlxTypedTilemap","get_scaledWidth",0x10ef6a9d,"flixel.tile.FlxTypedTilemap.get_scaledWidth","flixel/tile/FlxTilemap.hx",1552,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1557_get_scaledHeight,"flixel.tile.FlxTypedTilemap","get_scaledHeight",0x76dd5770,"flixel.tile.FlxTypedTilemap.get_scaledHeight","flixel/tile/FlxTilemap.hx",1557,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1567_getBounds,"flixel.tile.FlxTypedTilemap","getBounds",0xaa591e25,"flixel.tile.FlxTypedTilemap.getBounds","flixel/tile/FlxTilemap.hx",1567,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1576_set_debugBoundingBoxColorSolid,"flixel.tile.FlxTypedTilemap","set_debugBoundingBoxColorSolid",0x80676c5f,"flixel.tile.FlxTypedTilemap.set_debugBoundingBoxColorSolid","flixel/tile/FlxTilemap.hx",1576,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1583_set_debugBoundingBoxColorNotSolid,"flixel.tile.FlxTypedTilemap","set_debugBoundingBoxColorNotSolid",0x8d74e664,"flixel.tile.FlxTypedTilemap.set_debugBoundingBoxColorNotSolid","flixel/tile/FlxTilemap.hx",1583,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_1590_set_debugBoundingBoxColorPartial,"flixel.tile.FlxTypedTilemap","set_debugBoundingBoxColorPartial",0x605404b5,"flixel.tile.FlxTypedTilemap.set_debugBoundingBoxColorPartial","flixel/tile/FlxTilemap.hx",1590,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_0e3a69bb718c23c6_154_boot,"flixel.tile.FlxTypedTilemap","boot",0x878507f8,"flixel.tile.FlxTypedTilemap.boot","flixel/tile/FlxTilemap.hx",154,0x448feb74)
namespace flixel{
namespace tile{

void FlxTypedTilemap_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_146_new)
HXLINE( 283)		this->_checkBufferChanges = false;
HXLINE( 261)		this->_buffers = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 256)		this->_flashRect =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE( 251)		this->_flashPoint =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 229)		this->scaledTileHeight = ((Float)0);
HXLINE( 224)		this->scaledTileWidth = ((Float)0);
HXLINE( 219)		this->tileHeight = 0;
HXLINE( 214)		this->tileWidth = 0;
HXLINE( 209)		this->blend = null();
HXLINE( 204)		this->colorTransform =  ::openfl::geom::ColorTransform_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null(),null(),null());
HXLINE( 202)		this->alpha = ((Float)1.0);
HXLINE( 197)		this->color = 16777215;
HXLINE( 184)		 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN( 184)		point->_inPool = false;
HXDLIN( 184)		this->offset = point;
HXLINE( 178)		this->antialiasing = ::flixel::FlxSprite_obj::defaultAntialiasing;
HXLINE( 164)		this->framePadding = null();
HXLINE( 287)		super::__construct();
HXLINE( 289)		if (::flixel::FlxG_obj::renderTile) {
HXLINE( 291)			this->_helperPoint =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 292)			this->_matrix =  ::flixel::math::FlxMatrix_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
            		}
HXLINE( 295)		this->scale =  ::flixel::math::FlxCallbackPoint_obj::__alloc( HX_CTX ,this->setScaleXCallback_dyn(),this->setScaleYCallback_dyn(),this->setScaleXYCallback_dyn());
HXLINE( 296)		{
HXLINE( 296)			 ::flixel::math::FlxBasePoint this1 = this->scale;
HXDLIN( 296)			this1->set_x(( (Float)(1) ));
HXDLIN( 296)			this1->set_y(( (Float)(1) ));
            		}
HXLINE( 298)		::flixel::FlxG_obj::signals->gameResized->add(this->onGameResized_dyn());
HXLINE( 299)		::flixel::FlxG_obj::cameras->cameraAdded->add(this->onCameraChanged_dyn());
HXLINE( 300)		::flixel::FlxG_obj::cameras->cameraRemoved->add(this->onCameraChanged_dyn());
HXLINE( 301)		::flixel::FlxG_obj::cameras->cameraResized->add(this->onCameraChanged_dyn());
HXLINE( 304)		this->set_debugBoundingBoxColorSolid(-16744448);
HXLINE( 305)		this->set_debugBoundingBoxColorPartial(-16181);
HXLINE( 306)		this->set_debugBoundingBoxColorNotSolid(0);
HXLINE( 308)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 309)			::flixel::FlxG_obj::debugger->drawDebugChanged->add(this->onDrawDebugChanged_dyn());
            		}
            	}

Dynamic FlxTypedTilemap_obj::__CreateEmpty() { return new FlxTypedTilemap_obj; }

void *FlxTypedTilemap_obj::_hx_vtable = 0;

Dynamic FlxTypedTilemap_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< FlxTypedTilemap_obj > _hx_result = new FlxTypedTilemap_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool FlxTypedTilemap_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x7ccf8994) {
		if (inClassId<=(int)0x3d6253b5) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x3d6253b5;
		} else {
			return inClassId==(int)0x7ccf8994;
		}
	} else {
		return inClassId==(int)0x7dab0655 || inClassId==(int)0x7fac4e48;
	}
}

void FlxTypedTilemap_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_317_destroy)
HXLINE( 318)		this->_flashPoint = null();
HXLINE( 319)		this->_flashRect = null();
HXLINE( 321)		this->_tileObjects = ::flixel::util::FlxDestroyUtil_obj::destroyArray(this->_tileObjects);
HXLINE( 322)		this->_buffers = ::flixel::util::FlxDestroyUtil_obj::destroyArray(this->_buffers);
HXLINE( 324)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 327)			this->_debugRect = null();
HXLINE( 328)			this->_debugTileNotSolid = ::flixel::util::FlxDestroyUtil_obj::dispose(this->_debugTileNotSolid);
HXLINE( 329)			this->_debugTilePartial = ::flixel::util::FlxDestroyUtil_obj::dispose(this->_debugTilePartial);
HXLINE( 330)			this->_debugTileSolid = ::flixel::util::FlxDestroyUtil_obj::dispose(this->_debugTileSolid);
            		}
            		else {
HXLINE( 335)			this->_helperPoint = null();
HXLINE( 336)			this->_matrix = null();
            		}
HXLINE( 339)		this->set_frames(null());
HXLINE( 340)		this->set_graphic(null());
HXLINE( 343)		this->scale = ( ( ::flixel::math::FlxBasePoint)(::flixel::util::FlxDestroyUtil_obj::destroy(this->scale)) );
HXLINE( 344)		this->offset = ( ( ::flixel::math::FlxBasePoint)(::flixel::util::FlxDestroyUtil_obj::put(this->offset)) );
HXLINE( 346)		this->colorTransform = null();
HXLINE( 348)		::flixel::FlxG_obj::signals->gameResized->remove(this->onGameResized_dyn());
HXLINE( 349)		::flixel::FlxG_obj::cameras->cameraAdded->remove(this->onCameraChanged_dyn());
HXLINE( 350)		::flixel::FlxG_obj::cameras->cameraRemoved->remove(this->onCameraChanged_dyn());
HXLINE( 351)		::flixel::FlxG_obj::cameras->cameraResized->remove(this->onCameraChanged_dyn());
HXLINE( 354)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 355)			::flixel::FlxG_obj::debugger->drawDebugChanged->remove(this->onDrawDebugChanged_dyn());
            		}
HXLINE( 358)		this->shader = null();
HXLINE( 360)		this->super::destroy();
            	}


void FlxTypedTilemap_obj::initTileObjects(){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_364_initTileObjects)
HXLINE( 365)		if (::hx::IsNull( this->frames )) {
HXLINE( 366)			return;
            		}
HXLINE( 368)		this->_tileObjects = ::flixel::util::FlxDestroyUtil_obj::destroyArray(this->_tileObjects);
HXLINE( 370)		this->_tileObjects = ::cpp::VirtualArray_obj::__new(0);
HXLINE( 372)		int length = this->frames->frames->length;
HXLINE( 373)		length = (length + this->_startingIndex);
HXLINE( 375)		{
HXLINE( 375)			int _g = 0;
HXDLIN( 375)			int _g1 = length;
HXDLIN( 375)			while((_g < _g1)){
HXLINE( 375)				_g = (_g + 1);
HXDLIN( 375)				int i = (_g - 1);
HXLINE( 376)				this->_tileObjects->set(i,this->createTile(i,( (Float)(this->tileWidth) ),( (Float)(this->tileHeight) )));
            			}
            		}
HXLINE( 380)		this->updateDebugTileBoundingBoxSolid();
HXLINE( 381)		this->updateDebugTileBoundingBoxNotSolid();
HXLINE( 382)		this->updateDebugTileBoundingBoxPartial();
            	}


 ::Dynamic FlxTypedTilemap_obj::createTile(int index,Float width,Float height){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_388_createTile)
HXDLIN( 388)		HX_STACK_DO_THROW(HX_("createTile not implemented",5f,7a,88,7e));
HXDLIN( 388)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxTypedTilemap_obj,createTile,return )

 ::flixel::graphics::frames::FlxFramesCollection FlxTypedTilemap_obj::set_frames( ::flixel::graphics::frames::FlxFramesCollection value){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_392_set_frames)
HXLINE( 393)		this->frames = value;
HXLINE( 395)		if (::hx::IsNotNull( value )) {
HXLINE( 397)			this->tileWidth = ::Std_obj::_hx_int(value->frames->__get(0).StaticCast<  ::flixel::graphics::frames::FlxFrame >()->sourceSize->x);
HXLINE( 398)			this->tileHeight = ::Std_obj::_hx_int(value->frames->__get(0).StaticCast<  ::flixel::graphics::frames::FlxFrame >()->sourceSize->y);
HXLINE( 399)			this->_flashRect->setTo(( (Float)(0) ),( (Float)(0) ),( (Float)(this->tileWidth) ),( (Float)(this->tileHeight) ));
HXLINE( 400)			this->set_graphic(value->parent);
HXLINE( 401)			this->postGraphicLoad();
            		}
HXLINE( 404)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTypedTilemap_obj,set_frames,return )

void FlxTypedTilemap_obj::onGameResized(int w,int h){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_409_onGameResized)
HXDLIN( 409)		this->_checkBufferChanges = true;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTypedTilemap_obj,onGameResized,(void))

void FlxTypedTilemap_obj::onCameraChanged( ::flixel::FlxCamera cam){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_414_onCameraChanged)
HXDLIN( 414)		this->_checkBufferChanges = true;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTypedTilemap_obj,onCameraChanged,(void))

void FlxTypedTilemap_obj::loadMapHelper( ::Dynamic tileGraphic,::hx::Null< int >  __o_tileWidth,::hx::Null< int >  __o_tileHeight, ::flixel::tile::FlxTilemapAutoTiling autoTile,::hx::Null< int >  __o_startingIndex,::hx::Null< int >  __o_drawIndex,::hx::Null< int >  __o_collideIndex){
            		int tileWidth = __o_tileWidth.Default(0);
            		int tileHeight = __o_tileHeight.Default(0);
            		int startingIndex = __o_startingIndex.Default(0);
            		int drawIndex = __o_drawIndex.Default(1);
            		int collideIndex = __o_collideIndex.Default(1);
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_418_loadMapHelper)
HXLINE( 420)		this->_checkBufferChanges = true;
HXLINE( 422)		this->super::loadMapHelper(tileGraphic,tileWidth,tileHeight,autoTile,startingIndex,drawIndex,collideIndex);
            	}


void FlxTypedTilemap_obj::cacheGraphics(int tileWidth,int tileHeight, ::Dynamic tileGraphic){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_426_cacheGraphics)
HXLINE( 427)		if (::Std_obj::isOfType(tileGraphic,::hx::ClassOf< ::flixel::graphics::frames::FlxFramesCollection >())) {
HXLINE( 429)			this->set_frames(( ( ::flixel::graphics::frames::FlxFramesCollection)(tileGraphic) ));
HXLINE( 430)			return;
            		}
HXLINE( 433)		 ::flixel::graphics::FlxGraphic graph = ::flixel::FlxG_obj::bitmap->add(tileGraphic,null(),null());
HXLINE( 434)		if (::hx::IsNull( graph )) {
HXLINE( 435)			return;
            		}
HXLINE( 438)		if ((tileWidth <= 0)) {
HXLINE( 439)			tileWidth = graph->height;
            		}
HXLINE( 441)		if ((tileHeight <= 0)) {
HXLINE( 442)			tileHeight = tileWidth;
            		}
HXLINE( 444)		this->tileWidth = tileWidth;
HXLINE( 445)		this->tileHeight = tileHeight;
HXLINE( 447)		 ::Dynamic actualFramePadding;
HXDLIN( 447)		if (::hx::IsNull( this->framePadding )) {
HXLINE( 447)			actualFramePadding = ::flixel::tile::FlxTypedTilemap_obj::defaultFramePadding;
            		}
            		else {
HXLINE( 447)			actualFramePadding = this->framePadding;
            		}
HXLINE( 448)		bool _hx_tmp;
HXDLIN( 448)		if (::hx::IsGreater( actualFramePadding,0 )) {
HXLINE( 448)			if (::hx::IsNotNull( graph->bitmap )) {
HXLINE( 448)				_hx_tmp = !(graph->bitmap->rect->isEmpty());
            			}
            			else {
HXLINE( 448)				_hx_tmp = false;
            			}
            		}
            		else {
HXLINE( 448)			_hx_tmp = false;
            		}
HXDLIN( 448)		if (_hx_tmp) {
HXLINE( 449)			this->set_frames(this->padTileFrames(tileWidth,tileHeight,graph,( (int)(actualFramePadding) )));
            		}
            		else {
HXLINE( 470)			 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(tileWidth,tileHeight);
HXDLIN( 470)			point->_inPool = false;
HXDLIN( 470)			this->set_frames(::flixel::graphics::frames::FlxTileFrames_obj::fromGraphic(graph,point,null(),null()));
            		}
            	}


 ::flixel::graphics::frames::FlxTileFrames FlxTypedTilemap_obj::padTileFrames(int tileWidth,int tileHeight, ::flixel::graphics::FlxGraphic graphic,int padding){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_476_padTileFrames)
HXLINE( 478)		 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(tileWidth,tileHeight);
HXDLIN( 478)		point->_inPool = false;
HXLINE( 480)		 ::flixel::math::FlxBasePoint point1 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(padding,padding);
HXDLIN( 480)		point1->_inPool = false;
HXLINE( 476)		return ::flixel::graphics::frames::FlxTileFrames_obj::fromBitmapAddSpacesAndBorders(graphic,point,null(),point1,null());
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxTypedTilemap_obj,padTileFrames,return )

void FlxTypedTilemap_obj::updateDebugTileBoundingBoxSolid(){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_487_updateDebugTileBoundingBoxSolid)
HXDLIN( 487)		this->_debugTileSolid = this->updateDebugTile(this->_debugTileSolid,this->debugBoundingBoxColorSolid);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxTypedTilemap_obj,updateDebugTileBoundingBoxSolid,(void))

void FlxTypedTilemap_obj::updateDebugTileBoundingBoxNotSolid(){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_492_updateDebugTileBoundingBoxNotSolid)
HXDLIN( 492)		this->_debugTileNotSolid = this->updateDebugTile(this->_debugTileNotSolid,this->debugBoundingBoxColorNotSolid);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxTypedTilemap_obj,updateDebugTileBoundingBoxNotSolid,(void))

void FlxTypedTilemap_obj::updateDebugTileBoundingBoxPartial(){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_497_updateDebugTileBoundingBoxPartial)
HXDLIN( 497)		this->_debugTilePartial = this->updateDebugTile(this->_debugTilePartial,this->debugBoundingBoxColorPartial);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxTypedTilemap_obj,updateDebugTileBoundingBoxPartial,(void))

 ::openfl::display::BitmapData FlxTypedTilemap_obj::updateDebugTile( ::openfl::display::BitmapData tileBitmap,int color){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_501_updateDebugTile)
HXLINE( 502)		if (::flixel::FlxG_obj::renderTile) {
HXLINE( 503)			return null();
            		}
HXLINE( 505)		bool _hx_tmp;
HXDLIN( 505)		if ((this->tileWidth > 0)) {
HXLINE( 505)			_hx_tmp = (this->tileHeight <= 0);
            		}
            		else {
HXLINE( 505)			_hx_tmp = true;
            		}
HXDLIN( 505)		if (_hx_tmp) {
HXLINE( 506)			return tileBitmap;
            		}
HXLINE( 508)		bool _hx_tmp1;
HXDLIN( 508)		if (::hx::IsNotNull( tileBitmap )) {
HXLINE( 508)			if ((tileBitmap->width == this->tileWidth)) {
HXLINE( 508)				_hx_tmp1 = (tileBitmap->height != this->tileHeight);
            			}
            			else {
HXLINE( 508)				_hx_tmp1 = true;
            			}
            		}
            		else {
HXLINE( 508)			_hx_tmp1 = false;
            		}
HXDLIN( 508)		if (_hx_tmp1) {
HXLINE( 509)			tileBitmap = ::flixel::util::FlxDestroyUtil_obj::dispose(tileBitmap);
            		}
HXLINE( 511)		if (::hx::IsNull( tileBitmap )) {
HXLINE( 512)			tileBitmap = this->makeDebugTile(color);
            		}
            		else {
HXLINE( 515)			tileBitmap->fillRect(tileBitmap->rect,0);
HXLINE( 516)			this->drawDebugTile(tileBitmap,color);
            		}
HXLINE( 519)		this->setDirty(null());
HXLINE( 520)		return tileBitmap;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTypedTilemap_obj,updateDebugTile,return )

void FlxTypedTilemap_obj::computeDimensions(){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_525_computeDimensions)
HXLINE( 526)		this->scaledTileWidth = (( (Float)(this->tileWidth) ) * this->scale->x);
HXLINE( 527)		this->scaledTileHeight = (( (Float)(this->tileHeight) ) * this->scale->y);
HXLINE( 529)		this->set_width((( (Float)(this->widthInTiles) ) * this->scaledTileWidth));
HXLINE( 530)		this->set_height((( (Float)(this->heightInTiles) ) * this->scaledTileHeight));
            	}


void FlxTypedTilemap_obj::updateMap(){
            	HX_GC_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_534_updateMap)
HXLINE( 536)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 537)			this->_debugRect =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,0,0,this->tileWidth,this->tileHeight);
            		}
HXLINE( 540)		int numTiles = this->_tileObjects->get_length();
HXLINE( 541)		{
HXLINE( 541)			int _g = 0;
HXDLIN( 541)			int _g1 = numTiles;
HXDLIN( 541)			while((_g < _g1)){
HXLINE( 541)				_g = (_g + 1);
HXDLIN( 541)				int i = (_g - 1);
HXLINE( 542)				this->updateTile(i);
            			}
            		}
            	}


void FlxTypedTilemap_obj::drawDebugOnCamera( ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_547_drawDebugOnCamera)
HXLINE( 548)		if (!(::flixel::FlxG_obj::renderTile)) {
HXLINE( 549)			return;
            		}
HXLINE( 551)		 ::flixel::tile::FlxTilemapBuffer buffer = null();
HXLINE( 552)		int l = ::flixel::FlxG_obj::cameras->list->length;
HXLINE( 554)		{
HXLINE( 554)			int _g = 0;
HXDLIN( 554)			int _g1 = l;
HXDLIN( 554)			while((_g < _g1)){
HXLINE( 554)				_g = (_g + 1);
HXDLIN( 554)				int i = (_g - 1);
HXLINE( 556)				if (::hx::IsInstanceEq( ::flixel::FlxG_obj::cameras->list->__get(i).StaticCast<  ::flixel::FlxCamera >(),camera )) {
HXLINE( 558)					buffer = this->_buffers->__get(i).StaticCast<  ::flixel::tile::FlxTilemapBuffer >();
HXLINE( 559)					goto _hx_goto_18;
            				}
            			}
            			_hx_goto_18:;
            		}
HXLINE( 563)		if (::hx::IsNull( buffer )) {
HXLINE( 564)			return;
            		}
HXLINE( 567)		this->_helperPoint->x = (this->x - (camera->scroll->x * this->scrollFactor->x));
HXLINE( 568)		this->_helperPoint->y = (this->y - (camera->scroll->y * this->scrollFactor->y));
HXLINE( 570)		Float Width = this->scaledTileWidth;
HXDLIN( 570)		Float Height = this->scaledTileHeight;
HXDLIN( 570)		 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get().StaticCast<  ::flixel::math::FlxRect >();
HXDLIN( 570)		_this->x = ( (Float)(0) );
HXDLIN( 570)		_this->y = ( (Float)(0) );
HXDLIN( 570)		_this->width = Width;
HXDLIN( 570)		_this->height = Height;
HXDLIN( 570)		 ::flixel::math::FlxRect rect = _this;
HXDLIN( 570)		rect->_inPool = false;
HXDLIN( 570)		 ::flixel::math::FlxRect rect1 = rect;
HXLINE( 574)		this->_point->set_x(((camera->scroll->x * this->scrollFactor->x) - this->x));
HXLINE( 575)		this->_point->set_y(((camera->scroll->y * this->scrollFactor->y) - this->y));
HXLINE( 576)		int screenXInTiles = ::Math_obj::floor((this->_point->x / this->scaledTileWidth));
HXLINE( 577)		int screenYInTiles = ::Math_obj::floor((this->_point->y / this->scaledTileHeight));
HXLINE( 578)		int screenRows = buffer->rows;
HXLINE( 579)		int screenColumns = buffer->columns;
HXLINE( 582)		 ::Dynamic Max = (this->widthInTiles - screenColumns);
HXDLIN( 582)		Float lowerBound;
HXDLIN( 582)		if ((screenXInTiles < 0)) {
HXLINE( 582)			lowerBound = ( (Float)(0) );
            		}
            		else {
HXLINE( 582)			lowerBound = ( (Float)(screenXInTiles) );
            		}
HXDLIN( 582)		Float screenXInTiles1;
HXDLIN( 582)		bool screenXInTiles2;
HXDLIN( 582)		if (::hx::IsNotNull( Max )) {
HXLINE( 582)			screenXInTiles2 = ::hx::IsGreater( lowerBound,Max );
            		}
            		else {
HXLINE( 582)			screenXInTiles2 = false;
            		}
HXDLIN( 582)		if (screenXInTiles2) {
HXLINE( 582)			screenXInTiles1 = ( (Float)(Max) );
            		}
            		else {
HXLINE( 582)			screenXInTiles1 = lowerBound;
            		}
HXDLIN( 582)		screenXInTiles = ::Std_obj::_hx_int(screenXInTiles1);
HXLINE( 583)		 ::Dynamic Max1 = (this->heightInTiles - screenRows);
HXDLIN( 583)		Float lowerBound1;
HXDLIN( 583)		if ((screenYInTiles < 0)) {
HXLINE( 583)			lowerBound1 = ( (Float)(0) );
            		}
            		else {
HXLINE( 583)			lowerBound1 = ( (Float)(screenYInTiles) );
            		}
HXDLIN( 583)		Float screenYInTiles1;
HXDLIN( 583)		bool screenYInTiles2;
HXDLIN( 583)		if (::hx::IsNotNull( Max1 )) {
HXLINE( 583)			screenYInTiles2 = ::hx::IsGreater( lowerBound1,Max1 );
            		}
            		else {
HXLINE( 583)			screenYInTiles2 = false;
            		}
HXDLIN( 583)		if (screenYInTiles2) {
HXLINE( 583)			screenYInTiles1 = ( (Float)(Max1) );
            		}
            		else {
HXLINE( 583)			screenYInTiles1 = lowerBound1;
            		}
HXDLIN( 583)		screenYInTiles = ::Std_obj::_hx_int(screenYInTiles1);
HXLINE( 585)		int rowIndex = ((screenYInTiles * this->widthInTiles) + screenXInTiles);
HXLINE( 587)		{
HXLINE( 587)			int _g2 = 0;
HXDLIN( 587)			int _g3 = screenRows;
HXDLIN( 587)			while((_g2 < _g3)){
HXLINE( 587)				_g2 = (_g2 + 1);
HXDLIN( 587)				int row = (_g2 - 1);
HXLINE( 589)				int columnIndex = rowIndex;
HXLINE( 591)				{
HXLINE( 591)					int _g4 = 0;
HXDLIN( 591)					int _g5 = screenColumns;
HXDLIN( 591)					while((_g4 < _g5)){
HXLINE( 591)						_g4 = (_g4 + 1);
HXDLIN( 591)						int column = (_g4 - 1);
HXLINE( 593)						int tile;
HXDLIN( 593)						bool tile1;
HXDLIN( 593)						if ((columnIndex >= 0)) {
HXLINE( 593)							tile1 = (columnIndex < this->_data->length);
            						}
            						else {
HXLINE( 593)							tile1 = false;
            						}
HXDLIN( 593)						if (tile1) {
HXLINE( 593)							tile = this->_data->__get(columnIndex);
            						}
            						else {
HXLINE( 593)							tile = -1;
            						}
HXDLIN( 593)						 ::Dynamic tile2 = this->_tileObjects->__get(tile);
HXLINE( 595)						bool _hx_tmp;
HXDLIN( 595)						bool _hx_tmp1;
HXDLIN( 595)						if (::hx::IsNotNull( tile2 )) {
HXLINE( 595)							_hx_tmp1 = ( ( ::flixel::FlxBasic)(tile2) )->visible;
            						}
            						else {
HXLINE( 595)							_hx_tmp1 = false;
            						}
HXDLIN( 595)						if (_hx_tmp1) {
HXLINE( 595)							_hx_tmp = !(( ( ::flixel::FlxObject)(tile2) )->ignoreDrawDebug);
            						}
            						else {
HXLINE( 595)							_hx_tmp = false;
            						}
HXDLIN( 595)						if (_hx_tmp) {
HXLINE( 597)							rect1->x = (this->_helperPoint->x + (( (Float)(::hx::Mod(columnIndex,this->widthInTiles)) ) * rect1->width));
HXLINE( 598)							rect1->y = (this->_helperPoint->y + (( (Float)(::Math_obj::floor((( (Float)(columnIndex) ) / ( (Float)(this->widthInTiles) )))) ) * rect1->height));
HXLINE( 600)							 ::Dynamic color;
HXDLIN( 600)							if (::hx::IsNotNull( ( ( ::flixel::FlxObject)(tile2) )->debugBoundingBoxColor )) {
HXLINE( 600)								color = ( ( ::flixel::FlxObject)(tile2) )->debugBoundingBoxColor;
            							}
            							else {
HXLINE( 600)								color = this->getDebugBoundingBoxColor(( ( ::flixel::FlxObject)(tile2) )->allowCollisions);
            							}
HXLINE( 604)							if (::hx::IsNotNull( color )) {
HXLINE( 606)								int this1 = ( (int)(color) );
HXDLIN( 606)								::String colStr = HX_("0x",48,2a,00,00);
HXDLIN( 606)								::String colStr1 = ::StringTools_obj::hex(((this1 >> 24) & 255),2);
HXDLIN( 606)								::String colStr2 = ((colStr + colStr1) + ::StringTools_obj::hex(((this1 >> 16) & 255),2));
HXDLIN( 606)								::String colStr3 = (colStr2 + ::StringTools_obj::hex(((this1 >> 8) & 255),2));
HXDLIN( 606)								::String colStr4 = (colStr3 + ::StringTools_obj::hex((this1 & 255),2));
HXLINE( 607)								this->drawDebugBoundingBoxColor(camera->debugLayer->get_graphics(),rect1,( (int)(color) ));
            							}
            						}
HXLINE( 611)						columnIndex = (columnIndex + 1);
            					}
            				}
HXLINE( 614)				rowIndex = (rowIndex + this->widthInTiles);
            			}
            		}
HXLINE( 617)		if (!(rect1->_inPool)) {
HXLINE( 617)			rect1->_inPool = true;
HXDLIN( 617)			rect1->_weak = false;
HXDLIN( 617)			::flixel::math::FlxRect_obj::_pool->putUnsafe(rect1);
            		}
            	}


bool FlxTypedTilemap_obj::isOnScreen( ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_629_isOnScreen)
HXLINE( 630)		if (::hx::IsNull( camera )) {
HXLINE( 631)			camera = this->getDefaultCamera();
            		}
HXLINE( 633)		Float minX = ((this->x - this->offset->x) - (camera->scroll->x * this->scrollFactor->x));
HXLINE( 634)		Float minY = ((this->y - this->offset->y) - (camera->scroll->y * this->scrollFactor->y));
HXLINE( 636)		{
HXLINE( 636)			 ::flixel::math::FlxBasePoint this1 = this->_point;
HXDLIN( 636)			this1->set_x(minX);
HXDLIN( 636)			this1->set_y(minY);
            		}
HXLINE( 637)		 ::flixel::math::FlxBasePoint point = this->_point;
HXDLIN( 637)		bool contained;
HXDLIN( 637)		bool contained1;
HXDLIN( 637)		bool contained2;
HXDLIN( 637)		if (((point->x + (this->scaledTileWidth * ( (Float)(this->widthInTiles) ))) > camera->viewMarginX)) {
HXLINE( 637)			contained2 = (point->x < (( (Float)(camera->width) ) - camera->viewMarginX));
            		}
            		else {
HXLINE( 637)			contained2 = false;
            		}
HXDLIN( 637)		if (contained2) {
HXLINE( 637)			contained1 = ((point->y + (this->scaledTileHeight * ( (Float)(this->heightInTiles) ))) > camera->viewMarginY);
            		}
            		else {
HXLINE( 637)			contained1 = false;
            		}
HXDLIN( 637)		if (contained1) {
HXLINE( 637)			contained = (point->y < (( (Float)(camera->height) ) - camera->viewMarginY));
            		}
            		else {
HXLINE( 637)			contained = false;
            		}
HXDLIN( 637)		{
HXLINE( 637)			 ::flixel::math::FlxBasePoint _this = point;
HXDLIN( 637)			if (_this->_weak) {
HXLINE( 637)				_this->put();
            			}
            		}
HXDLIN( 637)		return contained;
            	}


void FlxTypedTilemap_obj::draw(){
            	HX_GC_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_644_draw)
HXLINE( 646)		if (::hx::IsNull( this->graphic )) {
HXLINE( 647)			return;
            		}
HXLINE( 649)		if (this->_checkBufferChanges) {
HXLINE( 651)			this->refreshBuffers();
HXLINE( 652)			this->_checkBufferChanges = false;
            		}
HXLINE( 655)		::Array< ::Dynamic> cameras = this->getCamerasLegacy();
HXLINE( 656)		 ::flixel::tile::FlxTilemapBuffer buffer;
HXLINE( 657)		int l = cameras->length;
HXLINE( 659)		{
HXLINE( 659)			int _g = 0;
HXDLIN( 659)			int _g1 = l;
HXDLIN( 659)			while((_g < _g1)){
HXLINE( 659)				_g = (_g + 1);
HXDLIN( 659)				int i = (_g - 1);
HXLINE( 661)				 ::flixel::FlxCamera camera = cameras->__get(i).StaticCast<  ::flixel::FlxCamera >();
HXLINE( 663)				bool _hx_tmp;
HXDLIN( 663)				bool _hx_tmp1;
HXDLIN( 663)				if (camera->visible) {
HXLINE( 663)					_hx_tmp1 = !(camera->exists);
            				}
            				else {
HXLINE( 663)					_hx_tmp1 = true;
            				}
HXDLIN( 663)				if (!(_hx_tmp1)) {
HXLINE( 663)					_hx_tmp = !(this->isOnScreen(camera));
            				}
            				else {
HXLINE( 663)					_hx_tmp = true;
            				}
HXDLIN( 663)				if (_hx_tmp) {
HXLINE( 664)					continue;
            				}
HXLINE( 666)				if (::hx::IsNull( this->_buffers->__get(i).StaticCast<  ::flixel::tile::FlxTilemapBuffer >() )) {
HXLINE( 667)					::Array< ::Dynamic> _hx_tmp2 = this->_buffers;
HXDLIN( 667)					 ::flixel::tile::FlxTilemapBuffer buffer1 =  ::flixel::tile::FlxTilemapBuffer_obj::__alloc( HX_CTX ,this->tileWidth,this->tileHeight,this->widthInTiles,this->heightInTiles,camera,this->scale->x,this->scale->y);
HXDLIN( 667)					buffer1->pixelPerfectRender = this->pixelPerfectRender;
HXDLIN( 667)					buffer1->antialiasing = this->antialiasing;
HXDLIN( 667)					_hx_tmp2[i] = buffer1;
            				}
HXLINE( 669)				buffer = this->_buffers->__get(i).StaticCast<  ::flixel::tile::FlxTilemapBuffer >();
HXLINE( 671)				if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 673)					if (buffer->isDirty(::hx::ObjectPtr<OBJ_>(this),camera)) {
HXLINE( 674)						this->drawTilemap(buffer,camera);
            					}
HXLINE( 676)					{
HXLINE( 676)						 ::flixel::math::FlxBasePoint this1 = this->getScreenPosition(this->_point,camera);
HXDLIN( 676)						 ::flixel::math::FlxBasePoint point = this->offset;
HXDLIN( 676)						{
HXLINE( 676)							Float y = point->y;
HXDLIN( 676)							this1->set_x((this1->x - point->x));
HXDLIN( 676)							this1->set_y((this1->y - y));
            						}
HXDLIN( 676)						{
HXLINE( 676)							 ::flixel::math::FlxBasePoint _this = point;
HXDLIN( 676)							if (_this->_weak) {
HXLINE( 676)								_this->put();
            							}
            						}
HXDLIN( 676)						 ::flixel::math::FlxBasePoint this2 = this1;
HXDLIN( 676)						Float y1 = buffer->y;
HXDLIN( 676)						this2->set_x((this2->x + buffer->x));
HXDLIN( 676)						this2->set_y((this2->y + y1));
HXDLIN( 676)						 ::flixel::math::FlxBasePoint this3 = this2;
HXDLIN( 676)						 ::openfl::geom::Point p = this->_flashPoint;
HXDLIN( 676)						p->x = this3->x;
HXDLIN( 676)						p->y = this3->y;
            					}
HXLINE( 677)					buffer->draw(camera,this->_flashPoint,this->scale->x,this->scale->y);
            				}
            				else {
HXLINE( 681)					this->drawTilemap(buffer,camera);
            				}
HXLINE( 685)				::flixel::FlxBasic_obj::visibleCount++;
            			}
            		}
HXLINE( 690)		if (::flixel::FlxG_obj::debugger->drawDebug) {
HXLINE( 691)			this->drawDebug();
            		}
            	}


void FlxTypedTilemap_obj::refreshBuffers(){
            	HX_GC_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_696_refreshBuffers)
HXLINE( 697)		::Array< ::Dynamic> cameras = this->getCamerasLegacy();
HXLINE( 698)		{
HXLINE( 698)			int _g = 0;
HXDLIN( 698)			int _g1 = cameras->length;
HXDLIN( 698)			while((_g < _g1)){
HXLINE( 698)				_g = (_g + 1);
HXDLIN( 698)				int i = (_g - 1);
HXLINE( 700)				 ::flixel::FlxCamera camera = cameras->__get(i).StaticCast<  ::flixel::FlxCamera >();
HXLINE( 701)				 ::flixel::tile::FlxTilemapBuffer buffer = this->_buffers->__get(i).StaticCast<  ::flixel::tile::FlxTilemapBuffer >();
HXLINE( 704)				if (::hx::IsNull( buffer )) {
HXLINE( 705)					::Array< ::Dynamic> _hx_tmp = this->_buffers;
HXDLIN( 705)					 ::flixel::tile::FlxTilemapBuffer buffer1 =  ::flixel::tile::FlxTilemapBuffer_obj::__alloc( HX_CTX ,this->tileWidth,this->tileHeight,this->widthInTiles,this->heightInTiles,camera,this->scale->x,this->scale->y);
HXDLIN( 705)					buffer1->pixelPerfectRender = this->pixelPerfectRender;
HXDLIN( 705)					buffer1->antialiasing = this->antialiasing;
HXDLIN( 705)					_hx_tmp[i] = buffer1;
            				}
            				else {
HXLINE( 707)					buffer->resize(this->tileWidth,this->tileHeight,this->widthInTiles,this->heightInTiles,camera,this->scale->x,this->scale->y);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxTypedTilemap_obj,refreshBuffers,(void))

void FlxTypedTilemap_obj::setDirty(::hx::Null< bool >  __o_dirty){
            		bool dirty = __o_dirty.Default(true);
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_718_setDirty)
HXLINE( 719)		if (::flixel::FlxG_obj::renderTile) {
HXLINE( 720)			return;
            		}
HXLINE( 722)		{
HXLINE( 722)			int _g = 0;
HXDLIN( 722)			::Array< ::Dynamic> _g1 = this->_buffers;
HXDLIN( 722)			while((_g < _g1->length)){
HXLINE( 722)				 ::flixel::tile::FlxTilemapBuffer buffer = _g1->__get(_g).StaticCast<  ::flixel::tile::FlxTilemapBuffer >();
HXDLIN( 722)				_g = (_g + 1);
HXLINE( 723)				if (::hx::IsNotNull( buffer )) {
HXLINE( 724)					buffer->dirty = dirty;
            				}
            			}
            		}
            	}


bool FlxTypedTilemap_obj::isOverlappingTile( ::flixel::FlxObject object, ::Dynamic filter, ::flixel::math::FlxBasePoint position){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_729_isOverlappingTile)
HXDLIN( 729)		return this->forEachOverlappingTileHelper(object,filter,position,true);
            	}


bool FlxTypedTilemap_obj::forEachOverlappingTile( ::flixel::FlxObject object, ::Dynamic func, ::flixel::math::FlxBasePoint position){
            		HX_BEGIN_LOCAL_FUNC_S1(::hx::LocalFunc,_hx_Closure_0, ::Dynamic,func) HXARGC(1)
            		bool _hx_run( ::Dynamic tile){
            			HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_735_forEachOverlappingTile)
HXLINE( 737)			func(tile);
HXLINE( 740)			return true;
            		}
            		HX_END_LOCAL_FUNC1(return)

            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_733_forEachOverlappingTile)
HXLINE( 734)		 ::Dynamic filter =  ::Dynamic(new _hx_Closure_0(func));
HXLINE( 743)		return this->forEachOverlappingTileHelper(object,filter,position,false);
            	}


bool FlxTypedTilemap_obj::forEachOverlappingTileHelper( ::flixel::FlxObject object, ::Dynamic filter, ::flixel::math::FlxBasePoint position,bool stopAtFirst){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_747_forEachOverlappingTileHelper)
HXLINE( 748)		Float xPos = this->x;
HXLINE( 749)		Float yPos = this->y;
HXLINE( 751)		if (::hx::IsNotNull( position )) {
HXLINE( 753)			xPos = position->x;
HXLINE( 754)			yPos = position->y;
HXLINE( 755)			{
HXLINE( 755)				 ::flixel::math::FlxBasePoint _this = position;
HXDLIN( 755)				if (_this->_weak) {
HXLINE( 755)					_this->put();
            				}
            			}
            		}
HXLINE( 764)		int value = ::Math_obj::floor(((object->x - xPos) / this->scaledTileWidth));
HXDLIN( 764)		int max = this->widthInTiles;
HXDLIN( 764)		Float lowerBound;
HXDLIN( 764)		if ((value < 0)) {
HXLINE( 764)			lowerBound = ( (Float)(0) );
            		}
            		else {
HXLINE( 764)			lowerBound = ( (Float)(value) );
            		}
HXDLIN( 764)		Float minTileX;
HXDLIN( 764)		bool minTileX1;
HXDLIN( 764)		if (::hx::IsNotNull( max )) {
HXLINE( 764)			minTileX1 = (lowerBound > max);
            		}
            		else {
HXLINE( 764)			minTileX1 = false;
            		}
HXDLIN( 764)		if (minTileX1) {
HXLINE( 764)			minTileX = ( (Float)(max) );
            		}
            		else {
HXLINE( 764)			minTileX = lowerBound;
            		}
HXDLIN( 764)		int minTileX2 = ::Std_obj::_hx_int(minTileX);
HXLINE( 765)		int value1 = ::Math_obj::floor(((object->y - yPos) / this->scaledTileHeight));
HXDLIN( 765)		int max1 = this->heightInTiles;
HXDLIN( 765)		Float lowerBound1;
HXDLIN( 765)		if ((value1 < 0)) {
HXLINE( 765)			lowerBound1 = ( (Float)(0) );
            		}
            		else {
HXLINE( 765)			lowerBound1 = ( (Float)(value1) );
            		}
HXDLIN( 765)		Float minTileY;
HXDLIN( 765)		bool minTileY1;
HXDLIN( 765)		if (::hx::IsNotNull( max1 )) {
HXLINE( 765)			minTileY1 = (lowerBound1 > max1);
            		}
            		else {
HXLINE( 765)			minTileY1 = false;
            		}
HXDLIN( 765)		if (minTileY1) {
HXLINE( 765)			minTileY = ( (Float)(max1) );
            		}
            		else {
HXLINE( 765)			minTileY = lowerBound1;
            		}
HXDLIN( 765)		int minTileY2 = ::Std_obj::_hx_int(minTileY);
HXLINE( 766)		Float object1 = object->x;
HXDLIN( 766)		Float value2 = ((object1 + object->get_width()) - xPos);
HXDLIN( 766)		int value3 = ::Math_obj::ceil((value2 / this->scaledTileWidth));
HXDLIN( 766)		int max2 = this->widthInTiles;
HXDLIN( 766)		Float lowerBound2;
HXDLIN( 766)		if ((value3 < 0)) {
HXLINE( 766)			lowerBound2 = ( (Float)(0) );
            		}
            		else {
HXLINE( 766)			lowerBound2 = ( (Float)(value3) );
            		}
HXDLIN( 766)		Float maxTileX;
HXDLIN( 766)		bool maxTileX1;
HXDLIN( 766)		if (::hx::IsNotNull( max2 )) {
HXLINE( 766)			maxTileX1 = (lowerBound2 > max2);
            		}
            		else {
HXLINE( 766)			maxTileX1 = false;
            		}
HXDLIN( 766)		if (maxTileX1) {
HXLINE( 766)			maxTileX = ( (Float)(max2) );
            		}
            		else {
HXLINE( 766)			maxTileX = lowerBound2;
            		}
HXDLIN( 766)		int maxTileX2 = ::Std_obj::_hx_int(maxTileX);
HXLINE( 767)		Float object2 = object->y;
HXDLIN( 767)		Float value4 = ((object2 + object->get_height()) - yPos);
HXDLIN( 767)		int value5 = ::Math_obj::ceil((value4 / this->scaledTileHeight));
HXDLIN( 767)		int max3 = this->heightInTiles;
HXDLIN( 767)		Float lowerBound3;
HXDLIN( 767)		if ((value5 < 0)) {
HXLINE( 767)			lowerBound3 = ( (Float)(0) );
            		}
            		else {
HXLINE( 767)			lowerBound3 = ( (Float)(value5) );
            		}
HXDLIN( 767)		Float maxTileY;
HXDLIN( 767)		bool maxTileY1;
HXDLIN( 767)		if (::hx::IsNotNull( max3 )) {
HXLINE( 767)			maxTileY1 = (lowerBound3 > max3);
            		}
            		else {
HXLINE( 767)			maxTileY1 = false;
            		}
HXDLIN( 767)		if (maxTileY1) {
HXLINE( 767)			maxTileY = ( (Float)(max3) );
            		}
            		else {
HXLINE( 767)			maxTileY = lowerBound3;
            		}
HXDLIN( 767)		int maxTileY2 = ::Std_obj::_hx_int(maxTileY);
HXLINE( 769)		bool result = false;
HXLINE( 770)		{
HXLINE( 770)			int _g = minTileY2;
HXDLIN( 770)			int _g1 = maxTileY2;
HXDLIN( 770)			while((_g < _g1)){
HXLINE( 770)				_g = (_g + 1);
HXDLIN( 770)				int row = (_g - 1);
HXLINE( 772)				{
HXLINE( 772)					int _g2 = minTileX2;
HXDLIN( 772)					int _g3 = maxTileX2;
HXDLIN( 772)					while((_g2 < _g3)){
HXLINE( 772)						_g2 = (_g2 + 1);
HXDLIN( 772)						int column = (_g2 - 1);
HXLINE( 774)						int mapIndex;
HXDLIN( 774)						bool mapIndex1;
HXDLIN( 774)						bool mapIndex2;
HXDLIN( 774)						if ((column >= 0)) {
HXLINE( 774)							mapIndex2 = (column < this->widthInTiles);
            						}
            						else {
HXLINE( 774)							mapIndex2 = false;
            						}
HXDLIN( 774)						if (mapIndex2) {
HXLINE( 774)							if ((row >= 0)) {
HXLINE( 774)								mapIndex1 = (row < this->heightInTiles);
            							}
            							else {
HXLINE( 774)								mapIndex1 = false;
            							}
            						}
            						else {
HXLINE( 774)							mapIndex1 = false;
            						}
HXDLIN( 774)						if (mapIndex1) {
HXLINE( 774)							mapIndex = ((row * this->widthInTiles) + column);
            						}
            						else {
HXLINE( 774)							mapIndex = -1;
            						}
HXDLIN( 774)						int tile;
HXDLIN( 774)						bool tile1;
HXDLIN( 774)						if ((mapIndex >= 0)) {
HXLINE( 774)							tile1 = (mapIndex < this->_data->length);
            						}
            						else {
HXLINE( 774)							tile1 = false;
            						}
HXDLIN( 774)						if (tile1) {
HXLINE( 774)							tile = this->_data->__get(mapIndex);
            						}
            						else {
HXLINE( 774)							tile = -1;
            						}
HXDLIN( 774)						 ::Dynamic tile2 = this->_tileObjects->__get(tile);
HXLINE( 775)						if (::hx::IsNull( tile2 )) {
HXLINE( 776)							continue;
            						}
HXLINE( 777)						( ( ::flixel::tile::FlxTile)(tile2) )->orientAt(xPos,yPos,column,row);
HXLINE( 778)						bool _hx_tmp;
HXDLIN( 778)						if (( (bool)(( ( ::flixel::tile::FlxTile)(tile2) )->overlapsObject(object)) )) {
HXLINE( 778)							if (::hx::IsNotNull( filter )) {
HXLINE( 778)								_hx_tmp = ( (bool)(filter(tile2)) );
            							}
            							else {
HXLINE( 778)								_hx_tmp = true;
            							}
            						}
            						else {
HXLINE( 778)							_hx_tmp = false;
            						}
HXDLIN( 778)						if (_hx_tmp) {
HXLINE( 780)							if (stopAtFirst) {
HXLINE( 781)								return true;
            							}
HXLINE( 783)							result = true;
            						}
            					}
            				}
            			}
            		}
HXLINE( 788)		return result;
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxTypedTilemap_obj,forEachOverlappingTileHelper,return )

bool FlxTypedTilemap_obj::objectOverlapsTiles( ::Dynamic object, ::Dynamic callback, ::flixel::math::FlxBasePoint position,::hx::Null< bool >  __o_isCollision){
            		HX_BEGIN_LOCAL_FUNC_S4(::hx::LocalFunc,_hx_Closure_0,::Array< bool >,results, ::Dynamic,object,bool,isCollision, ::Dynamic,callback) HXARGC(1)
            		void _hx_run( ::Dynamic tile){
            			HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_796_objectOverlapsTiles)
HXLINE( 797)			bool overlapFound;
HXDLIN( 797)			if (!(((( ( ::flixel::FlxObject)(tile) )->allowCollisions & 4369) > 0))) {
HXLINE( 797)				overlapFound = !(isCollision);
            			}
            			else {
HXLINE( 797)				overlapFound = true;
            			}
HXLINE( 798)			bool each;
HXDLIN( 798)			if (overlapFound) {
HXLINE( 798)				each = ::hx::IsNotNull( callback );
            			}
            			else {
HXLINE( 798)				each = false;
            			}
HXDLIN( 798)			if (each) {
HXLINE( 800)				overlapFound = ( (bool)(callback(tile,object)) );
            			}
HXLINE( 803)			if (overlapFound) {
HXLINE( 805)				if (::hx::IsNotNull( ( ( ::flixel::tile::FlxTile)(tile) )->callbackFunction )) {
HXLINE( 807)					( ( ::flixel::tile::FlxTile)(tile) )->callbackFunction(tile,object);
            				}
HXLINE( 811)				bool each1;
HXDLIN( 811)				if (!(((( ( ::flixel::FlxObject)(tile) )->allowCollisions & 4369) > 0))) {
HXLINE( 811)					each1 = !(isCollision);
            				}
            				else {
HXLINE( 811)					each1 = true;
            				}
HXDLIN( 811)				if (each1) {
HXLINE( 813)					( ( ::flixel::tile::FlxTile)(tile) )->onCollide->dispatch(( ( ::flixel::tile::FlxTile)(tile) ),( ( ::flixel::FlxObject)(object) ));
HXLINE( 814)					results[0] = true;
            				}
            			}
            		}
            		HX_END_LOCAL_FUNC1((void))

            		bool isCollision = __o_isCollision.Default(true);
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_792_objectOverlapsTiles)
HXLINE( 793)		::Array< bool > results = ::Array_obj< bool >::fromData( _hx_array_data_54257268_37,1);
HXLINE( 795)		 ::Dynamic each =  ::Dynamic(new _hx_Closure_0(results,object,isCollision,callback));
HXLINE( 819)		this->forEachOverlappingTile(( ( ::flixel::FlxObject)(object) ),each,position);
HXLINE( 821)		return results->__get(0);
            	}


int FlxTypedTilemap_obj::getColumnAt(Float worldX,::hx::Null< bool >  __o_bind){
            		bool bind = __o_bind.Default(false);
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_825_getColumnAt)
HXLINE( 826)		int result = ::Math_obj::floor(((worldX - this->x) / this->scaledTileWidth));
HXLINE( 828)		if (bind) {
HXLINE( 829)			if ((result < 0)) {
HXLINE( 829)				return 0;
            			}
            			else {
HXLINE( 829)				if ((result >= this->widthInTiles)) {
HXLINE( 829)					return (this->widthInTiles - 1);
            				}
            				else {
HXLINE( 829)					return result;
            				}
            			}
            		}
HXLINE( 831)		return result;
            	}


int FlxTypedTilemap_obj::getRowAt(Float worldY,::hx::Null< bool >  __o_bind){
            		bool bind = __o_bind.Default(false);
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_835_getRowAt)
HXLINE( 836)		int result = ::Math_obj::floor(((worldY - this->y) / this->scaledTileHeight));
HXLINE( 838)		if (bind) {
HXLINE( 839)			if ((result < 0)) {
HXLINE( 839)				return 0;
            			}
            			else {
HXLINE( 839)				if ((result >= this->heightInTiles)) {
HXLINE( 839)					return (this->heightInTiles - 1);
            				}
            				else {
HXLINE( 839)					return result;
            				}
            			}
            		}
HXLINE( 841)		return result;
            	}


Float FlxTypedTilemap_obj::getColumnPos(Float column,::hx::Null< bool >  __o_midpoint){
            		bool midpoint = __o_midpoint.Default(false);
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_846_getColumnPos)
HXDLIN( 846)		Float _hx_tmp;
HXDLIN( 846)		if (midpoint) {
HXDLIN( 846)			_hx_tmp = (this->scaledTileWidth * ((Float)0.5));
            		}
            		else {
HXDLIN( 846)			_hx_tmp = ( (Float)(0) );
            		}
HXDLIN( 846)		return ((this->x + (column * this->scaledTileWidth)) + _hx_tmp);
            	}


Float FlxTypedTilemap_obj::getRowPos(int row,::hx::Null< bool >  __o_midpoint){
            		bool midpoint = __o_midpoint.Default(false);
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_851_getRowPos)
HXDLIN( 851)		Float _hx_tmp;
HXDLIN( 851)		if (midpoint) {
HXDLIN( 851)			_hx_tmp = (this->scaledTileHeight * ((Float)0.5));
            		}
            		else {
HXDLIN( 851)			_hx_tmp = ( (Float)(0) );
            		}
HXDLIN( 851)		return ((this->y + (( (Float)(row) ) * this->scaledTileHeight)) + _hx_tmp);
            	}


::Array< ::Dynamic> FlxTypedTilemap_obj::getTileCoords(int tileIndex,::hx::Null< bool >  __o_midpoint){
            		bool midpoint = __o_midpoint.Default(true);
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_864_getTileCoords)
HXDLIN( 864)		return this->getAllTilePos(tileIndex,midpoint);
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTypedTilemap_obj,getTileCoords,return )

void FlxTypedTilemap_obj::follow( ::flixel::FlxCamera camera,::hx::Null< int >  __o_border,::hx::Null< bool >  __o_updateWorld){
            		int border = __o_border.Default(0);
            		bool updateWorld = __o_updateWorld.Default(true);
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_877_follow)
HXLINE( 878)		if (::hx::IsNull( camera )) {
HXLINE( 879)			camera = this->getDefaultCamera();
            		}
HXLINE( 881)		camera->setScrollBoundsRect((this->x + (( (Float)(border) ) * this->scaledTileWidth)),(this->y + (( (Float)(border) ) * this->scaledTileHeight)),((( (Float)(this->widthInTiles) ) * this->scaledTileWidth) - ((( (Float)(border) ) * this->scaledTileWidth) * ( (Float)(2) ))),((( (Float)(this->heightInTiles) ) * this->scaledTileHeight) - ((( (Float)(border) ) * this->scaledTileHeight) * ( (Float)(2) ))),updateWorld);
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxTypedTilemap_obj,follow,(void))

bool FlxTypedTilemap_obj::ray( ::flixel::math::FlxBasePoint start, ::flixel::math::FlxBasePoint end, ::flixel::math::FlxBasePoint result){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_903_ray)
HXLINE( 905)		 ::flixel::math::FlxBasePoint trimmedStart = this->calcRayEntry(start,end,null());
HXLINE( 906)		 ::flixel::math::FlxBasePoint result1 = null();
HXDLIN( 906)		 ::flixel::math::FlxBasePoint trimmedEnd = this->calcRayEntry(end,start,result1);
HXLINE( 908)		{
HXLINE( 908)			 ::flixel::math::FlxBasePoint _this = start;
HXDLIN( 908)			if (_this->_weak) {
HXLINE( 908)				_this->put();
            			}
            		}
HXLINE( 909)		{
HXLINE( 909)			 ::flixel::math::FlxBasePoint _this1 = end;
HXDLIN( 909)			if (_this1->_weak) {
HXLINE( 909)				_this1->put();
            			}
            		}
HXLINE( 911)		bool _hx_tmp;
HXDLIN( 911)		if (::hx::IsNotNull( trimmedStart )) {
HXLINE( 911)			_hx_tmp = ::hx::IsNull( trimmedEnd );
            		}
            		else {
HXLINE( 911)			_hx_tmp = true;
            		}
HXDLIN( 911)		if (_hx_tmp) {
HXLINE( 913)			::flixel::util::FlxDestroyUtil_obj::put(trimmedStart);
HXLINE( 914)			::flixel::util::FlxDestroyUtil_obj::put(trimmedEnd);
HXLINE( 915)			return true;
            		}
HXLINE( 918)		start = trimmedStart;
HXLINE( 919)		end = trimmedEnd;
HXLINE( 927)		Float worldY = start->y;
HXDLIN( 927)		int column = this->getColumnAt(start->x,null());
HXDLIN( 927)		int row = this->getRowAt(worldY,null());
HXDLIN( 927)		int startIndex;
HXDLIN( 927)		bool startIndex1;
HXDLIN( 927)		bool startIndex2;
HXDLIN( 927)		if ((column >= 0)) {
HXLINE( 927)			startIndex2 = (column < this->widthInTiles);
            		}
            		else {
HXLINE( 927)			startIndex2 = false;
            		}
HXDLIN( 927)		if (startIndex2) {
HXLINE( 927)			if ((row >= 0)) {
HXLINE( 927)				startIndex1 = (row < this->heightInTiles);
            			}
            			else {
HXLINE( 927)				startIndex1 = false;
            			}
            		}
            		else {
HXLINE( 927)			startIndex1 = false;
            		}
HXDLIN( 927)		if (startIndex1) {
HXLINE( 927)			startIndex = ((row * this->widthInTiles) + column);
            		}
            		else {
HXLINE( 927)			startIndex = -1;
            		}
HXLINE( 928)		Float worldY1 = end->y;
HXDLIN( 928)		int column1 = this->getColumnAt(end->x,null());
HXDLIN( 928)		int row1 = this->getRowAt(worldY1,null());
HXDLIN( 928)		int endIndex;
HXDLIN( 928)		bool endIndex1;
HXDLIN( 928)		bool endIndex2;
HXDLIN( 928)		if ((column1 >= 0)) {
HXLINE( 928)			endIndex2 = (column1 < this->widthInTiles);
            		}
            		else {
HXLINE( 928)			endIndex2 = false;
            		}
HXDLIN( 928)		if (endIndex2) {
HXLINE( 928)			if ((row1 >= 0)) {
HXLINE( 928)				endIndex1 = (row1 < this->heightInTiles);
            			}
            			else {
HXLINE( 928)				endIndex1 = false;
            			}
            		}
            		else {
HXLINE( 928)			endIndex1 = false;
            		}
HXDLIN( 928)		if (endIndex1) {
HXLINE( 928)			endIndex = ((row1 * this->widthInTiles) + column1);
            		}
            		else {
HXLINE( 928)			endIndex = -1;
            		}
HXLINE( 931)		int tile;
HXDLIN( 931)		bool tile1;
HXDLIN( 931)		if ((startIndex >= 0)) {
HXLINE( 931)			tile1 = (startIndex < this->_data->length);
            		}
            		else {
HXLINE( 931)			tile1 = false;
            		}
HXDLIN( 931)		if (tile1) {
HXLINE( 931)			tile = this->_data->__get(startIndex);
            		}
            		else {
HXLINE( 931)			tile = -1;
            		}
HXDLIN( 931)		 ::Dynamic tile2 = this->_tileObjects->__get(tile);
HXLINE( 932)		bool _hx_tmp1;
HXDLIN( 932)		if (::hx::IsNotNull( tile2 )) {
HXLINE( 932)			_hx_tmp1 = ((( ( ::flixel::FlxObject)(tile2) )->allowCollisions & 4369) > 0);
            		}
            		else {
HXLINE( 932)			_hx_tmp1 = false;
            		}
HXDLIN( 932)		if (_hx_tmp1) {
HXLINE( 934)			if (::hx::IsNotNull( result )) {
HXLINE( 935)				{
HXLINE( 935)					Float y = start->y;
HXDLIN( 935)					result->set_x(start->x);
HXDLIN( 935)					result->set_y(y);
            				}
HXDLIN( 935)				{
HXLINE( 935)					 ::flixel::math::FlxBasePoint _this2 = start;
HXDLIN( 935)					if (_this2->_weak) {
HXLINE( 935)						_this2->put();
            					}
            				}
            			}
HXLINE( 937)			{
HXLINE( 937)				trimmedStart->put();
HXDLIN( 937)				trimmedEnd->put();
            			}
HXLINE( 938)			return false;
            		}
HXLINE( 941)		int startTileX = ::hx::Mod(startIndex,this->widthInTiles);
HXLINE( 942)		int startTileY = ::Std_obj::_hx_int((( (Float)(startIndex) ) / ( (Float)(this->widthInTiles) )));
HXLINE( 943)		int endTileX = ::hx::Mod(endIndex,this->widthInTiles);
HXLINE( 944)		int endTileY = ::Std_obj::_hx_int((( (Float)(endIndex) ) / ( (Float)(this->widthInTiles) )));
HXLINE( 945)		int hitIndex = -1;
HXLINE( 947)		if ((start->x == end->x)) {
HXLINE( 949)			hitIndex = this->checkColumn(startTileX,startTileY,endTileY);
HXLINE( 950)			bool _hx_tmp2;
HXDLIN( 950)			if ((hitIndex != -1)) {
HXLINE( 950)				_hx_tmp2 = ::hx::IsNotNull( result );
            			}
            			else {
HXLINE( 950)				_hx_tmp2 = false;
            			}
HXDLIN( 950)			if (_hx_tmp2) {
HXLINE( 953)				{
HXLINE( 953)					bool midpoint = false;
HXDLIN( 953)					 ::flixel::math::FlxBasePoint p;
HXDLIN( 953)					bool p1;
HXDLIN( 953)					if ((hitIndex >= 0)) {
HXLINE( 953)						p1 = (hitIndex < this->_data->length);
            					}
            					else {
HXLINE( 953)						p1 = false;
            					}
HXDLIN( 953)					if (p1) {
HXLINE( 953)						int column2 = ::hx::Mod(hitIndex,this->widthInTiles);
HXDLIN( 953)						int row2 = ::Std_obj::_hx_int((( (Float)(hitIndex) ) / ( (Float)(this->widthInTiles) )));
HXDLIN( 953)						Float x = this->getColumnPos(( (Float)(column2) ),midpoint);
HXDLIN( 953)						Float y1 = this->getRowPos(row2,midpoint);
HXDLIN( 953)						 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(x,y1);
HXDLIN( 953)						point->_inPool = false;
HXDLIN( 953)						p = point;
            					}
            					else {
HXLINE( 953)						p = null();
            					}
HXDLIN( 953)					{
HXLINE( 953)						Float y2 = p->y;
HXDLIN( 953)						result->set_x(p->x);
HXDLIN( 953)						result->set_y(y2);
            					}
HXDLIN( 953)					{
HXLINE( 953)						 ::flixel::math::FlxBasePoint _this3 = p;
HXDLIN( 953)						if (_this3->_weak) {
HXLINE( 953)							_this3->put();
            						}
            					}
            				}
HXLINE( 954)				result->set_x(start->x);
HXLINE( 955)				if ((start->y > end->y)) {
HXLINE( 956)					result->set_y((result->y + this->scaledTileHeight));
            				}
            			}
            		}
            		else {
HXLINE( 962)			Float m = ((start->y - end->y) / (start->x - end->x));
HXLINE( 964)			Float b = (start->y - (m * start->x));
HXLINE( 966)			bool movesRight = (start->x < end->x);
HXLINE( 967)			int inc;
HXDLIN( 967)			if (movesRight) {
HXLINE( 967)				inc = 1;
            			}
            			else {
HXLINE( 967)				inc = -1;
            			}
HXLINE( 968)			int offset;
HXDLIN( 968)			if (movesRight) {
HXLINE( 968)				offset = 1;
            			}
            			else {
HXLINE( 968)				offset = 0;
            			}
HXLINE( 969)			int tileX = startTileX;
HXLINE( 970)			int lastTileY = startTileY;
HXLINE( 972)			while((tileX != endTileX)){
HXLINE( 974)				Float xPos = this->getColumnPos(( (Float)((tileX + offset)) ),null());
HXLINE( 975)				Float yPos = ((m * this->getColumnPos(( (Float)((tileX + offset)) ),null())) + b);
HXLINE( 976)				int tileY = this->getRowAt(yPos,null());
HXLINE( 977)				hitIndex = this->checkColumn(tileX,lastTileY,tileY);
HXLINE( 978)				if ((hitIndex != -1)) {
HXLINE( 979)					goto _hx_goto_44;
            				}
HXLINE( 980)				lastTileY = tileY;
HXLINE( 981)				tileX = (tileX + inc);
            			}
            			_hx_goto_44:;
HXLINE( 984)			if ((hitIndex == -1)) {
HXLINE( 985)				hitIndex = this->checkColumn(endTileX,lastTileY,endTileY);
            			}
HXLINE( 987)			bool _hx_tmp3;
HXDLIN( 987)			if ((hitIndex != -1)) {
HXLINE( 987)				_hx_tmp3 = ::hx::IsNotNull( result );
            			}
            			else {
HXLINE( 987)				_hx_tmp3 = false;
            			}
HXDLIN( 987)			if (_hx_tmp3) {
HXLINE( 989)				{
HXLINE( 989)					bool midpoint1 = false;
HXDLIN( 989)					 ::flixel::math::FlxBasePoint p2;
HXDLIN( 989)					bool p3;
HXDLIN( 989)					if ((hitIndex >= 0)) {
HXLINE( 989)						p3 = (hitIndex < this->_data->length);
            					}
            					else {
HXLINE( 989)						p3 = false;
            					}
HXDLIN( 989)					if (p3) {
HXLINE( 989)						int column3 = ::hx::Mod(hitIndex,this->widthInTiles);
HXDLIN( 989)						int row3 = ::Std_obj::_hx_int((( (Float)(hitIndex) ) / ( (Float)(this->widthInTiles) )));
HXDLIN( 989)						Float x1 = this->getColumnPos(( (Float)(column3) ),midpoint1);
HXDLIN( 989)						Float y3 = this->getRowPos(row3,midpoint1);
HXDLIN( 989)						 ::flixel::math::FlxBasePoint point1 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(x1,y3);
HXDLIN( 989)						point1->_inPool = false;
HXDLIN( 989)						p2 = point1;
            					}
            					else {
HXLINE( 989)						p2 = null();
            					}
HXDLIN( 989)					{
HXLINE( 989)						Float y4 = p2->y;
HXDLIN( 989)						result->set_x(p2->x);
HXDLIN( 989)						result->set_y(y4);
            					}
HXDLIN( 989)					{
HXLINE( 989)						 ::flixel::math::FlxBasePoint _this4 = p2;
HXDLIN( 989)						if (_this4->_weak) {
HXLINE( 989)							_this4->put();
            						}
            					}
            				}
HXLINE( 990)				if ((::Std_obj::_hx_int((( (Float)(hitIndex) ) / ( (Float)(this->widthInTiles) ))) == lastTileY)) {
HXLINE( 992)					if ((start->x > end->x)) {
HXLINE( 993)						result->set_x((result->x + this->scaledTileWidth));
            					}
HXLINE( 996)					result->set_y(((m * result->x) + b));
            				}
            				else {
HXLINE(1001)					if ((start->y > end->y)) {
HXLINE(1004)						result->set_y((result->y + this->scaledTileHeight));
            					}
HXLINE(1009)					result->set_x(((result->y - b) / m));
            				}
            			}
            		}
HXLINE(1014)		{
HXLINE(1014)			trimmedStart->put();
HXDLIN(1014)			trimmedEnd->put();
            		}
HXLINE(1015)		return (hitIndex == -1);
            	}


int FlxTypedTilemap_obj::checkColumn(int x,int startY,int endY){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1019_checkColumn)
HXLINE(1020)		if ((startY < 0)) {
HXLINE(1021)			startY = 0;
            		}
HXLINE(1023)		if ((endY < 0)) {
HXLINE(1024)			endY = 0;
            		}
HXLINE(1026)		if ((startY > (this->heightInTiles - 1))) {
HXLINE(1027)			startY = (this->heightInTiles - 1);
            		}
HXLINE(1029)		if ((endY > (this->heightInTiles - 1))) {
HXLINE(1030)			endY = (this->heightInTiles - 1);
            		}
HXLINE(1032)		int y = startY;
HXLINE(1033)		int step;
HXDLIN(1033)		if ((startY <= endY)) {
HXLINE(1033)			step = 1;
            		}
            		else {
HXLINE(1033)			step = -1;
            		}
HXLINE(1034)		while(true){
HXLINE(1036)			int index;
HXDLIN(1036)			bool index1;
HXDLIN(1036)			bool index2;
HXDLIN(1036)			if ((x >= 0)) {
HXLINE(1036)				index2 = (x < this->widthInTiles);
            			}
            			else {
HXLINE(1036)				index2 = false;
            			}
HXDLIN(1036)			if (index2) {
HXLINE(1036)				if ((y >= 0)) {
HXLINE(1036)					index1 = (y < this->heightInTiles);
            				}
            				else {
HXLINE(1036)					index1 = false;
            				}
            			}
            			else {
HXLINE(1036)				index1 = false;
            			}
HXDLIN(1036)			if (index1) {
HXLINE(1036)				index = ((y * this->widthInTiles) + x);
            			}
            			else {
HXLINE(1036)				index = -1;
            			}
HXLINE(1037)			int tile;
HXDLIN(1037)			bool tile1;
HXDLIN(1037)			if ((index >= 0)) {
HXLINE(1037)				tile1 = (index < this->_data->length);
            			}
            			else {
HXLINE(1037)				tile1 = false;
            			}
HXDLIN(1037)			if (tile1) {
HXLINE(1037)				tile = this->_data->__get(index);
            			}
            			else {
HXLINE(1037)				tile = -1;
            			}
HXDLIN(1037)			 ::Dynamic tile2 = this->_tileObjects->__get(tile);
HXLINE(1038)			bool _hx_tmp;
HXDLIN(1038)			if (::hx::IsNotNull( tile2 )) {
HXLINE(1038)				_hx_tmp = ((( ( ::flixel::FlxObject)(tile2) )->allowCollisions & 4369) > 0);
            			}
            			else {
HXLINE(1038)				_hx_tmp = false;
            			}
HXDLIN(1038)			if (_hx_tmp) {
HXLINE(1039)				return index;
            			}
HXLINE(1041)			if ((y == endY)) {
HXLINE(1042)				goto _hx_goto_46;
            			}
HXLINE(1044)			y = (y + step);
            		}
            		_hx_goto_46:;
HXLINE(1047)		return -1;
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxTypedTilemap_obj,checkColumn,return )

bool FlxTypedTilemap_obj::rayStep( ::flixel::math::FlxBasePoint start, ::flixel::math::FlxBasePoint end, ::flixel::math::FlxBasePoint result,::hx::Null< Float >  __o_resolution){
            		Float resolution = __o_resolution.Default(1);
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1065_rayStep)
HXLINE(1066)		Float step = this->scaledTileWidth;
HXLINE(1068)		if ((this->scaledTileHeight < this->scaledTileWidth)) {
HXLINE(1069)			step = this->scaledTileHeight;
            		}
HXLINE(1071)		step = (step / resolution);
HXLINE(1072)		Float deltaX = (end->x - start->x);
HXLINE(1073)		Float deltaY = (end->y - start->y);
HXLINE(1074)		Float distance = ::Math_obj::sqrt(((deltaX * deltaX) + (deltaY * deltaY)));
HXLINE(1075)		int steps = ::Math_obj::ceil((distance / step));
HXLINE(1076)		Float stepX = (deltaX / ( (Float)(steps) ));
HXLINE(1077)		Float stepY = (deltaY / ( (Float)(steps) ));
HXLINE(1078)		Float curX = ((start->x - stepX) - this->x);
HXLINE(1079)		Float curY = ((start->y - stepY) - this->y);
HXLINE(1080)		int i = 0;
HXLINE(1082)		{
HXLINE(1082)			 ::flixel::math::FlxBasePoint _this = start;
HXDLIN(1082)			if (_this->_weak) {
HXLINE(1082)				_this->put();
            			}
            		}
HXLINE(1083)		{
HXLINE(1083)			 ::flixel::math::FlxBasePoint _this1 = end;
HXDLIN(1083)			if (_this1->_weak) {
HXLINE(1083)				_this1->put();
            			}
            		}
HXLINE(1085)		while((i < steps)){
HXLINE(1087)			curX = (curX + stepX);
HXLINE(1088)			curY = (curY + stepY);
HXLINE(1090)			bool _hx_tmp;
HXDLIN(1090)			bool _hx_tmp1;
HXDLIN(1090)			bool _hx_tmp2;
HXDLIN(1090)			if (!((curX < 0))) {
HXLINE(1090)				_hx_tmp2 = (curX > (( (Float)(this->widthInTiles) ) * this->scaledTileWidth));
            			}
            			else {
HXLINE(1090)				_hx_tmp2 = true;
            			}
HXDLIN(1090)			if (!(_hx_tmp2)) {
HXLINE(1090)				_hx_tmp1 = (curY < 0);
            			}
            			else {
HXLINE(1090)				_hx_tmp1 = true;
            			}
HXDLIN(1090)			if (!(_hx_tmp1)) {
HXLINE(1090)				_hx_tmp = (curY > (( (Float)(this->heightInTiles) ) * this->scaledTileHeight));
            			}
            			else {
HXLINE(1090)				_hx_tmp = true;
            			}
HXDLIN(1090)			if (_hx_tmp) {
HXLINE(1092)				i = (i + 1);
HXLINE(1093)				continue;
            			}
HXLINE(1096)			int tileX = ::Math_obj::floor((curX / this->scaledTileWidth));
HXLINE(1097)			int tileY = ::Math_obj::floor((curY / this->scaledTileHeight));
HXLINE(1099)			int mapIndex;
HXDLIN(1099)			bool mapIndex1;
HXDLIN(1099)			bool mapIndex2;
HXDLIN(1099)			if ((tileX >= 0)) {
HXLINE(1099)				mapIndex2 = (tileX < this->widthInTiles);
            			}
            			else {
HXLINE(1099)				mapIndex2 = false;
            			}
HXDLIN(1099)			if (mapIndex2) {
HXLINE(1099)				if ((tileY >= 0)) {
HXLINE(1099)					mapIndex1 = (tileY < this->heightInTiles);
            				}
            				else {
HXLINE(1099)					mapIndex1 = false;
            				}
            			}
            			else {
HXLINE(1099)				mapIndex1 = false;
            			}
HXDLIN(1099)			if (mapIndex1) {
HXLINE(1099)				mapIndex = ((tileY * this->widthInTiles) + tileX);
            			}
            			else {
HXLINE(1099)				mapIndex = -1;
            			}
HXDLIN(1099)			int tile;
HXDLIN(1099)			bool tile1;
HXDLIN(1099)			if ((mapIndex >= 0)) {
HXLINE(1099)				tile1 = (mapIndex < this->_data->length);
            			}
            			else {
HXLINE(1099)				tile1 = false;
            			}
HXDLIN(1099)			if (tile1) {
HXLINE(1099)				tile = this->_data->__get(mapIndex);
            			}
            			else {
HXLINE(1099)				tile = -1;
            			}
HXDLIN(1099)			 ::Dynamic tile2 = this->_tileObjects->__get(tile);
HXLINE(1100)			bool _hx_tmp3;
HXDLIN(1100)			if (::hx::IsNotNull( tile2 )) {
HXLINE(1100)				_hx_tmp3 = ((( ( ::flixel::FlxObject)(tile2) )->allowCollisions & 4369) > 0);
            			}
            			else {
HXLINE(1100)				_hx_tmp3 = false;
            			}
HXDLIN(1100)			if (_hx_tmp3) {
HXLINE(1103)				tileX = (tileX * ::Std_obj::_hx_int(this->scaledTileWidth));
HXLINE(1104)				tileY = (tileY * ::Std_obj::_hx_int(this->scaledTileHeight));
HXLINE(1105)				Float rx = ( (Float)(0) );
HXLINE(1106)				Float ry = ( (Float)(0) );
HXLINE(1108)				Float lx = (curX - stepX);
HXLINE(1109)				Float ly = (curY - stepY);
HXLINE(1107)				Float q = ( (Float)(tileX) );
HXLINE(1114)				if ((deltaX < 0)) {
HXLINE(1116)					q = (q + this->scaledTileWidth);
            				}
HXLINE(1119)				rx = q;
HXLINE(1120)				ry = (ly + (stepY * ((q - lx) / stepX)));
HXLINE(1122)				bool _hx_tmp4;
HXDLIN(1122)				if ((ry >= tileY)) {
HXLINE(1122)					_hx_tmp4 = (ry <= (tileY + this->scaledTileHeight));
            				}
            				else {
HXLINE(1122)					_hx_tmp4 = false;
            				}
HXDLIN(1122)				if (_hx_tmp4) {
HXLINE(1124)					if (::hx::IsNull( result )) {
HXLINE(1126)						 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN(1126)						point->_inPool = false;
HXDLIN(1126)						result = point;
            					}
HXLINE(1129)					{
HXLINE(1129)						Float y = (ry + this->y);
HXDLIN(1129)						result->set_x((rx + this->x));
HXDLIN(1129)						result->set_y(y);
            					}
HXLINE(1130)					return false;
            				}
HXLINE(1134)				q = ( (Float)(tileY) );
HXLINE(1136)				if ((deltaY < 0)) {
HXLINE(1138)					q = (q + this->scaledTileHeight);
            				}
HXLINE(1141)				rx = (lx + (stepX * ((q - ly) / stepY)));
HXLINE(1142)				ry = q;
HXLINE(1144)				bool _hx_tmp5;
HXDLIN(1144)				if ((rx >= tileX)) {
HXLINE(1144)					_hx_tmp5 = (rx <= (tileX + this->scaledTileWidth));
            				}
            				else {
HXLINE(1144)					_hx_tmp5 = false;
            				}
HXDLIN(1144)				if (_hx_tmp5) {
HXLINE(1146)					if (::hx::IsNull( result )) {
HXLINE(1148)						 ::flixel::math::FlxBasePoint point1 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN(1148)						point1->_inPool = false;
HXDLIN(1148)						result = point1;
            					}
HXLINE(1151)					{
HXLINE(1151)						Float y1 = (ry + this->y);
HXDLIN(1151)						result->set_x((rx + this->x));
HXDLIN(1151)						result->set_y(y1);
            					}
HXLINE(1152)					return false;
            				}
HXLINE(1155)				return true;
            			}
HXLINE(1157)			i = (i + 1);
            		}
HXLINE(1160)		return true;
            	}


 ::flixel::FlxSprite FlxTypedTilemap_obj::tileToSprite(int tileX,int tileY,::hx::Null< int >  __o_newTile, ::Dynamic spriteFactory){
            		int newTile = __o_newTile.Default(0);
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1173_tileToSprite)
HXLINE(1174)		if (::hx::IsNull( spriteFactory )) {
HXLINE(1175)			spriteFactory = this->defaultTileToSprite_dyn();
            		}
HXLINE(1177)		int mapIndex;
HXDLIN(1177)		bool mapIndex1;
HXDLIN(1177)		bool mapIndex2;
HXDLIN(1177)		if ((tileX >= 0)) {
HXLINE(1177)			mapIndex2 = (tileX < this->widthInTiles);
            		}
            		else {
HXLINE(1177)			mapIndex2 = false;
            		}
HXDLIN(1177)		if (mapIndex2) {
HXLINE(1177)			if ((tileY >= 0)) {
HXLINE(1177)				mapIndex1 = (tileY < this->heightInTiles);
            			}
            			else {
HXLINE(1177)				mapIndex1 = false;
            			}
            		}
            		else {
HXLINE(1177)			mapIndex1 = false;
            		}
HXDLIN(1177)		if (mapIndex1) {
HXLINE(1177)			mapIndex = ((tileY * this->widthInTiles) + tileX);
            		}
            		else {
HXLINE(1177)			mapIndex = -1;
            		}
HXDLIN(1177)		int tile;
HXDLIN(1177)		bool tile1;
HXDLIN(1177)		if ((mapIndex >= 0)) {
HXLINE(1177)			tile1 = (mapIndex < this->_data->length);
            		}
            		else {
HXLINE(1177)			tile1 = false;
            		}
HXDLIN(1177)		if (tile1) {
HXLINE(1177)			tile = this->_data->__get(mapIndex);
            		}
            		else {
HXLINE(1177)			tile = -1;
            		}
HXDLIN(1177)		 ::flixel::tile::FlxTile tile2 = ( ( ::flixel::tile::FlxTile)(this->_tileObjects->__get(tile)) );
HXLINE(1178)		 ::flixel::graphics::frames::FlxImageFrame image = null();
HXLINE(1180)		bool _hx_tmp;
HXDLIN(1180)		if (::hx::IsNotNull( tile2 )) {
HXLINE(1180)			_hx_tmp = tile2->visible;
            		}
            		else {
HXLINE(1180)			_hx_tmp = false;
            		}
HXDLIN(1180)		if (_hx_tmp) {
HXLINE(1181)			image = ::flixel::graphics::frames::FlxImageFrame_obj::fromFrame(tile2->frame);
            		}
            		else {
HXLINE(1183)			 ::flixel::graphics::FlxGraphic image1 = this->graphic;
HXDLIN(1183)			Float Width = ( (Float)(this->tileWidth) );
HXDLIN(1183)			Float Height = ( (Float)(this->tileHeight) );
HXDLIN(1183)			 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get().StaticCast<  ::flixel::math::FlxRect >();
HXDLIN(1183)			_this->x = ( (Float)(0) );
HXDLIN(1183)			_this->y = ( (Float)(0) );
HXDLIN(1183)			_this->width = Width;
HXDLIN(1183)			_this->height = Height;
HXDLIN(1183)			 ::flixel::math::FlxRect rect = _this;
HXDLIN(1183)			rect->_inPool = false;
HXDLIN(1183)			image = ::flixel::graphics::frames::FlxImageFrame_obj::fromEmptyFrame(image1,rect);
            		}
HXLINE(1185)		Float worldX = ((( (Float)((tileX * this->tileWidth)) ) * this->scale->x) + this->x);
HXLINE(1186)		Float worldY = ((( (Float)((tileY * this->tileHeight)) ) * this->scale->y) + this->y);
HXLINE(1191)		 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN(1191)		point->_inPool = false;
HXDLIN(1191)		 ::flixel::math::FlxBasePoint this1 = point;
HXDLIN(1191)		 ::flixel::math::FlxBasePoint p = this->scale;
HXDLIN(1191)		{
HXLINE(1191)			Float y = p->y;
HXDLIN(1191)			this1->set_x(p->x);
HXDLIN(1191)			this1->set_y(y);
            		}
HXDLIN(1191)		{
HXLINE(1191)			 ::flixel::math::FlxBasePoint _this1 = p;
HXDLIN(1191)			if (_this1->_weak) {
HXLINE(1191)				_this1->put();
            			}
            		}
HXLINE(1187)		 ::flixel::FlxSprite tileSprite = ( ( ::flixel::FlxSprite)(spriteFactory( ::Dynamic(::hx::Anon_obj::Create(6)
            			->setFixed(0,HX_("blend",51,e8,f4,b4),this->blend)
            			->setFixed(1,HX_("x",78,00,00,00),worldX)
            			->setFixed(2,HX_("y",79,00,00,00),worldY)
            			->setFixed(3,HX_("alpha",5e,a7,96,21),this->alpha)
            			->setFixed(4,HX_("graphic",a8,5a,07,74),image)
            			->setFixed(5,HX_("scale",8a,ce,ce,78),this1)))) );
HXLINE(1196)		if ((newTile >= 0)) {
HXLINE(1197)			int _hx_tmp1;
HXDLIN(1197)			bool _hx_tmp2;
HXDLIN(1197)			bool _hx_tmp3;
HXDLIN(1197)			if ((tileX >= 0)) {
HXLINE(1197)				_hx_tmp3 = (tileX < this->widthInTiles);
            			}
            			else {
HXLINE(1197)				_hx_tmp3 = false;
            			}
HXDLIN(1197)			if (_hx_tmp3) {
HXLINE(1197)				if ((tileY >= 0)) {
HXLINE(1197)					_hx_tmp2 = (tileY < this->heightInTiles);
            				}
            				else {
HXLINE(1197)					_hx_tmp2 = false;
            				}
            			}
            			else {
HXLINE(1197)				_hx_tmp2 = false;
            			}
HXDLIN(1197)			if (_hx_tmp2) {
HXLINE(1197)				_hx_tmp1 = ((tileY * this->widthInTiles) + tileX);
            			}
            			else {
HXLINE(1197)				_hx_tmp1 = -1;
            			}
HXDLIN(1197)			this->setTileHelper(_hx_tmp1,newTile,true);
            		}
HXLINE(1199)		return tileSprite;
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxTypedTilemap_obj,tileToSprite,return )

void FlxTypedTilemap_obj::updateBuffers(){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1206_updateBuffers)
HXLINE(1207)		::flixel::util::FlxDestroyUtil_obj::destroyArray(this->_buffers);
HXLINE(1208)		this->_buffers = ::Array_obj< ::Dynamic>::__new(0);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxTypedTilemap_obj,updateBuffers,(void))

void FlxTypedTilemap_obj::drawTilemap( ::flixel::tile::FlxTilemapBuffer buffer, ::flixel::FlxCamera camera){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1219_drawTilemap)
HXLINE(1220)		bool isColored;
HXDLIN(1220)		if ((this->alpha == 1)) {
HXLINE(1220)			isColored = (this->color != 16777215);
            		}
            		else {
HXLINE(1220)			isColored = true;
            		}
HXLINE(1223)		Float drawX = ( (Float)(0) );
HXLINE(1224)		Float drawY = ( (Float)(0) );
HXLINE(1225)		Float scaledWidth = ( (Float)(0) );
HXLINE(1226)		Float scaledHeight = ( (Float)(0) );
HXLINE(1227)		 ::flixel::graphics::tile::FlxDrawQuadsItem drawItem = null();
HXLINE(1229)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE(1231)			buffer->fill(null());
            		}
            		else {
HXLINE(1235)			{
HXLINE(1235)				 ::flixel::math::FlxBasePoint this1 = this->getScreenPosition(this->_point,camera);
HXDLIN(1235)				 ::flixel::math::FlxBasePoint point = this->offset;
HXDLIN(1235)				{
HXLINE(1235)					Float y = point->y;
HXDLIN(1235)					this1->set_x((this1->x - point->x));
HXDLIN(1235)					this1->set_y((this1->y - y));
            				}
HXDLIN(1235)				{
HXLINE(1235)					 ::flixel::math::FlxBasePoint _this = point;
HXDLIN(1235)					if (_this->_weak) {
HXLINE(1235)						_this->put();
            					}
            				}
HXDLIN(1235)				 ::flixel::math::FlxBasePoint this2 = this1;
HXDLIN(1235)				 ::openfl::geom::Point p = this->_helperPoint;
HXDLIN(1235)				p->x = this2->x;
HXDLIN(1235)				p->y = this2->y;
            			}
HXLINE(1237)			Float _hx_tmp;
HXDLIN(1237)			if (this->isPixelPerfectRender(camera)) {
HXLINE(1237)				_hx_tmp = ( (Float)(::Math_obj::floor(this->_helperPoint->x)) );
            			}
            			else {
HXLINE(1237)				_hx_tmp = this->_helperPoint->x;
            			}
HXDLIN(1237)			this->_helperPoint->x = _hx_tmp;
HXLINE(1238)			Float _hx_tmp1;
HXDLIN(1238)			if (this->isPixelPerfectRender(camera)) {
HXLINE(1238)				_hx_tmp1 = ( (Float)(::Math_obj::floor(this->_helperPoint->y)) );
            			}
            			else {
HXLINE(1238)				_hx_tmp1 = this->_helperPoint->y;
            			}
HXDLIN(1238)			this->_helperPoint->y = _hx_tmp1;
HXLINE(1240)			scaledWidth = this->scaledTileWidth;
HXLINE(1241)			scaledHeight = this->scaledTileHeight;
HXLINE(1243)			bool hasColorOffsets;
HXDLIN(1243)			if (::hx::IsNotNull( this->colorTransform )) {
HXLINE(1243)				hasColorOffsets = ::flixel::util::FlxColorTransformUtil_obj::hasRGBAOffsets(this->colorTransform);
            			}
            			else {
HXLINE(1243)				hasColorOffsets = false;
            			}
HXLINE(1244)			drawItem = camera->startQuadBatch(this->graphic,isColored,hasColorOffsets,this->blend,this->antialiasing,this->shader);
            		}
HXLINE(1248)		this->_point->set_x(((((camera->scroll->x * this->scrollFactor->x) - this->x) - this->offset->x) + camera->viewMarginX));
HXLINE(1249)		this->_point->set_y(((((camera->scroll->y * this->scrollFactor->y) - this->y) - this->offset->y) + camera->viewMarginY));
HXLINE(1251)		int screenXInTiles = ::Math_obj::floor((this->_point->x / this->scaledTileWidth));
HXLINE(1252)		int screenYInTiles = ::Math_obj::floor((this->_point->y / this->scaledTileHeight));
HXLINE(1253)		int screenRows = buffer->rows;
HXLINE(1254)		int screenColumns = buffer->columns;
HXLINE(1257)		 ::Dynamic Max = (this->widthInTiles - screenColumns);
HXDLIN(1257)		Float lowerBound;
HXDLIN(1257)		if ((screenXInTiles < 0)) {
HXLINE(1257)			lowerBound = ( (Float)(0) );
            		}
            		else {
HXLINE(1257)			lowerBound = ( (Float)(screenXInTiles) );
            		}
HXDLIN(1257)		Float screenXInTiles1;
HXDLIN(1257)		bool screenXInTiles2;
HXDLIN(1257)		if (::hx::IsNotNull( Max )) {
HXLINE(1257)			screenXInTiles2 = ::hx::IsGreater( lowerBound,Max );
            		}
            		else {
HXLINE(1257)			screenXInTiles2 = false;
            		}
HXDLIN(1257)		if (screenXInTiles2) {
HXLINE(1257)			screenXInTiles1 = ( (Float)(Max) );
            		}
            		else {
HXLINE(1257)			screenXInTiles1 = lowerBound;
            		}
HXDLIN(1257)		screenXInTiles = ::Std_obj::_hx_int(screenXInTiles1);
HXLINE(1258)		 ::Dynamic Max1 = (this->heightInTiles - screenRows);
HXDLIN(1258)		Float lowerBound1;
HXDLIN(1258)		if ((screenYInTiles < 0)) {
HXLINE(1258)			lowerBound1 = ( (Float)(0) );
            		}
            		else {
HXLINE(1258)			lowerBound1 = ( (Float)(screenYInTiles) );
            		}
HXDLIN(1258)		Float screenYInTiles1;
HXDLIN(1258)		bool screenYInTiles2;
HXDLIN(1258)		if (::hx::IsNotNull( Max1 )) {
HXLINE(1258)			screenYInTiles2 = ::hx::IsGreater( lowerBound1,Max1 );
            		}
            		else {
HXLINE(1258)			screenYInTiles2 = false;
            		}
HXDLIN(1258)		if (screenYInTiles2) {
HXLINE(1258)			screenYInTiles1 = ( (Float)(Max1) );
            		}
            		else {
HXLINE(1258)			screenYInTiles1 = lowerBound1;
            		}
HXDLIN(1258)		screenYInTiles = ::Std_obj::_hx_int(screenYInTiles1);
HXLINE(1260)		int rowIndex = ((screenYInTiles * this->widthInTiles) + screenXInTiles);
HXLINE(1261)		this->_flashPoint->y = ( (Float)(0) );
HXLINE(1262)		int columnIndex;
HXLINE(1263)		 ::flixel::tile::FlxTile tile;
HXLINE(1264)		 ::flixel::graphics::frames::FlxFrame frame;
HXLINE(1267)		 ::openfl::display::BitmapData debugTile;
HXLINE(1270)		{
HXLINE(1270)			int _g = 0;
HXDLIN(1270)			int _g1 = screenRows;
HXDLIN(1270)			while((_g < _g1)){
HXLINE(1270)				_g = (_g + 1);
HXDLIN(1270)				int row = (_g - 1);
HXLINE(1272)				columnIndex = rowIndex;
HXLINE(1273)				this->_flashPoint->x = ( (Float)(0) );
HXLINE(1275)				{
HXLINE(1275)					int _g2 = 0;
HXDLIN(1275)					int _g3 = screenColumns;
HXDLIN(1275)					while((_g2 < _g3)){
HXLINE(1275)						_g2 = (_g2 + 1);
HXDLIN(1275)						int column = (_g2 - 1);
HXLINE(1277)						int tile1;
HXDLIN(1277)						bool tile2;
HXDLIN(1277)						if ((columnIndex >= 0)) {
HXLINE(1277)							tile2 = (columnIndex < this->_data->length);
            						}
            						else {
HXLINE(1277)							tile2 = false;
            						}
HXDLIN(1277)						if (tile2) {
HXLINE(1277)							tile1 = this->_data->__get(columnIndex);
            						}
            						else {
HXLINE(1277)							tile1 = -1;
            						}
HXDLIN(1277)						tile = ( ( ::flixel::tile::FlxTile)(this->_tileObjects->__get(tile1)) );
HXLINE(1279)						bool _hx_tmp2;
HXDLIN(1279)						bool _hx_tmp3;
HXDLIN(1279)						if (::hx::IsNotNull( tile )) {
HXLINE(1279)							_hx_tmp3 = tile->visible;
            						}
            						else {
HXLINE(1279)							_hx_tmp3 = false;
            						}
HXDLIN(1279)						if (_hx_tmp3) {
HXLINE(1279)							_hx_tmp2 = (tile->frame->type != 2);
            						}
            						else {
HXLINE(1279)							_hx_tmp2 = false;
            						}
HXDLIN(1279)						if (_hx_tmp2) {
HXLINE(1281)							frame = tile->frame;
HXLINE(1283)							if (::flixel::FlxG_obj::renderBlit) {
HXLINE(1285)								frame->paint(buffer->pixels,this->_flashPoint,true,null());
HXLINE(1288)								bool _hx_tmp4;
HXDLIN(1288)								if (::flixel::FlxG_obj::debugger->drawDebug) {
HXLINE(1288)									_hx_tmp4 = !(this->ignoreDrawDebug);
            								}
            								else {
HXLINE(1288)									_hx_tmp4 = false;
            								}
HXDLIN(1288)								if (_hx_tmp4) {
HXLINE(1290)									if ((tile->allowCollisions <= 0)) {
HXLINE(1292)										debugTile = this->_debugTileNotSolid;
            									}
            									else {
HXLINE(1294)										if ((tile->allowCollisions != 4369)) {
HXLINE(1296)											debugTile = this->_debugTilePartial;
            										}
            										else {
HXLINE(1300)											debugTile = this->_debugTileSolid;
            										}
            									}
HXLINE(1303)									{
HXLINE(1303)										 ::flixel::math::FlxBasePoint this3 = this->offset;
HXDLIN(1303)										 ::openfl::geom::Point p1 = this->_flashPoint;
HXDLIN(1303)										 ::openfl::geom::Point p2 = p1;
HXDLIN(1303)										p2->x = (p2->x + this3->x);
HXDLIN(1303)										 ::openfl::geom::Point p3 = p1;
HXDLIN(1303)										p3->y = (p3->y + this3->y);
            									}
HXLINE(1304)									buffer->pixels->copyPixels(debugTile,this->_debugRect,this->_flashPoint,null(),null(),true);
HXLINE(1305)									{
HXLINE(1305)										 ::flixel::math::FlxBasePoint this4 = this->offset;
HXDLIN(1305)										 ::openfl::geom::Point p4 = this->_flashPoint;
HXDLIN(1305)										 ::openfl::geom::Point p5 = p4;
HXDLIN(1305)										p5->x = (p5->x - this4->x);
HXDLIN(1305)										 ::openfl::geom::Point p6 = p4;
HXDLIN(1305)										p6->y = (p6->y - this4->y);
            									}
            								}
            							}
            							else {
HXLINE(1311)								drawX = (this->_helperPoint->x + (( (Float)(::hx::Mod(columnIndex,this->widthInTiles)) ) * scaledWidth));
HXLINE(1312)								drawY = (this->_helperPoint->y + (( (Float)(::Math_obj::floor((( (Float)(columnIndex) ) / ( (Float)(this->widthInTiles) )))) ) * scaledHeight));
HXLINE(1314)								this->_matrix->identity();
HXLINE(1316)								if ((frame->angle != 0)) {
HXLINE(1318)									frame->prepareMatrix(this->_matrix,null(),null(),null());
            								}
HXLINE(1321)								Float scaleX = this->scale->x;
HXLINE(1322)								Float scaleY = this->scale->y;
HXLINE(1324)								this->_matrix->scale(scaleX,scaleY);
HXLINE(1325)								this->_matrix->translate(drawX,drawY);
HXLINE(1327)								drawItem->addQuad(frame,this->_matrix,this->colorTransform);
            							}
            						}
HXLINE(1331)						if (::flixel::FlxG_obj::renderBlit) {
HXLINE(1332)							 ::openfl::geom::Point fh = this->_flashPoint;
HXDLIN(1332)							fh->x = (fh->x + this->tileWidth);
            						}
HXLINE(1334)						columnIndex = (columnIndex + 1);
            					}
            				}
HXLINE(1337)				if (::flixel::FlxG_obj::renderBlit) {
HXLINE(1338)					 ::openfl::geom::Point fh1 = this->_flashPoint;
HXDLIN(1338)					fh1->y = (fh1->y + this->tileHeight);
            				}
HXLINE(1339)				rowIndex = (rowIndex + this->widthInTiles);
            			}
            		}
HXLINE(1342)		buffer->x = (( (Float)(screenXInTiles) ) * this->scaledTileWidth);
HXLINE(1343)		buffer->y = (( (Float)(screenYInTiles) ) * this->scaledTileHeight);
HXLINE(1345)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE(1347)			if (isColored) {
HXLINE(1348)				buffer->colorTransform(this->colorTransform);
            			}
HXLINE(1349)			buffer->blend = this->blend;
            		}
HXLINE(1352)		buffer->dirty = false;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTypedTilemap_obj,drawTilemap,(void))

 ::openfl::display::BitmapData FlxTypedTilemap_obj::makeDebugTile(int color){
            	HX_GC_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1361_makeDebugTile)
HXLINE(1362)		if (::flixel::FlxG_obj::renderTile) {
HXLINE(1363)			return null();
            		}
HXLINE(1365)		 ::openfl::display::BitmapData debugTile =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,this->tileWidth,this->tileHeight,true,0);
HXLINE(1366)		this->drawDebugTile(debugTile,color);
HXLINE(1367)		return debugTile;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTypedTilemap_obj,makeDebugTile,return )

void FlxTypedTilemap_obj::drawDebugTile( ::openfl::display::BitmapData debugTile,int color){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1372_drawDebugTile)
HXDLIN(1372)		if ((color != 0)) {
HXLINE(1374)			 ::openfl::display::Graphics gfx = ::flixel::util::FlxSpriteUtil_obj::flashGfx;
HXLINE(1375)			gfx->clear();
HXLINE(1376)			gfx->moveTo(( (Float)(0) ),( (Float)(0) ));
HXLINE(1377)			gfx->lineStyle(1,color,((Float)0.5),null(),null(),null(),null(),null());
HXLINE(1378)			gfx->lineTo(( (Float)((this->tileWidth - 1)) ),( (Float)(0) ));
HXLINE(1379)			gfx->lineTo(( (Float)((this->tileWidth - 1)) ),( (Float)((this->tileHeight - 1)) ));
HXLINE(1380)			gfx->lineTo(( (Float)(0) ),( (Float)((this->tileHeight - 1)) ));
HXLINE(1381)			gfx->lineTo(( (Float)(0) ),( (Float)(0) ));
HXLINE(1383)			debugTile->draw(::flixel::util::FlxSpriteUtil_obj::flashGfxSprite,null(),null(),null(),null(),null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTypedTilemap_obj,drawDebugTile,(void))

void FlxTypedTilemap_obj::onDrawDebugChanged(){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1389_onDrawDebugChanged)
HXDLIN(1389)		this->setDirty(null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxTypedTilemap_obj,onDrawDebugChanged,(void))

void FlxTypedTilemap_obj::updateTile(int index){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1399_updateTile)
HXLINE(1400)		 ::flixel::tile::FlxTile tile = ( ( ::flixel::tile::FlxTile)(this->_tileObjects->__get(index)) );
HXLINE(1401)		bool _hx_tmp;
HXDLIN(1401)		if (::hx::IsNotNull( tile )) {
HXLINE(1401)			_hx_tmp = !(tile->visible);
            		}
            		else {
HXLINE(1401)			_hx_tmp = true;
            		}
HXDLIN(1401)		if (_hx_tmp) {
HXLINE(1402)			return;
            		}
HXLINE(1404)		tile->frame = this->frames->frames->__get((index - this->_startingIndex)).StaticCast<  ::flixel::graphics::frames::FlxFrame >();
            	}


 ::flixel::tile::FlxTilemapBuffer FlxTypedTilemap_obj::createBuffer( ::flixel::FlxCamera camera){
            	HX_GC_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1408_createBuffer)
HXLINE(1409)		 ::flixel::tile::FlxTilemapBuffer buffer =  ::flixel::tile::FlxTilemapBuffer_obj::__alloc( HX_CTX ,this->tileWidth,this->tileHeight,this->widthInTiles,this->heightInTiles,camera,this->scale->x,this->scale->y);
HXLINE(1410)		buffer->pixelPerfectRender = this->pixelPerfectRender;
HXLINE(1411)		buffer->antialiasing = this->antialiasing;
HXLINE(1412)		return buffer;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTypedTilemap_obj,createBuffer,return )

bool FlxTypedTilemap_obj::set_antialiasing(bool value){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1416_set_antialiasing)
HXLINE(1417)		{
HXLINE(1417)			int _g = 0;
HXDLIN(1417)			::Array< ::Dynamic> _g1 = this->_buffers;
HXDLIN(1417)			while((_g < _g1->length)){
HXLINE(1417)				 ::flixel::tile::FlxTilemapBuffer buffer = _g1->__get(_g).StaticCast<  ::flixel::tile::FlxTilemapBuffer >();
HXDLIN(1417)				_g = (_g + 1);
HXLINE(1418)				buffer->antialiasing = value;
            			}
            		}
HXLINE(1419)		return (this->antialiasing = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTypedTilemap_obj,set_antialiasing,return )

 ::flixel::graphics::FlxGraphic FlxTypedTilemap_obj::set_graphic( ::flixel::graphics::FlxGraphic value){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1428_set_graphic)
HXLINE(1429)		if (::hx::IsInstanceNotEq( this->graphic,value )) {
HXLINE(1432)			if (::hx::IsNotNull( value )) {
HXLINE(1433)				value->incrementUseCount();
            			}
HXLINE(1436)			if (::hx::IsNotNull( this->graphic )) {
HXLINE(1437)				this->graphic->decrementUseCount();
            			}
HXLINE(1439)			this->graphic = value;
            		}
HXLINE(1442)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTypedTilemap_obj,set_graphic,return )

bool FlxTypedTilemap_obj::set_pixelPerfectRender(bool value){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1446_set_pixelPerfectRender)
HXLINE(1447)		if (::hx::IsNotNull( this->_buffers )) {
HXLINE(1448)			int _g = 0;
HXDLIN(1448)			::Array< ::Dynamic> _g1 = this->_buffers;
HXDLIN(1448)			while((_g < _g1->length)){
HXLINE(1448)				 ::flixel::tile::FlxTilemapBuffer buffer = _g1->__get(_g).StaticCast<  ::flixel::tile::FlxTilemapBuffer >();
HXDLIN(1448)				_g = (_g + 1);
HXLINE(1449)				buffer->pixelPerfectRender = value;
            			}
            		}
HXLINE(1451)		return ( (bool)((this->pixelPerfectRender = value)) );
            	}


Float FlxTypedTilemap_obj::set_alpha(Float value){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1455_set_alpha)
HXLINE(1456)		Float lowerBound;
HXDLIN(1456)		if ((value < 0)) {
HXLINE(1456)			lowerBound = ( (Float)(0) );
            		}
            		else {
HXLINE(1456)			lowerBound = value;
            		}
HXDLIN(1456)		Float _hx_tmp;
HXDLIN(1456)		if ((lowerBound > 1)) {
HXLINE(1456)			_hx_tmp = ( (Float)(1) );
            		}
            		else {
HXLINE(1456)			_hx_tmp = lowerBound;
            		}
HXDLIN(1456)		this->alpha = _hx_tmp;
HXLINE(1457)		this->updateColorTransform();
HXLINE(1458)		return this->alpha;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTypedTilemap_obj,set_alpha,return )

int FlxTypedTilemap_obj::set_color(int value){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1462_set_color)
HXLINE(1463)		if ((this->color == value)) {
HXLINE(1464)			return value;
            		}
HXLINE(1466)		this->color = value;
HXLINE(1467)		this->updateColorTransform();
HXLINE(1468)		return this->color;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTypedTilemap_obj,set_color,return )

void FlxTypedTilemap_obj::updateColorTransform(){
            	HX_GC_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1472_updateColorTransform)
HXLINE(1473)		if (::hx::IsNull( this->colorTransform )) {
HXLINE(1474)			this->colorTransform =  ::openfl::geom::ColorTransform_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null(),null(),null());
            		}
HXLINE(1476)		bool _hx_tmp;
HXDLIN(1476)		if ((this->alpha == 1)) {
HXLINE(1476)			_hx_tmp = (this->color != 16777215);
            		}
            		else {
HXLINE(1476)			_hx_tmp = true;
            		}
HXDLIN(1476)		if (_hx_tmp) {
HXLINE(1477)			 ::openfl::geom::ColorTransform transform = this->colorTransform;
HXDLIN(1477)			transform->redMultiplier = (( (Float)(((this->color >> 16) & 255)) ) / ( (Float)(255) ));
HXDLIN(1477)			transform->greenMultiplier = (( (Float)(((this->color >> 8) & 255)) ) / ( (Float)(255) ));
HXDLIN(1477)			transform->blueMultiplier = (( (Float)((this->color & 255)) ) / ( (Float)(255) ));
HXDLIN(1477)			transform->alphaMultiplier = this->alpha;
            		}
            		else {
HXLINE(1479)			 ::openfl::geom::ColorTransform transform1 = this->colorTransform;
HXDLIN(1479)			transform1->redMultiplier = ( (Float)(1) );
HXDLIN(1479)			transform1->greenMultiplier = ( (Float)(1) );
HXDLIN(1479)			transform1->blueMultiplier = ( (Float)(1) );
HXDLIN(1479)			transform1->alphaMultiplier = ( (Float)(1) );
            		}
HXLINE(1481)		this->setDirty(null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxTypedTilemap_obj,updateColorTransform,(void))

 ::Dynamic FlxTypedTilemap_obj::set_blend( ::Dynamic value){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1485_set_blend)
HXLINE(1486)		this->setDirty(null());
HXLINE(1487)		return (this->blend = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTypedTilemap_obj,set_blend,return )

void FlxTypedTilemap_obj::setScaleXYCallback( ::flixel::math::FlxBasePoint scale){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1491_setScaleXYCallback)
HXLINE(1492)		this->setScaleXCallback(scale);
HXLINE(1493)		this->setScaleYCallback(scale);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTypedTilemap_obj,setScaleXYCallback,(void))

void FlxTypedTilemap_obj::setScaleXCallback( ::flixel::math::FlxBasePoint scale){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1497_setScaleXCallback)
HXLINE(1498)		this->scaledTileWidth = (( (Float)(this->tileWidth) ) * scale->x);
HXLINE(1499)		this->set_width((( (Float)(this->widthInTiles) ) * this->scaledTileWidth));
HXLINE(1501)		::Array< ::Dynamic> cameras = this->getCameras();
HXLINE(1502)		if (::hx::IsNull( cameras )) {
HXLINE(1503)			return;
            		}
HXLINE(1505)		{
HXLINE(1505)			int _g = 0;
HXDLIN(1505)			int _g1 = cameras->length;
HXDLIN(1505)			while((_g < _g1)){
HXLINE(1505)				_g = (_g + 1);
HXDLIN(1505)				int i = (_g - 1);
HXLINE(1506)				if (::hx::IsNotNull( this->_buffers->__get(i).StaticCast<  ::flixel::tile::FlxTilemapBuffer >() )) {
HXLINE(1507)					this->_buffers->__get(i).StaticCast<  ::flixel::tile::FlxTilemapBuffer >()->updateColumns(this->tileWidth,this->widthInTiles,scale->x,cameras->__get(i).StaticCast<  ::flixel::FlxCamera >());
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTypedTilemap_obj,setScaleXCallback,(void))

void FlxTypedTilemap_obj::setScaleYCallback( ::flixel::math::FlxBasePoint scale){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1511_setScaleYCallback)
HXLINE(1512)		this->scaledTileHeight = (( (Float)(this->tileHeight) ) * scale->y);
HXLINE(1513)		this->set_height((( (Float)(this->heightInTiles) ) * this->scaledTileHeight));
HXLINE(1515)		::Array< ::Dynamic> cameras = this->getCameras();
HXLINE(1516)		if (::hx::IsNull( cameras )) {
HXLINE(1517)			return;
            		}
HXLINE(1519)		{
HXLINE(1519)			int _g = 0;
HXDLIN(1519)			int _g1 = cameras->length;
HXDLIN(1519)			while((_g < _g1)){
HXLINE(1519)				_g = (_g + 1);
HXDLIN(1519)				int i = (_g - 1);
HXLINE(1520)				if (::hx::IsNotNull( this->_buffers->__get(i).StaticCast<  ::flixel::tile::FlxTilemapBuffer >() )) {
HXLINE(1521)					this->_buffers->__get(i).StaticCast<  ::flixel::tile::FlxTilemapBuffer >()->updateRows(this->tileHeight,this->heightInTiles,scale->y,cameras->__get(i).StaticCast<  ::flixel::FlxCamera >());
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTypedTilemap_obj,setScaleYCallback,(void))

 ::flixel::FlxSprite FlxTypedTilemap_obj::defaultTileToSprite( ::Dynamic tileProperties){
            	HX_GC_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1531_defaultTileToSprite)
HXLINE(1532)		 ::flixel::FlxSprite tileSprite =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,tileProperties->__Field(HX_("x",78,00,00,00),::hx::paccDynamic),tileProperties->__Field(HX_("y",79,00,00,00),::hx::paccDynamic),null());
HXLINE(1533)		tileSprite->set_frames(( ( ::flixel::graphics::frames::FlxFramesCollection)(tileProperties->__Field(HX_("graphic",a8,5a,07,74),::hx::paccDynamic)) ));
HXLINE(1534)		{
HXLINE(1534)			 ::flixel::math::FlxBasePoint this1 = tileSprite->scale;
HXDLIN(1534)			 ::flixel::math::FlxBasePoint p = ( ( ::flixel::math::FlxBasePoint)(tileProperties->__Field(HX_("scale",8a,ce,ce,78),::hx::paccDynamic)) );
HXDLIN(1534)			{
HXLINE(1534)				Float y = p->y;
HXDLIN(1534)				this1->set_x(p->x);
HXDLIN(1534)				this1->set_y(y);
            			}
HXDLIN(1534)			{
HXLINE(1534)				 ::flixel::math::FlxBasePoint _this = p;
HXDLIN(1534)				if (_this->_weak) {
HXLINE(1534)					_this->put();
            				}
            			}
            		}
HXLINE(1535)		tileProperties->__SetField(HX_("scale",8a,ce,ce,78),::flixel::util::FlxDestroyUtil_obj::put( ::Dynamic(tileProperties->__Field(HX_("scale",8a,ce,ce,78),::hx::paccDynamic))),::hx::paccDynamic);
HXLINE(1536)		tileSprite->set_alpha(( (Float)(tileProperties->__Field(HX_("alpha",5e,a7,96,21),::hx::paccDynamic)) ));
HXLINE(1537)		tileSprite->set_blend(tileProperties->__Field(HX_("blend",51,e8,f4,b4),::hx::paccDynamic));
HXLINE(1538)		return tileSprite;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTypedTilemap_obj,defaultTileToSprite,return )

int FlxTypedTilemap_obj::set_allowCollisions(int value){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1542_set_allowCollisions)
HXLINE(1543)		{
HXLINE(1543)			int _g = 0;
HXDLIN(1543)			::cpp::VirtualArray _g1 = this->_tileObjects;
HXDLIN(1543)			while((_g < _g1->get_length())){
HXLINE(1543)				 ::Dynamic tile = _g1->__get(_g);
HXDLIN(1543)				_g = (_g + 1);
HXLINE(1544)				if ((( ( ::flixel::tile::FlxTile)(tile) )->index >= this->_collideIndex)) {
HXLINE(1545)					( ( ::flixel::FlxObject)(tile) )->set_allowCollisions(value);
            				}
            			}
            		}
HXLINE(1547)		return this->super::set_allowCollisions(value);
            	}


Float FlxTypedTilemap_obj::get_scaledWidth(){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1552_get_scaledWidth)
HXDLIN(1552)		return (( (Float)(this->widthInTiles) ) * this->scaledTileWidth);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxTypedTilemap_obj,get_scaledWidth,return )

Float FlxTypedTilemap_obj::get_scaledHeight(){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1557_get_scaledHeight)
HXDLIN(1557)		return (( (Float)(this->heightInTiles) ) * this->scaledTileHeight);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxTypedTilemap_obj,get_scaledHeight,return )

 ::flixel::math::FlxRect FlxTypedTilemap_obj::getBounds( ::flixel::math::FlxRect bounds){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1567_getBounds)
HXLINE(1568)		if (::hx::IsNull( bounds )) {
HXLINE(1569)			 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get().StaticCast<  ::flixel::math::FlxRect >();
HXDLIN(1569)			_this->x = ( (Float)(0) );
HXDLIN(1569)			_this->y = ( (Float)(0) );
HXDLIN(1569)			_this->width = ( (Float)(0) );
HXDLIN(1569)			_this->height = ( (Float)(0) );
HXDLIN(1569)			 ::flixel::math::FlxRect rect = _this;
HXDLIN(1569)			rect->_inPool = false;
HXDLIN(1569)			bounds = rect;
            		}
HXLINE(1571)		bounds->x = this->x;
HXDLIN(1571)		bounds->y = this->y;
HXDLIN(1571)		bounds->width = (( (Float)(this->widthInTiles) ) * this->scaledTileWidth);
HXDLIN(1571)		bounds->height = (( (Float)(this->heightInTiles) ) * this->scaledTileHeight);
HXDLIN(1571)		return bounds;
            	}


int FlxTypedTilemap_obj::set_debugBoundingBoxColorSolid(int color){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1576_set_debugBoundingBoxColorSolid)
HXLINE(1577)		this->super::set_debugBoundingBoxColorSolid(color);
HXLINE(1578)		this->updateDebugTileBoundingBoxSolid();
HXLINE(1579)		return color;
            	}


int FlxTypedTilemap_obj::set_debugBoundingBoxColorNotSolid(int color){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1583_set_debugBoundingBoxColorNotSolid)
HXLINE(1584)		this->super::set_debugBoundingBoxColorNotSolid(color);
HXLINE(1585)		this->updateDebugTileBoundingBoxNotSolid();
HXLINE(1586)		return color;
            	}


int FlxTypedTilemap_obj::set_debugBoundingBoxColorPartial(int color){
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_1590_set_debugBoundingBoxColorPartial)
HXLINE(1591)		this->super::set_debugBoundingBoxColorPartial(color);
HXLINE(1592)		this->updateDebugTileBoundingBoxPartial();
HXLINE(1593)		return color;
            	}


int FlxTypedTilemap_obj::defaultFramePadding;


::hx::ObjectPtr< FlxTypedTilemap_obj > FlxTypedTilemap_obj::__new() {
	::hx::ObjectPtr< FlxTypedTilemap_obj > __this = new FlxTypedTilemap_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< FlxTypedTilemap_obj > FlxTypedTilemap_obj::__alloc(::hx::Ctx *_hx_ctx) {
	FlxTypedTilemap_obj *__this = (FlxTypedTilemap_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(FlxTypedTilemap_obj), true, "flixel.tile.FlxTypedTilemap"));
	*(void **)__this = FlxTypedTilemap_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

FlxTypedTilemap_obj::FlxTypedTilemap_obj()
{
}

void FlxTypedTilemap_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(FlxTypedTilemap);
	HX_MARK_MEMBER_NAME(framePadding,"framePadding");
	HX_MARK_MEMBER_NAME(scale,"scale");
	HX_MARK_MEMBER_NAME(antialiasing,"antialiasing");
	HX_MARK_MEMBER_NAME(offset,"offset");
	HX_MARK_MEMBER_NAME(frames,"frames");
	HX_MARK_MEMBER_NAME(graphic,"graphic");
	HX_MARK_MEMBER_NAME(color,"color");
	HX_MARK_MEMBER_NAME(alpha,"alpha");
	HX_MARK_MEMBER_NAME(colorTransform,"colorTransform");
	HX_MARK_MEMBER_NAME(blend,"blend");
	HX_MARK_MEMBER_NAME(tileWidth,"tileWidth");
	HX_MARK_MEMBER_NAME(tileHeight,"tileHeight");
	HX_MARK_MEMBER_NAME(scaledTileWidth,"scaledTileWidth");
	HX_MARK_MEMBER_NAME(scaledTileHeight,"scaledTileHeight");
	HX_MARK_MEMBER_NAME(shader,"shader");
	HX_MARK_MEMBER_NAME(_flashPoint,"_flashPoint");
	HX_MARK_MEMBER_NAME(_flashRect,"_flashRect");
	HX_MARK_MEMBER_NAME(_buffers,"_buffers");
	HX_MARK_MEMBER_NAME(_debugTileNotSolid,"_debugTileNotSolid");
	HX_MARK_MEMBER_NAME(_debugTilePartial,"_debugTilePartial");
	HX_MARK_MEMBER_NAME(_debugTileSolid,"_debugTileSolid");
	HX_MARK_MEMBER_NAME(_debugRect,"_debugRect");
	HX_MARK_MEMBER_NAME(_helperPoint,"_helperPoint");
	HX_MARK_MEMBER_NAME(_matrix,"_matrix");
	HX_MARK_MEMBER_NAME(_checkBufferChanges,"_checkBufferChanges");
	 ::flixel::tile::FlxBaseTilemap_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void FlxTypedTilemap_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(framePadding,"framePadding");
	HX_VISIT_MEMBER_NAME(scale,"scale");
	HX_VISIT_MEMBER_NAME(antialiasing,"antialiasing");
	HX_VISIT_MEMBER_NAME(offset,"offset");
	HX_VISIT_MEMBER_NAME(frames,"frames");
	HX_VISIT_MEMBER_NAME(graphic,"graphic");
	HX_VISIT_MEMBER_NAME(color,"color");
	HX_VISIT_MEMBER_NAME(alpha,"alpha");
	HX_VISIT_MEMBER_NAME(colorTransform,"colorTransform");
	HX_VISIT_MEMBER_NAME(blend,"blend");
	HX_VISIT_MEMBER_NAME(tileWidth,"tileWidth");
	HX_VISIT_MEMBER_NAME(tileHeight,"tileHeight");
	HX_VISIT_MEMBER_NAME(scaledTileWidth,"scaledTileWidth");
	HX_VISIT_MEMBER_NAME(scaledTileHeight,"scaledTileHeight");
	HX_VISIT_MEMBER_NAME(shader,"shader");
	HX_VISIT_MEMBER_NAME(_flashPoint,"_flashPoint");
	HX_VISIT_MEMBER_NAME(_flashRect,"_flashRect");
	HX_VISIT_MEMBER_NAME(_buffers,"_buffers");
	HX_VISIT_MEMBER_NAME(_debugTileNotSolid,"_debugTileNotSolid");
	HX_VISIT_MEMBER_NAME(_debugTilePartial,"_debugTilePartial");
	HX_VISIT_MEMBER_NAME(_debugTileSolid,"_debugTileSolid");
	HX_VISIT_MEMBER_NAME(_debugRect,"_debugRect");
	HX_VISIT_MEMBER_NAME(_helperPoint,"_helperPoint");
	HX_VISIT_MEMBER_NAME(_matrix,"_matrix");
	HX_VISIT_MEMBER_NAME(_checkBufferChanges,"_checkBufferChanges");
	 ::flixel::tile::FlxBaseTilemap_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val FlxTypedTilemap_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"ray") ) { return ::hx::Val( ray_dyn() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"draw") ) { return ::hx::Val( draw_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"scale") ) { return ::hx::Val( scale ); }
		if (HX_FIELD_EQ(inName,"color") ) { return ::hx::Val( color ); }
		if (HX_FIELD_EQ(inName,"alpha") ) { return ::hx::Val( alpha ); }
		if (HX_FIELD_EQ(inName,"blend") ) { return ::hx::Val( blend ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"offset") ) { return ::hx::Val( offset ); }
		if (HX_FIELD_EQ(inName,"frames") ) { return ::hx::Val( frames ); }
		if (HX_FIELD_EQ(inName,"shader") ) { return ::hx::Val( shader ); }
		if (HX_FIELD_EQ(inName,"follow") ) { return ::hx::Val( follow_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"graphic") ) { return ::hx::Val( graphic ); }
		if (HX_FIELD_EQ(inName,"_matrix") ) { return ::hx::Val( _matrix ); }
		if (HX_FIELD_EQ(inName,"destroy") ) { return ::hx::Val( destroy_dyn() ); }
		if (HX_FIELD_EQ(inName,"rayStep") ) { return ::hx::Val( rayStep_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"_buffers") ) { return ::hx::Val( _buffers ); }
		if (HX_FIELD_EQ(inName,"setDirty") ) { return ::hx::Val( setDirty_dyn() ); }
		if (HX_FIELD_EQ(inName,"getRowAt") ) { return ::hx::Val( getRowAt_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"tileWidth") ) { return ::hx::Val( tileWidth ); }
		if (HX_FIELD_EQ(inName,"updateMap") ) { return ::hx::Val( updateMap_dyn() ); }
		if (HX_FIELD_EQ(inName,"getRowPos") ) { return ::hx::Val( getRowPos_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_alpha") ) { return ::hx::Val( set_alpha_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_color") ) { return ::hx::Val( set_color_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_blend") ) { return ::hx::Val( set_blend_dyn() ); }
		if (HX_FIELD_EQ(inName,"getBounds") ) { return ::hx::Val( getBounds_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"tileHeight") ) { return ::hx::Val( tileHeight ); }
		if (HX_FIELD_EQ(inName,"_flashRect") ) { return ::hx::Val( _flashRect ); }
		if (HX_FIELD_EQ(inName,"_debugRect") ) { return ::hx::Val( _debugRect ); }
		if (HX_FIELD_EQ(inName,"createTile") ) { return ::hx::Val( createTile_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_frames") ) { return ::hx::Val( set_frames_dyn() ); }
		if (HX_FIELD_EQ(inName,"isOnScreen") ) { return ::hx::Val( isOnScreen_dyn() ); }
		if (HX_FIELD_EQ(inName,"updateTile") ) { return ::hx::Val( updateTile_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"scaledWidth") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_scaledWidth() ); }
		if (HX_FIELD_EQ(inName,"_flashPoint") ) { return ::hx::Val( _flashPoint ); }
		if (HX_FIELD_EQ(inName,"getColumnAt") ) { return ::hx::Val( getColumnAt_dyn() ); }
		if (HX_FIELD_EQ(inName,"checkColumn") ) { return ::hx::Val( checkColumn_dyn() ); }
		if (HX_FIELD_EQ(inName,"drawTilemap") ) { return ::hx::Val( drawTilemap_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_graphic") ) { return ::hx::Val( set_graphic_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"framePadding") ) { return ::hx::Val( framePadding ); }
		if (HX_FIELD_EQ(inName,"antialiasing") ) { return ::hx::Val( antialiasing ); }
		if (HX_FIELD_EQ(inName,"scaledHeight") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( get_scaledHeight() ); }
		if (HX_FIELD_EQ(inName,"_helperPoint") ) { return ::hx::Val( _helperPoint ); }
		if (HX_FIELD_EQ(inName,"getColumnPos") ) { return ::hx::Val( getColumnPos_dyn() ); }
		if (HX_FIELD_EQ(inName,"tileToSprite") ) { return ::hx::Val( tileToSprite_dyn() ); }
		if (HX_FIELD_EQ(inName,"createBuffer") ) { return ::hx::Val( createBuffer_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"onGameResized") ) { return ::hx::Val( onGameResized_dyn() ); }
		if (HX_FIELD_EQ(inName,"loadMapHelper") ) { return ::hx::Val( loadMapHelper_dyn() ); }
		if (HX_FIELD_EQ(inName,"cacheGraphics") ) { return ::hx::Val( cacheGraphics_dyn() ); }
		if (HX_FIELD_EQ(inName,"padTileFrames") ) { return ::hx::Val( padTileFrames_dyn() ); }
		if (HX_FIELD_EQ(inName,"getTileCoords") ) { return ::hx::Val( getTileCoords_dyn() ); }
		if (HX_FIELD_EQ(inName,"updateBuffers") ) { return ::hx::Val( updateBuffers_dyn() ); }
		if (HX_FIELD_EQ(inName,"makeDebugTile") ) { return ::hx::Val( makeDebugTile_dyn() ); }
		if (HX_FIELD_EQ(inName,"drawDebugTile") ) { return ::hx::Val( drawDebugTile_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"colorTransform") ) { return ::hx::Val( colorTransform ); }
		if (HX_FIELD_EQ(inName,"refreshBuffers") ) { return ::hx::Val( refreshBuffers_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"scaledTileWidth") ) { return ::hx::Val( scaledTileWidth ); }
		if (HX_FIELD_EQ(inName,"_debugTileSolid") ) { return ::hx::Val( _debugTileSolid ); }
		if (HX_FIELD_EQ(inName,"initTileObjects") ) { return ::hx::Val( initTileObjects_dyn() ); }
		if (HX_FIELD_EQ(inName,"onCameraChanged") ) { return ::hx::Val( onCameraChanged_dyn() ); }
		if (HX_FIELD_EQ(inName,"updateDebugTile") ) { return ::hx::Val( updateDebugTile_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_scaledWidth") ) { return ::hx::Val( get_scaledWidth_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"scaledTileHeight") ) { return ::hx::Val( scaledTileHeight ); }
		if (HX_FIELD_EQ(inName,"set_antialiasing") ) { return ::hx::Val( set_antialiasing_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_scaledHeight") ) { return ::hx::Val( get_scaledHeight_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"_debugTilePartial") ) { return ::hx::Val( _debugTilePartial ); }
		if (HX_FIELD_EQ(inName,"computeDimensions") ) { return ::hx::Val( computeDimensions_dyn() ); }
		if (HX_FIELD_EQ(inName,"drawDebugOnCamera") ) { return ::hx::Val( drawDebugOnCamera_dyn() ); }
		if (HX_FIELD_EQ(inName,"isOverlappingTile") ) { return ::hx::Val( isOverlappingTile_dyn() ); }
		if (HX_FIELD_EQ(inName,"setScaleXCallback") ) { return ::hx::Val( setScaleXCallback_dyn() ); }
		if (HX_FIELD_EQ(inName,"setScaleYCallback") ) { return ::hx::Val( setScaleYCallback_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"_debugTileNotSolid") ) { return ::hx::Val( _debugTileNotSolid ); }
		if (HX_FIELD_EQ(inName,"onDrawDebugChanged") ) { return ::hx::Val( onDrawDebugChanged_dyn() ); }
		if (HX_FIELD_EQ(inName,"setScaleXYCallback") ) { return ::hx::Val( setScaleXYCallback_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"_checkBufferChanges") ) { return ::hx::Val( _checkBufferChanges ); }
		if (HX_FIELD_EQ(inName,"objectOverlapsTiles") ) { return ::hx::Val( objectOverlapsTiles_dyn() ); }
		if (HX_FIELD_EQ(inName,"defaultTileToSprite") ) { return ::hx::Val( defaultTileToSprite_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_allowCollisions") ) { return ::hx::Val( set_allowCollisions_dyn() ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"updateColorTransform") ) { return ::hx::Val( updateColorTransform_dyn() ); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"forEachOverlappingTile") ) { return ::hx::Val( forEachOverlappingTile_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_pixelPerfectRender") ) { return ::hx::Val( set_pixelPerfectRender_dyn() ); }
		break;
	case 28:
		if (HX_FIELD_EQ(inName,"forEachOverlappingTileHelper") ) { return ::hx::Val( forEachOverlappingTileHelper_dyn() ); }
		break;
	case 30:
		if (HX_FIELD_EQ(inName,"set_debugBoundingBoxColorSolid") ) { return ::hx::Val( set_debugBoundingBoxColorSolid_dyn() ); }
		break;
	case 31:
		if (HX_FIELD_EQ(inName,"updateDebugTileBoundingBoxSolid") ) { return ::hx::Val( updateDebugTileBoundingBoxSolid_dyn() ); }
		break;
	case 32:
		if (HX_FIELD_EQ(inName,"set_debugBoundingBoxColorPartial") ) { return ::hx::Val( set_debugBoundingBoxColorPartial_dyn() ); }
		break;
	case 33:
		if (HX_FIELD_EQ(inName,"updateDebugTileBoundingBoxPartial") ) { return ::hx::Val( updateDebugTileBoundingBoxPartial_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_debugBoundingBoxColorNotSolid") ) { return ::hx::Val( set_debugBoundingBoxColorNotSolid_dyn() ); }
		break;
	case 34:
		if (HX_FIELD_EQ(inName,"updateDebugTileBoundingBoxNotSolid") ) { return ::hx::Val( updateDebugTileBoundingBoxNotSolid_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool FlxTypedTilemap_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 19:
		if (HX_FIELD_EQ(inName,"defaultFramePadding") ) { outValue = ( defaultFramePadding ); return true; }
	}
	return false;
}

::hx::Val FlxTypedTilemap_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"scale") ) { scale=inValue.Cast<  ::flixel::math::FlxBasePoint >(); return inValue; }
		if (HX_FIELD_EQ(inName,"color") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_color(inValue.Cast< int >()) );color=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"alpha") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_alpha(inValue.Cast< Float >()) );alpha=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"blend") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_blend(inValue.Cast<  ::Dynamic >()) );blend=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"offset") ) { offset=inValue.Cast<  ::flixel::math::FlxBasePoint >(); return inValue; }
		if (HX_FIELD_EQ(inName,"frames") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_frames(inValue.Cast<  ::flixel::graphics::frames::FlxFramesCollection >()) );frames=inValue.Cast<  ::flixel::graphics::frames::FlxFramesCollection >(); return inValue; }
		if (HX_FIELD_EQ(inName,"shader") ) { shader=inValue.Cast<  ::flixel::graphics::tile::FlxGraphicsShader >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"graphic") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_graphic(inValue.Cast<  ::flixel::graphics::FlxGraphic >()) );graphic=inValue.Cast<  ::flixel::graphics::FlxGraphic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_matrix") ) { _matrix=inValue.Cast<  ::flixel::math::FlxMatrix >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"_buffers") ) { _buffers=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"tileWidth") ) { tileWidth=inValue.Cast< int >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"tileHeight") ) { tileHeight=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_flashRect") ) { _flashRect=inValue.Cast<  ::openfl::geom::Rectangle >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_debugRect") ) { _debugRect=inValue.Cast<  ::openfl::geom::Rectangle >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_flashPoint") ) { _flashPoint=inValue.Cast<  ::openfl::geom::Point >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"framePadding") ) { framePadding=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"antialiasing") ) { if (inCallProp == ::hx::paccAlways) return ::hx::Val( set_antialiasing(inValue.Cast< bool >()) );antialiasing=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_helperPoint") ) { _helperPoint=inValue.Cast<  ::openfl::geom::Point >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"colorTransform") ) { colorTransform=inValue.Cast<  ::openfl::geom::ColorTransform >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"scaledTileWidth") ) { scaledTileWidth=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_debugTileSolid") ) { _debugTileSolid=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"scaledTileHeight") ) { scaledTileHeight=inValue.Cast< Float >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"_debugTilePartial") ) { _debugTilePartial=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"_debugTileNotSolid") ) { _debugTileNotSolid=inValue.Cast<  ::openfl::display::BitmapData >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"_checkBufferChanges") ) { _checkBufferChanges=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool FlxTypedTilemap_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 19:
		if (HX_FIELD_EQ(inName,"defaultFramePadding") ) { defaultFramePadding=ioValue.Cast< int >(); return true; }
	}
	return false;
}

void FlxTypedTilemap_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("framePadding",24,19,08,71));
	outFields->push(HX_("scale",8a,ce,ce,78));
	outFields->push(HX_("antialiasing",f4,16,b3,48));
	outFields->push(HX_("offset",93,97,3f,60));
	outFields->push(HX_("frames",a6,af,85,ac));
	outFields->push(HX_("graphic",a8,5a,07,74));
	outFields->push(HX_("color",63,71,5c,4a));
	outFields->push(HX_("alpha",5e,a7,96,21));
	outFields->push(HX_("colorTransform",89,d7,3f,ad));
	outFields->push(HX_("blend",51,e8,f4,b4));
	outFields->push(HX_("tileWidth",f8,13,be,55));
	outFields->push(HX_("tileHeight",b5,dd,e2,66));
	outFields->push(HX_("scaledTileWidth",fe,e5,29,4d));
	outFields->push(HX_("scaledTileHeight",ef,d0,ce,ed));
	outFields->push(HX_("scaledWidth",0c,8d,af,10));
	outFields->push(HX_("scaledHeight",21,56,3b,3f));
	outFields->push(HX_("shader",25,bf,20,1d));
	outFields->push(HX_("_flashPoint",9f,1d,2a,b7));
	outFields->push(HX_("_flashRect",b5,c2,f3,5d));
	outFields->push(HX_("_buffers",f4,fc,48,eb));
	outFields->push(HX_("_debugTileNotSolid",1a,df,89,53));
	outFields->push(HX_("_debugTilePartial",bf,14,2d,78));
	outFields->push(HX_("_debugTileSolid",e9,85,df,f6));
	outFields->push(HX_("_debugRect",d8,6c,95,8a));
	outFields->push(HX_("_helperPoint",03,e6,14,f8));
	outFields->push(HX_("_matrix",e0,47,3f,2a));
	outFields->push(HX_("_checkBufferChanges",1a,1a,89,0b));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo FlxTypedTilemap_obj_sMemberStorageInfo[] = {
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(FlxTypedTilemap_obj,framePadding),HX_("framePadding",24,19,08,71)},
	{::hx::fsObject /*  ::flixel::math::FlxBasePoint */ ,(int)offsetof(FlxTypedTilemap_obj,scale),HX_("scale",8a,ce,ce,78)},
	{::hx::fsBool,(int)offsetof(FlxTypedTilemap_obj,antialiasing),HX_("antialiasing",f4,16,b3,48)},
	{::hx::fsObject /*  ::flixel::math::FlxBasePoint */ ,(int)offsetof(FlxTypedTilemap_obj,offset),HX_("offset",93,97,3f,60)},
	{::hx::fsObject /*  ::flixel::graphics::frames::FlxFramesCollection */ ,(int)offsetof(FlxTypedTilemap_obj,frames),HX_("frames",a6,af,85,ac)},
	{::hx::fsObject /*  ::flixel::graphics::FlxGraphic */ ,(int)offsetof(FlxTypedTilemap_obj,graphic),HX_("graphic",a8,5a,07,74)},
	{::hx::fsInt,(int)offsetof(FlxTypedTilemap_obj,color),HX_("color",63,71,5c,4a)},
	{::hx::fsFloat,(int)offsetof(FlxTypedTilemap_obj,alpha),HX_("alpha",5e,a7,96,21)},
	{::hx::fsObject /*  ::openfl::geom::ColorTransform */ ,(int)offsetof(FlxTypedTilemap_obj,colorTransform),HX_("colorTransform",89,d7,3f,ad)},
	{::hx::fsObject /*  ::Dynamic */ ,(int)offsetof(FlxTypedTilemap_obj,blend),HX_("blend",51,e8,f4,b4)},
	{::hx::fsInt,(int)offsetof(FlxTypedTilemap_obj,tileWidth),HX_("tileWidth",f8,13,be,55)},
	{::hx::fsInt,(int)offsetof(FlxTypedTilemap_obj,tileHeight),HX_("tileHeight",b5,dd,e2,66)},
	{::hx::fsFloat,(int)offsetof(FlxTypedTilemap_obj,scaledTileWidth),HX_("scaledTileWidth",fe,e5,29,4d)},
	{::hx::fsFloat,(int)offsetof(FlxTypedTilemap_obj,scaledTileHeight),HX_("scaledTileHeight",ef,d0,ce,ed)},
	{::hx::fsObject /*  ::flixel::graphics::tile::FlxGraphicsShader */ ,(int)offsetof(FlxTypedTilemap_obj,shader),HX_("shader",25,bf,20,1d)},
	{::hx::fsObject /*  ::openfl::geom::Point */ ,(int)offsetof(FlxTypedTilemap_obj,_flashPoint),HX_("_flashPoint",9f,1d,2a,b7)},
	{::hx::fsObject /*  ::openfl::geom::Rectangle */ ,(int)offsetof(FlxTypedTilemap_obj,_flashRect),HX_("_flashRect",b5,c2,f3,5d)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(FlxTypedTilemap_obj,_buffers),HX_("_buffers",f4,fc,48,eb)},
	{::hx::fsObject /*  ::openfl::display::BitmapData */ ,(int)offsetof(FlxTypedTilemap_obj,_debugTileNotSolid),HX_("_debugTileNotSolid",1a,df,89,53)},
	{::hx::fsObject /*  ::openfl::display::BitmapData */ ,(int)offsetof(FlxTypedTilemap_obj,_debugTilePartial),HX_("_debugTilePartial",bf,14,2d,78)},
	{::hx::fsObject /*  ::openfl::display::BitmapData */ ,(int)offsetof(FlxTypedTilemap_obj,_debugTileSolid),HX_("_debugTileSolid",e9,85,df,f6)},
	{::hx::fsObject /*  ::openfl::geom::Rectangle */ ,(int)offsetof(FlxTypedTilemap_obj,_debugRect),HX_("_debugRect",d8,6c,95,8a)},
	{::hx::fsObject /*  ::openfl::geom::Point */ ,(int)offsetof(FlxTypedTilemap_obj,_helperPoint),HX_("_helperPoint",03,e6,14,f8)},
	{::hx::fsObject /*  ::flixel::math::FlxMatrix */ ,(int)offsetof(FlxTypedTilemap_obj,_matrix),HX_("_matrix",e0,47,3f,2a)},
	{::hx::fsBool,(int)offsetof(FlxTypedTilemap_obj,_checkBufferChanges),HX_("_checkBufferChanges",1a,1a,89,0b)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo FlxTypedTilemap_obj_sStaticStorageInfo[] = {
	{::hx::fsInt,(void *) &FlxTypedTilemap_obj::defaultFramePadding,HX_("defaultFramePadding",85,db,60,ed)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String FlxTypedTilemap_obj_sMemberFields[] = {
	HX_("framePadding",24,19,08,71),
	HX_("scale",8a,ce,ce,78),
	HX_("antialiasing",f4,16,b3,48),
	HX_("offset",93,97,3f,60),
	HX_("frames",a6,af,85,ac),
	HX_("graphic",a8,5a,07,74),
	HX_("color",63,71,5c,4a),
	HX_("alpha",5e,a7,96,21),
	HX_("colorTransform",89,d7,3f,ad),
	HX_("blend",51,e8,f4,b4),
	HX_("tileWidth",f8,13,be,55),
	HX_("tileHeight",b5,dd,e2,66),
	HX_("scaledTileWidth",fe,e5,29,4d),
	HX_("scaledTileHeight",ef,d0,ce,ed),
	HX_("shader",25,bf,20,1d),
	HX_("_flashPoint",9f,1d,2a,b7),
	HX_("_flashRect",b5,c2,f3,5d),
	HX_("_buffers",f4,fc,48,eb),
	HX_("_debugTileNotSolid",1a,df,89,53),
	HX_("_debugTilePartial",bf,14,2d,78),
	HX_("_debugTileSolid",e9,85,df,f6),
	HX_("_debugRect",d8,6c,95,8a),
	HX_("_helperPoint",03,e6,14,f8),
	HX_("_matrix",e0,47,3f,2a),
	HX_("_checkBufferChanges",1a,1a,89,0b),
	HX_("destroy",fa,2c,86,24),
	HX_("initTileObjects",16,be,45,2e),
	HX_("createTile",4a,8c,8a,5f),
	HX_("set_frames",e3,bd,8a,a0),
	HX_("onGameResized",3f,ef,13,ab),
	HX_("onCameraChanged",30,48,4e,5c),
	HX_("loadMapHelper",24,aa,93,69),
	HX_("cacheGraphics",2d,61,95,fc),
	HX_("padTileFrames",a7,e0,6e,cc),
	HX_("updateDebugTileBoundingBoxSolid",9c,41,64,d8),
	HX_("updateDebugTileBoundingBoxNotSolid",47,35,bd,4d),
	HX_("updateDebugTileBoundingBoxPartial",32,63,1e,51),
	HX_("updateDebugTile",d8,3f,d3,7f),
	HX_("computeDimensions",a4,a4,eb,f3),
	HX_("updateMap",13,e8,df,82),
	HX_("drawDebugOnCamera",f3,47,7b,cb),
	HX_("isOnScreen",f5,43,b9,a1),
	HX_("draw",04,2c,70,42),
	HX_("refreshBuffers",d8,b2,a5,26),
	HX_("setDirty",10,b9,04,e8),
	HX_("isOverlappingTile",7d,50,c6,cb),
	HX_("forEachOverlappingTile",bd,fa,b5,d8),
	HX_("forEachOverlappingTileHelper",0b,18,a9,b0),
	HX_("objectOverlapsTiles",9a,54,0e,a5),
	HX_("getColumnAt",1f,2c,11,21),
	HX_("getRowAt",37,65,3e,4d),
	HX_("getColumnPos",e8,cc,00,ce),
	HX_("getRowPos",d0,88,65,49),
	HX_("getTileCoords",22,d6,8d,89),
	HX_("follow",71,91,96,f9),
	HX_("ray",ea,d5,56,00),
	HX_("checkColumn",be,21,9d,a8),
	HX_("rayStep",56,26,de,2f),
	HX_("tileToSprite",2e,e9,26,c3),
	HX_("updateBuffers",6a,08,ff,7c),
	HX_("drawTilemap",8a,34,d7,8e),
	HX_("makeDebugTile",53,67,f1,28),
	HX_("drawDebugTile",7d,82,6f,8f),
	HX_("onDrawDebugChanged",44,e0,f1,9f),
	HX_("updateTile",d7,b5,b1,05),
	HX_("createBuffer",1c,fd,e9,f2),
	HX_("set_antialiasing",f1,f0,93,a3),
	HX_("set_graphic",cb,c1,6e,04),
	HX_("set_pixelPerfectRender",9a,4f,8f,bc),
	HX_("set_alpha",c1,ef,90,48),
	HX_("set_color",c6,b9,56,71),
	HX_("updateColorTransform",72,0f,d2,2f),
	HX_("set_blend",b4,30,ef,db),
	HX_("setScaleXYCallback",6e,fd,35,90),
	HX_("setScaleXCallback",b5,05,a2,03),
	HX_("setScaleYCallback",b6,6e,93,d6),
	HX_("defaultTileToSprite",8f,ab,7f,3f),
	HX_("set_allowCollisions",cd,8b,81,21),
	HX_("get_scaledWidth",a3,44,91,d1),
	HX_("get_scaledHeight",aa,42,da,43),
	HX_("getBounds",ab,0f,74,e2),
	HX_("set_debugBoundingBoxColorSolid",19,c9,0b,4b),
	HX_("set_debugBoundingBoxColorNotSolid",ea,b9,e3,4b),
	HX_("set_debugBoundingBoxColorPartial",ef,83,54,62),
	::String(null()) };

static void FlxTypedTilemap_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxTypedTilemap_obj::defaultFramePadding,"defaultFramePadding");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxTypedTilemap_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxTypedTilemap_obj::defaultFramePadding,"defaultFramePadding");
};

#endif

::hx::Class FlxTypedTilemap_obj::__mClass;

static ::String FlxTypedTilemap_obj_sStaticFields[] = {
	HX_("defaultFramePadding",85,db,60,ed),
	::String(null())
};

void FlxTypedTilemap_obj::__register()
{
	FlxTypedTilemap_obj _hx_dummy;
	FlxTypedTilemap_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("flixel.tile.FlxTypedTilemap",68,72,25,54);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &FlxTypedTilemap_obj::__GetStatic;
	__mClass->mSetStaticField = &FlxTypedTilemap_obj::__SetStatic;
	__mClass->mMarkFunc = FlxTypedTilemap_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(FlxTypedTilemap_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(FlxTypedTilemap_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< FlxTypedTilemap_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxTypedTilemap_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxTypedTilemap_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxTypedTilemap_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void FlxTypedTilemap_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_0e3a69bb718c23c6_154_boot)
HXDLIN( 154)		defaultFramePadding = 2;
            	}
}

} // end namespace flixel
} // end namespace tile
