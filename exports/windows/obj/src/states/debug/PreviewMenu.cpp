// Generated by Haxe 4.3.7
#include <hxcpp.h>

#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxGame
#include <flixel/FlxGame.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedContainer
#include <flixel/group/FlxTypedContainer.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxBaseKeyList
#include <flixel/input/FlxBaseKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_FlxKeyManager
#include <flixel/input/FlxKeyManager.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyList
#include <flixel/input/keyboard/FlxKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyboard
#include <flixel/input/keyboard/FlxKeyboard.h>
#endif
#ifndef INCLUDED_flixel_system_debug_log_LogStyle
#include <flixel/system/debug/log/LogStyle.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_LogFrontEnd
#include <flixel/system/frontEnds/LogFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextBorderStyle
#include <flixel/text/FlxTextBorderStyle.h>
#endif
#ifndef INCLUDED_flixel_text__FlxText_FlxTextAlign_Impl_
#include <flixel/text/_FlxText/FlxTextAlign_Impl_.h>
#endif
#ifndef INCLUDED_flixel_ui_FlxButton
#include <flixel/ui/FlxButton.h>
#endif
#ifndef INCLUDED_flixel_ui_FlxTypedButton_flixel_text_FlxText
#include <flixel/ui/FlxTypedButton_flixel_text_FlxText.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_typeLimit__NextState_NextState_Impl_
#include <flixel/util/typeLimit/_NextState/NextState_Impl_.h>
#endif
#ifndef INCLUDED_objetos_ImagenMenu
#include <objetos/ImagenMenu.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_text_TextFormat
#include <openfl/text/TextFormat.h>
#endif
#ifndef INCLUDED_states_debug_MenuEditorState
#include <states/debug/MenuEditorState.h>
#endif
#ifndef INCLUDED_states_debug_PreviewMenu
#include <states/debug/PreviewMenu.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_d6e0db7350a23b34_12_new,"states.debug.PreviewMenu","new",0x857d11d2,"states.debug.PreviewMenu.new","states/debug/PreviewMenu.hx",12,0xb04a9420)
HX_LOCAL_STACK_FRAME(_hx_pos_d6e0db7350a23b34_22_create,"states.debug.PreviewMenu","create",0x18bf18ca,"states.debug.PreviewMenu.create","states/debug/PreviewMenu.hx",22,0xb04a9420)
HX_LOCAL_STACK_FRAME(_hx_pos_d6e0db7350a23b34_13_create,"states.debug.PreviewMenu","create",0x18bf18ca,"states.debug.PreviewMenu.create","states/debug/PreviewMenu.hx",13,0xb04a9420)
HX_LOCAL_STACK_FRAME(_hx_pos_d6e0db7350a23b34_50_update,"states.debug.PreviewMenu","update",0x23b537d7,"states.debug.PreviewMenu.update","states/debug/PreviewMenu.hx",50,0xb04a9420)
HX_LOCAL_STACK_FRAME(_hx_pos_d6e0db7350a23b34_52_update,"states.debug.PreviewMenu","update",0x23b537d7,"states.debug.PreviewMenu.update","states/debug/PreviewMenu.hx",52,0xb04a9420)
namespace states{
namespace debug{

void PreviewMenu_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_d6e0db7350a23b34_12_new)
HXDLIN(  12)		super::__construct();
            	}

Dynamic PreviewMenu_obj::__CreateEmpty() { return new PreviewMenu_obj; }

void *PreviewMenu_obj::_hx_vtable = 0;

Dynamic PreviewMenu_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< PreviewMenu_obj > _hx_result = new PreviewMenu_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool PreviewMenu_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x62817b24) {
		if (inClassId<=(int)0x563293a6) {
			if (inClassId<=(int)0x47f9a2da) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x47f9a2da;
			} else {
				return inClassId==(int)0x563293a6;
			}
		} else {
			return inClassId==(int)0x62817b24;
		}
	} else {
		return inClassId==(int)0x7c795c9f || inClassId==(int)0x7ccf8994;
	}
}

void PreviewMenu_obj::create(){
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_2) HXARGC(0)
            		void _hx_run(){
            			HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(0)
            			 ::states::debug::MenuEditorState _hx_run(){
            				HX_GC_STACKFRAME(&_hx_pos_d6e0db7350a23b34_22_create)
HXLINE(  22)				return  ::states::debug::MenuEditorState_obj::__alloc( HX_CTX );
            			}
            			HX_END_LOCAL_FUNC0(return)

            			HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_1, ::Dynamic,nextState, ::flixel::FlxState,stateOnCall) HXARGC(0)
            			void _hx_run(){
            				HX_GC_STACKFRAME(&_hx_pos_d6e0db7350a23b34_22_create)
HXLINE(  22)				if (::hx::IsInstanceEq( ::flixel::FlxG_obj::game->_state,stateOnCall )) {
HXLINE(  22)					::flixel::FlxG_obj::game->_nextState = nextState;
            				}
            				else {
HXLINE(  22)					::flixel::FlxG_obj::log->advanced(HX_("`onOutroComplete` was called after the state was switched. This will be ignored",46,b2,58,c7),::flixel::_hx_system::debug::log::LogStyle_obj::WARNING,true,::hx::SourceInfo(HX_("flixel/FlxG.hx",36,68,17,8e),385,HX_("flixel.FlxG",07,ab,3b,0e),HX_("switchState",7d,07,8b,77)));
            				}
            			}
            			HX_END_LOCAL_FUNC0((void))

            			HX_GC_STACKFRAME(&_hx_pos_d6e0db7350a23b34_22_create)
HXLINE(  22)			 ::Dynamic nextState = ::flixel::util::typeLimit::_NextState::NextState_Impl__obj::fromMaker( ::Dynamic(new _hx_Closure_0()));
HXDLIN(  22)			 ::flixel::FlxState stateOnCall = ::flixel::FlxG_obj::game->_state;
HXDLIN(  22)			::flixel::FlxG_obj::game->_state->startOutro( ::Dynamic(new _hx_Closure_1(nextState,stateOnCall)));
            		}
            		HX_END_LOCAL_FUNC0((void))

            	HX_GC_STACKFRAME(&_hx_pos_d6e0db7350a23b34_13_create)
HXLINE(  14)		this->super::create();
HXLINE(  16)		this->add( ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null())->makeGraphic(::flixel::FlxG_obj::width,::flixel::FlxG_obj::height,-16777216,null(),null()));
HXLINE(  18)		 ::flixel::text::FlxText titulo =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,20,20,0,HX_W(u"\U0001f441\ufe0f Vista previa",d337,8092),null(),null());
HXLINE(  19)		titulo->setFormat(null(),18,-1,null(),null(),null(),null());
HXLINE(  20)		this->add(titulo);
HXLINE(  22)		this->add( ::flixel::ui::FlxButton_obj::__alloc( HX_CTX ,(::flixel::FlxG_obj::width - 160),20,HX_W(u"\u2190 Volver",2c44,1f12), ::Dynamic(new _hx_Closure_2())));
HXLINE(  25)		if ((::states::debug::MenuEditorState_obj::elementosCompartidos->get_length() > 0)) {
HXLINE(  26)			int _g = 0;
HXDLIN(  26)			::cpp::VirtualArray _g1 = ::states::debug::MenuEditorState_obj::elementosCompartidos;
HXDLIN(  26)			while((_g < _g1->get_length())){
HXLINE(  26)				 ::Dynamic elemento = _g1->__get(_g);
HXDLIN(  26)				_g = (_g + 1);
HXLINE(  27)				if (::Std_obj::isOfType(elemento,::hx::ClassOf< ::flixel::text::FlxText >())) {
HXLINE(  28)					 ::flixel::text::FlxText txt = ( ( ::flixel::text::FlxText)(elemento) );
HXLINE(  29)					Float txt1 = txt->x;
HXDLIN(  29)					Float txt2 = txt->y;
HXDLIN(  29)					Float copia = txt->get_fieldWidth();
HXDLIN(  29)					 ::flixel::text::FlxText copia1 =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,txt1,txt2,copia,txt->text,null(),null());
HXLINE(  30)					::String txt3 = txt->_font;
HXDLIN(  30)					int _hx_tmp = ::Std_obj::_hx_int(( (Float)(txt->_defaultFormat->size) ));
HXDLIN(  30)					int txt4 = txt->color;
HXDLIN(  30)					copia1->setFormat(txt3,_hx_tmp,txt4,::flixel::text::_FlxText::FlxTextAlign_Impl__obj::fromOpenFL(txt->_defaultFormat->align),null(),null(),null());
HXLINE(  31)					this->add(copia1);
            				}
            				else {
HXLINE(  32)					if (::Std_obj::isOfType(elemento,::hx::ClassOf< ::objetos::ImagenMenu >())) {
HXLINE(  33)						 ::objetos::ImagenMenu img = ( ( ::objetos::ImagenMenu)(elemento) );
HXLINE(  34)						 ::objetos::ImagenMenu copia2 =  ::objetos::ImagenMenu_obj::__alloc( HX_CTX ,img->x,img->y,img->ruta);
HXLINE(  35)						this->add(copia2);
            					}
            					else {
HXLINE(  36)						if (::Std_obj::isOfType(elemento,::hx::ClassOf< ::flixel::ui::FlxButton >())) {
HXLINE(  37)							 ::flixel::ui::FlxButton btn = ( ( ::flixel::ui::FlxButton)(elemento) );
HXLINE(  38)							::String copia3;
HXDLIN(  38)							if (::hx::IsNotNull( btn->label )) {
HXLINE(  38)								copia3 = btn->label->text;
            							}
            							else {
HXLINE(  38)								copia3 = null();
            							}
HXDLIN(  38)							 ::flixel::ui::FlxButton copia4 =  ::flixel::ui::FlxButton_obj::__alloc( HX_CTX ,btn->x,btn->y,copia3,null());
HXLINE(  39)							this->add(copia4);
            						}
            					}
            				}
            			}
            		}
            		else {
HXLINE(  43)			 ::flixel::text::FlxText aviso =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,0,0,::flixel::FlxG_obj::width,HX_W(u"\U0001f9ea Sin elementos\nCrea algo en el editor primero",7183,d302),null(),null());
HXLINE(  44)			aviso->setFormat(null(),16,-8355712,HX_("center",d5,25,db,05),null(),null(),null());
HXLINE(  45)			{
HXLINE(  45)				int axes = 17;
HXDLIN(  45)				bool _hx_tmp1;
HXDLIN(  45)				if ((axes != 1)) {
HXLINE(  45)					_hx_tmp1 = (axes == 17);
            				}
            				else {
HXLINE(  45)					_hx_tmp1 = true;
            				}
HXDLIN(  45)				if (_hx_tmp1) {
HXLINE(  45)					int _hx_tmp2 = ::flixel::FlxG_obj::width;
HXDLIN(  45)					aviso->set_x(((( (Float)(_hx_tmp2) ) - aviso->get_width()) / ( (Float)(2) )));
            				}
HXDLIN(  45)				bool _hx_tmp3;
HXDLIN(  45)				if ((axes != 16)) {
HXLINE(  45)					_hx_tmp3 = (axes == 17);
            				}
            				else {
HXLINE(  45)					_hx_tmp3 = true;
            				}
HXDLIN(  45)				if (_hx_tmp3) {
HXLINE(  45)					int _hx_tmp4 = ::flixel::FlxG_obj::height;
HXDLIN(  45)					aviso->set_y(((( (Float)(_hx_tmp4) ) - aviso->get_height()) / ( (Float)(2) )));
            				}
            			}
HXLINE(  46)			this->add(aviso);
            		}
            	}


void PreviewMenu_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_d6e0db7350a23b34_50_update)
HXLINE(  51)		this->super::update(elapsed);
HXLINE(  52)		 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN(  52)		if (_this->keyManager->checkStatusUnsafe(27,_this->status)) {
            			HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(0)
            			 ::states::debug::MenuEditorState _hx_run(){
            				HX_GC_STACKFRAME(&_hx_pos_d6e0db7350a23b34_52_update)
HXLINE(  52)				return  ::states::debug::MenuEditorState_obj::__alloc( HX_CTX );
            			}
            			HX_END_LOCAL_FUNC0(return)

            			HX_BEGIN_LOCAL_FUNC_S2(::hx::LocalFunc,_hx_Closure_1, ::Dynamic,nextState, ::flixel::FlxState,stateOnCall) HXARGC(0)
            			void _hx_run(){
            				HX_STACKFRAME(&_hx_pos_d6e0db7350a23b34_52_update)
HXLINE(  52)				if (::hx::IsInstanceEq( ::flixel::FlxG_obj::game->_state,stateOnCall )) {
HXLINE(  52)					::flixel::FlxG_obj::game->_nextState = nextState;
            				}
            				else {
HXLINE(  52)					::flixel::FlxG_obj::log->advanced(HX_("`onOutroComplete` was called after the state was switched. This will be ignored",46,b2,58,c7),::flixel::_hx_system::debug::log::LogStyle_obj::WARNING,true,::hx::SourceInfo(HX_("flixel/FlxG.hx",36,68,17,8e),385,HX_("flixel.FlxG",07,ab,3b,0e),HX_("switchState",7d,07,8b,77)));
            				}
            			}
            			HX_END_LOCAL_FUNC0((void))

HXLINE(  52)			 ::Dynamic nextState = ::flixel::util::typeLimit::_NextState::NextState_Impl__obj::fromMaker( ::Dynamic(new _hx_Closure_0()));
HXDLIN(  52)			 ::flixel::FlxState stateOnCall = ::flixel::FlxG_obj::game->_state;
HXDLIN(  52)			::flixel::FlxG_obj::game->_state->startOutro( ::Dynamic(new _hx_Closure_1(nextState,stateOnCall)));
            		}
            	}



::hx::ObjectPtr< PreviewMenu_obj > PreviewMenu_obj::__new() {
	::hx::ObjectPtr< PreviewMenu_obj > __this = new PreviewMenu_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< PreviewMenu_obj > PreviewMenu_obj::__alloc(::hx::Ctx *_hx_ctx) {
	PreviewMenu_obj *__this = (PreviewMenu_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(PreviewMenu_obj), true, "states.debug.PreviewMenu"));
	*(void **)__this = PreviewMenu_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

PreviewMenu_obj::PreviewMenu_obj()
{
}

::hx::Val PreviewMenu_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"create") ) { return ::hx::Val( create_dyn() ); }
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *PreviewMenu_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *PreviewMenu_obj_sStaticStorageInfo = 0;
#endif

static ::String PreviewMenu_obj_sMemberFields[] = {
	HX_("create",fc,66,0f,7c),
	HX_("update",09,86,05,87),
	::String(null()) };

::hx::Class PreviewMenu_obj::__mClass;

void PreviewMenu_obj::__register()
{
	PreviewMenu_obj _hx_dummy;
	PreviewMenu_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("states.debug.PreviewMenu",e0,80,3f,17);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(PreviewMenu_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< PreviewMenu_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = PreviewMenu_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = PreviewMenu_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace states
} // end namespace debug
